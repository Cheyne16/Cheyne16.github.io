<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Home</title>
    <link>/</link>
    <description>Recent content on Home</description>
    <image>
      <title>Home</title>
      <url>%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E</url>
      <link>%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E</link>
    </image>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Tue, 21 Feb 2023 16:29:43 +0000</lastBuildDate><atom:link href="/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>BUPT ch2 operating-system structures</title>
      <link>/posts/os/bupt-ch2-operating-system-structures/</link>
      <pubDate>Tue, 21 Feb 2023 16:29:43 +0000</pubDate>
      
      <guid>/posts/os/bupt-ch2-operating-system-structures/</guid>
      <description>BUPT ch2 operating-system structures 操作系统服务 一个操作系统的服务可以提供给：用户、进程、其他os
to user User interface - UI分为命令行CLI，图形化用户界面GUI，Batch Program execution I/O operations File-system manipulation communications - 进程间交换信息 Error detection to os 通过资源共享确保os自身的有效操作
Resource allocation Accounting Protection and security 用户接口 CLI 实现方式：内核、系统程序、多因素
GUI 用户友好
许多os同时存在CLI和GUI
系统调用 运行在用户空间的程序向操作系统内核请求需要更高权限运行的服务
为什么要用系统调用 它为用户空间提供了一种统一的硬件的抽象接口。
保证了系统的稳定和安全。
为什么使用API而不是系统调用？ 使用API来实现
Win32 API for Windows POSIX API for POSIX-based systems Java API for the Java virtual machine(JVM) 只需要遵循API，不用理解系统调用的内部实现。
系统调用参数传递方式 寄存器——最简单、参数少时、在用户态设置好寄存器的值然后进入内核态 块——参数放在块中，传递块的地址（地址放在栈中），在内核把参数拷贝过来 栈——程序将参数压入栈中，os将参数出栈 块、栈不限制参数的长度/数量
系统调用类型 进程控制
文件管理</description>
    </item>
    
    <item>
      <title>BUPT ch3 processes</title>
      <link>/posts/os/bupt-ch3-processes/</link>
      <pubDate>Tue, 21 Feb 2023 16:29:43 +0000</pubDate>
      
      <guid>/posts/os/bupt-ch3-processes/</guid>
      <description>BUPT ch3 processes 进程概念 即：运行中的程序
一个进程包括：程序计数器、栈、数据区域
进程的几种状态：new、running、waiting、ready、terminated
PCB（进程控制块）：包括 描述信息、控制信息、资源占用、现场保护
进程调度 进程切换 原因：中断 / 系统调用
过程：保存现场 —&amp;gt; 加载另一个进程的现场
进程调度队列 Job queue：所有进程
Ready queue：等待CPU资源
Device queue：等待IO设备
调度器 长期调度
短期调度
长期调度（控制进程的多道程度） 短期调度 中期调度 选择进程去 进入ready队列 分配CPU执行 效率 低 高 调用频率 不频繁 频繁 消耗时间 长 短 选取时要协调IO和计算的任务量 将进程从内存（或CPU竞争）中取出，降低内存中多道数据程度 进程上的操作 进程创建 父进程创建子进程，绵延成一棵进程树，他们之间有各种可能的情况：
资源共享——3种 执行次序——2种 地址空间——2种 进程终止 exit——正常退出 abort——异常退出 级联终止 非级联终止 合作进程 进程间通信 CS系统通信 </description>
    </item>
    
    <item>
      <title>ch1 概述</title>
      <link>/posts/computer-network/ch1-%E6%A6%82%E8%BF%B0/</link>
      <pubDate>Tue, 21 Feb 2023 16:29:43 +0000</pubDate>
      
      <guid>/posts/computer-network/ch1-%E6%A6%82%E8%BF%B0/</guid>
      <description>ch1思考问题：既然互联网的数据链路层和物理层不是一样的，那这两层如何通信的？
Internet ：起源于美国的那个网 internet ：互联网
Measure line speeds: (megabits/sec) 1 Mbps = 1,000,000 bits/sec (gigabits/sec) 1 Gbps = 1,000,000,000 bits/sec
​	TB PB
应用层的两种服务模式：p2p 和 CS
1. 什么是计算机网络 通信vs计算机：通信-传输信息；计算机-处理信息 分布式系统和计算机网络：分布式系统对于用户来说是透明、不可见的，是单一的系统，用户不会知道实际机器的存在。如 www。而计算机网络的异构性对用户是可见的。总结：两者硬件相同，都是独立的计算机构成的集合；区别在于软件（尤其是操作系统）。分布式系统是建立在网络之上的软件系统。 2. 计算机网络是干什么的 3. 计算机网络的分类 传输技术：
点到点链路 和 广播式链路 覆盖范围（最常用）：
覆盖范围 典型网络的种类 代表性设备 应用场景 PAN 个域网 1m 个人 master-slave paradigm （主从范式） 蓝牙 LAN 局域网 10m-1km 企业、家庭 广播式链路 有线：以太网（Ethernet）无线：WLAN（wifi） privately owned MAN 城域网 10km 城市 有线：有线电视网(Cable TV) 无线：WiMax (IEEE802.16) WAN 广域网 100km-1000km 全国 有线：拨号上网服务无线：3G,4G,5G 通信子网、交换设备与路由交换技术 Internet 互联网 10000km 世界 ISP（移动电信联通、教育网提供商） 以太网：每台计算机都使用以太网协议，并通过点对点链路连接到一个称为交换机的盒子</description>
    </item>
    
    <item>
      <title>ch1-编译概述</title>
      <link>/posts/principles-of-compiler/ch1-%E7%BC%96%E8%AF%91%E6%A6%82%E8%BF%B0/</link>
      <pubDate>Tue, 21 Feb 2023 16:29:43 +0000</pubDate>
      
      <guid>/posts/principles-of-compiler/ch1-%E7%BC%96%E8%AF%91%E6%A6%82%E8%BF%B0/</guid>
      <description>编译的几个过程 一、分析阶段 1. 词法分析 2. 语法分析 3. 语义分析 对语法成份（语法分析确定的层次结构）的意义进行检查分析 收集必要信息：类型、作用域等 工作依据：语义规则 重要类型：类型检查 根据规则检查每个运算符及其运算对象是否符合要求 数组的下标是否合法 过程调用时，形参与实参个数、类型是否匹配等。 二、综合阶段 4. 中间代码生成 5. 代码优化 6. 目标代码生成 三、符号表的管理 四、错误诊断和处理 </description>
    </item>
    
    <item>
      <title>ch14索引</title>
      <link>/posts/db/ch14%E7%B4%A2%E5%BC%95/</link>
      <pubDate>Tue, 21 Feb 2023 16:29:43 +0000</pubDate>
      
      <guid>/posts/db/ch14%E7%B4%A2%E5%BC%95/</guid>
      <description>update减速
insert无关</description>
    </item>
    
    <item>
      <title>ch16查询优化</title>
      <link>/posts/db/ch16%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96/</link>
      <pubDate>Tue, 21 Feb 2023 16:29:43 +0000</pubDate>
      
      <guid>/posts/db/ch16%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96/</guid>
      <description>启发式优化 先写出sql语句（view要写开）
拆开选择操作 下移选择操作 下移（同时添加）投影 </description>
    </item>
    
    <item>
      <title>ch17事务</title>
      <link>/posts/db/ch17%E4%BA%8B%E5%8A%A1/</link>
      <pubDate>Tue, 21 Feb 2023 16:29:43 +0000</pubDate>
      
      <guid>/posts/db/ch17%E4%BA%8B%E5%8A%A1/</guid>
      <description>调度 串行调度 以事务为单位
并发调度 以语句为单位
可串行化 等价于某个串行调度
冲突可串行化 冲突等价于某个串行调度
冲突等价：如果调度S可以经过一系列非冲突指令交换转换成调度S&amp;rsquo;，则称调度S与S&amp;rsquo;是冲突等价
冲突的操作：
用前驱图判断是否冲突可串行化 根据冲突操作的类型，判段是否存在冲突，有冲突就画边，构造优先图。如果无环，则是，可以写出执行序列；有环，则不是。
视图可串行化 可恢复调度与不可恢复调度 事务T9读取了事务T8所写的数据A，如果事务T8发生故障而回滚，就有可能引起T9的回滚，因此事务T8必须在T9提交之前进行提交，才能保证调度中事务是可恢复的。
如果T8在T9提交之前进行提交，则是可恢复调度； 反之，如果T9读取后立即提交，在T8提交之前提交，则是不可恢复调度。
级联回滚与非级联调度 级联回滚：后一个事务读取了前一个事务写的数据，如果前面的出错回滚，后面的全都要回滚。
非级联调度：在前一个事务提交之后，后面的事务才能读取其写的数据。</description>
    </item>
    
    <item>
      <title>ch2 物理层</title>
      <link>/posts/computer-network/ch2-%E7%89%A9%E7%90%86%E5%B1%82/</link>
      <pubDate>Tue, 21 Feb 2023 16:29:43 +0000</pubDate>
      
      <guid>/posts/computer-network/ch2-%E7%89%A9%E7%90%86%E5%B1%82/</guid>
      <description>总结 有线和无线？？？ 无线传输比有线传输：易出错，时延长，不安全；可定位，（带宽高？）
有线电视：同轴电缆 粗缆 卫星电视：卫星 数字电视？
电信号：高低电平 光信号：有 无 （强度会有不同）
各种传输介质总结 物理结构 工作原理 传输特性 分类 典型应用 磁性介质 磁带或可移动介质 人工运输 实际效率高 U盘 双绞线 two insulated copper wires 相互抵消，减少损耗 模拟/数字信号皆可速度在Mbps级别 UTP/STP(好) 最常用 同轴电缆 铜。 high bandwidth(1GHz)；excellent noise immunity 粗缆（数字信号）；细缆（模拟信号） 粗：以太网；细：有线电视 光纤 发送端-光纤-接收端；接口 光的全反射 High bandwidthLightweightSecurity 多模（互相影响）；单模（好） 无线电波 发射站-接收站 电磁波 地面传输&amp;lt;2MHz；天际传输2-30MHz；视距传输&amp;gt;30MHz 微波 Distance between repeaters: 80km 波以近乎直线的方式传播，发射和接收天线必须精确对准。 100M~10GHz；易受天气影响 the long-distance telephone transmission system 卫星 充当大型微波中继器 延时长；广播传播；成本与距离无关 GEO；MEO；LEO （第三周第一次 课前回顾复习）2.1 Basic Concepts on Data Communications 带宽 有两种：</description>
    </item>
    
    <item>
      <title>ch2-词法分析</title>
      <link>/posts/principles-of-compiler/ch2-%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/</link>
      <pubDate>Tue, 21 Feb 2023 16:29:43 +0000</pubDate>
      
      <guid>/posts/principles-of-compiler/ch2-%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/</guid>
      <description>序 词法分析程序的作用 扫描源程序、识别单词符号、生成记号流；
词法检查，把错误信息和源程序关联起来；
跳过注释和空白；
（创建符号表）。
1 与语法分析程序的关系 独立的一遍 / 作为其子程序 / 协同
2 词法分析程序的输入输出 实现方法 自动生成器、系统程序设计语言、汇编语言
设置缓冲区的必要性 需要超前扫描若干个字符
配对缓冲区 把单缓冲区分为两半。
普通的 / 每半区带有结束标记的缓冲器
输出 记号 模式 单词 类别编码 构词规则 一个特例 如：标识符的记号是id，常数的记号是num等 如：标识符：字母开头的字母数字串 如：position是标识符 ==记号影响语法分析的决策、属性影响记号的翻译==
一旦识别出一个记号后，就保留下其属性，就完事了；不同于符号表，不断完善添加信息。
3 记号的描述与识别 词法与正规文法 词法：描述语言的标识符、常数、运算符、标点符号等记号的文法 —— 正规文法 语法：借助记号来描述语言的结构的文法 —— 上下文无关文法 记号的文法 写出正规表达式/定义式，再由此写出正规文法
标识符：一般写作： id -&amp;gt; letter rid ; rid -&amp;gt; 3 / letter rid / digit rid [rid: (letter/digit)*] 常数 整数：digits -&amp;gt; digit remainder ; remainder -&amp;gt; 3 / digit remainder [remainder: (digit)*] 无符号数：很复杂 运算符：只讲了关系运算符 分界符 关键字 状态转换图与记号的识别 状态转换图 利用状态转换图识别记号 为线性文法构造相应的状态转换图 状态集合的构成 为每个非终结状态设置一个对应状态 开始符号对应初态 增加一个新的状态：终态 状态之间边的形成 4 词法分析程序的设计与实现 文法及状态转换图 语言说明、记号的正规文法、状态转换图</description>
    </item>
    
    <item>
      <title>ch2-语言及文法</title>
      <link>/posts/formal-languages-and-automata/ch2-%E8%AF%AD%E8%A8%80%E5%8F%8A%E6%96%87%E6%B3%95/</link>
      <pubDate>Tue, 21 Feb 2023 16:29:43 +0000</pubDate>
      
      <guid>/posts/formal-languages-and-automata/ch2-%E8%AF%AD%E8%A8%80%E5%8F%8A%E6%96%87%E6%B3%95/</guid>
      <description>2.1 语言的定义与运算 字符串的逆/倒置 闭包 *闭包：包括空串
+闭包：字母表T上的所有非空字符串构成的集合
语言 设 T 为字母表，则任何集合 L ⊆ T* 是字母表T上的一个语言（language）
语言的基本运算 L1L2 ≠ L2L1 语言的积不可交换
2.2 文法 定义：所谓文法是用来定义语言的一个数学模型
**元语言：**描述语言的语言。 文法是一种元语言，一种方法，根据文法产生出语言的句子
BNF 巴科斯范式 BNF范式通常被作为讨论某种程序设计语言语法的元语言
::= &amp;mdash;-&amp;gt; “定义为”
Chomsky文法体系 将::= 改为→表示可被代替
Chomsky文法体系中，任何一种文法必须包含有：
两个不同的有限符号的集合，即非终结符集合N和终结符集合T。 一个形式规则的有限集合P（生成式集合）， 一个起始符S 文法的核心是生成式的集合，它决定了语言中句子的产生
文法 形式定义：四元组（N, T, P, S）
由定义可知，α不能为空，至少存在一个非终结符；β可以为空。
推导与句型 产生式是单箭头，双箭头是推导的过程
直接推导 推导序列
推导序列的每一步，都产生一个字符串，这些字符串一般称为句型
句型和句子
由S经过文法G的推导序列得到的字符串α：
若α ∈（N∪T）*，则 α 称为文法G的句型。 若α ∈T*，则 α 称为文法G的句子。 可知：句型包括句子。
文法产生的语言 2.3 Chomsky文法体系分类 乔姆斯基文法体系回顾：
文法 G = (N, T, P, S); P: α→β 其中 α∈(N∪T)* N^+^ (N∪T)* , β∈(N∪T)*</description>
    </item>
    
    <item>
      <title>ch3 数据链路层</title>
      <link>/posts/computer-network/ch3-%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/</link>
      <pubDate>Tue, 21 Feb 2023 16:29:43 +0000</pubDate>
      
      <guid>/posts/computer-network/ch3-%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/</guid>
      <description>数据链路层 地位、功能 为网络层传来的packet加头和尾（即协议），再以frame形式的PDU传送给对等层，对等层通过成帧技术得到数据。 尾：检错码
该层功能在网卡上实现（小部分在操作系统驱动实现），所以功能不宜太复杂，而且现在物理传输介质比较好，所以甚至可以不用在链路层考虑差错控制（如 物理层用光纤）。现在的网卡和主机不分离，是一体的。
提供给网络层的三类服务： （丢失 差错 乱序 重复）
无连接服务： 无确认的： eg：UDP 1）应用层需要实时性高（时延、带宽）的服务，不在意传输质量（误码率）&amp;mdash;&amp;mdash; 实时音视频通信；2）底层物理传输介质非常好。 比如：有线局域网（有线、近距离 &amp;ndash;&amp;gt; 干扰少误码少） eg：以太网 有确认的： eg：无线系统，如 wifi &amp;mdash;&amp;gt; 因为网络传输链路质量不好，所以需要确认。 1）传输正确发确认信息（ACK），用的多。 eg: TCP 2）传输错误发确认信息（NAK） 有确认的面向连接服务：1）高层需要可靠传输；2）链路不好，距离长，易误码。 eg：TCP 技术 成帧 字符填充 和 比特填充 一样，只不过适用于不同协议（以字符/比特传输）。
前三个效率都不到100%。
可能多种技术并用，如 以太网 &amp;mdash; 第1+4种。
差错控制 错误种类：单个错误（常见），多个错误，数据包丢失
纠错 （适合易出错的信道） 前向纠错（FEC）：接收方能够检测并纠正错误，如 海明码 自动请求重传（ARQ）：适合误码率小于 10^-5^ 的信道。 检错 + 重传 （适合质量好的信道） 奇偶校验 交错校验 CRC （循环冗余校验）&amp;mdash;- 利用二进制除法 流量控制 和 差错控制 是结合在一起的
基于反馈的流量控制 &amp;mdash;- 6个协议，前三个：单工（一发一收）；后三个：双工 停等：一个帧，等一下。
​	太慢。尤其对带宽时延积大的，浪费信道。</description>
    </item>
    
    <item>
      <title>ch3-有限自动机和右线性文法</title>
      <link>/posts/formal-languages-and-automata/ch3-%E6%9C%89%E9%99%90%E8%87%AA%E5%8A%A8%E6%9C%BA%E5%92%8C%E5%8F%B3%E7%BA%BF%E6%80%A7%E6%96%87%E6%B3%95/</link>
      <pubDate>Tue, 21 Feb 2023 16:29:43 +0000</pubDate>
      
      <guid>/posts/formal-languages-and-automata/ch3-%E6%9C%89%E9%99%90%E8%87%AA%E5%8A%A8%E6%9C%BA%E5%92%8C%E5%8F%B3%E7%BA%BF%E6%80%A7%E6%96%87%E6%B3%95/</guid>
      <description>3.1&amp;amp;&amp;amp;3.2 有限自动机 具有离散 输入 输出系统的一种数学模型
每次转换的后继状态是否唯一：DFA/NFA
DFA-Deterministic finite automaton 定义：
接收的语言：输入结束后使DFA的状态到达终止状态。否则该字符串不能被DFA接收.
​	NFA-Nondeterministic finite automaton 对应一个输入,可以有多个转移, 到达不同的状态。具有在同一情况下可有不同选择的能力
定义：
接收的串：如果接收一个字符串后NFA进入一个状态集,而此集合中包含了一个F中的状态, 则称NFA接收该字符串.
​	3.3 NFA与DFA的等价性 一方面：DFA是NFA的特例，即每次转移后的状态只有一个的特例。所以DFA能接收的语言，NFA必然能接收。
另一方面：NFA能接收的语言，DFA必然能接收。这也可以证明，用子集构造法，对于任意一个NFA，构造一个接收同样语言的DFA。
==NFA&amp;mdash;&amp;gt;DFA（子集构造法）== 原理思想：把NFA中每一步所到达的状态总体都当作DFA的一个状态
过程：
（写的时候得到一个添一个即可，不用直接写出所有状态）
子集构造法得到DFA状态数：
3.4 带 ε-转移的有限自动机 当输入为ε时，也能引起状态转移
形式定义 增加了空转移
ε-闭包 状态 q 的 ε- 闭包：记为 ε - CLOSURE 或 ECLOSE ，定义为从 q 经所有的 ε 路径可以到达的状态（包括q自身）
状态子集I 的ε- 闭包：I 的各个元素的闭包的并集 Ia：I经过a到达的所有状态 的闭包的并集
δ1(q0, 0) = ε-CLOSURE(δ(q0, 0)) ε-NFA的语言 其中：δ&amp;rsquo; 与 δ 不同，前者包含空转移。（经过每一个字符前后都考虑空转移）
==ε-NFA&amp;mdash;&amp;gt;无εNFA== 具有ε转移的NFA是无ε转移的NFA的一般情况</description>
    </item>
    
    <item>
      <title>ch4 MACSublayer</title>
      <link>/posts/computer-network/ch4-macsublayer/</link>
      <pubDate>Tue, 21 Feb 2023 16:29:43 +0000</pubDate>
      
      <guid>/posts/computer-network/ch4-macsublayer/</guid>
      <description>物理层：repeater 识别bit，是一个冲突域
介质访问控制子层
4.1 信道分配问题 静态信道分配
动态信道分配（√）
4.2 多路访问协议 4.2.1 ALOHA 纯 ALOHA 冲突时间：2T~tran~（发送时延、帧时） &amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;ndash;（发送前T 和 发送时 T）
想发就发
在一个RTT内接收ACK，如果没有或者NAK，退避随机时间再重发
时隙 ALOHA 冲突时间：T~tran~ &amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;ndash;（发送前T）
将时间分片（槽），发帧和重传只能在槽的开始发送
比 pure ALOHA吞吐量高，效率高
4.2.2 CSMA Carrier Sense Multiple Access Protocols
CS：载波监听。检测电压摆动值。
MA：多点接入。
局域网中：==传播时间远远小于发送时间==，因为是在局域网内，距离短
协议思想：
发送之前，先监听信道（避免）
信道空闲：以一定概率发送帧
信道忙：等待直到信道空闲
非坚持CSMA：等待一个随机时间再重新监听载波
坚持CSMA：一直监听着
1-坚持CSMA：一直监听信道，空闲了直接发送 p-坚持CSMA：一直监听信道，空闲了以概率p发送，以概率p-1延迟一个随机时间后再发送 如果冲突：等待一个合理时间（RTT+ACK竞争时间）
如果未收到ACK，则重传
CSMA比较：
1-坚持 非坚持 低负载 高吞吐量、低延迟 高负载 低吞吐量 高吞吐量 评价MAC协议的指标： （低负载适合使用竞争方法）
低负载（轻载）情况下的时延
高负载（重载）情况下的吞吐量（信道利用率）
冲突时间：τ（propagation delay）
CSMA/CD ==以太网== IEEE 802.3 半双工通信系统；节省时间和宽带；以太网的技术基础
基本思想：
载波监听（避免冲突） 冲突检测（处理冲突）——边发边检测冲突，检测到冲突后：停止发送 + 发送jam信号 冲突检测原理：发的同时往回收，检测信号是否相同 无线网络发出的信号是接受信号的100万倍强度，覆盖了，收不回； 还与调制模式有关 退避（处理冲突）——等待随机时间后重传 状态：CSMA/CD 可能处于以下三个状态之一: 竞争，传输，空闲。</description>
    </item>
    
    <item>
      <title>ch4-上下文无关文法与下推自动机</title>
      <link>/posts/formal-languages-and-automata/ch4-%E4%B8%8A%E4%B8%8B%E6%96%87%E6%97%A0%E5%85%B3%E6%96%87%E6%B3%95%E4%B8%8E%E4%B8%8B%E6%8E%A8%E8%87%AA%E5%8A%A8%E6%9C%BA/</link>
      <pubDate>Tue, 21 Feb 2023 16:29:43 +0000</pubDate>
      
      <guid>/posts/formal-languages-and-automata/ch4-%E4%B8%8A%E4%B8%8B%E6%96%87%E6%97%A0%E5%85%B3%E6%96%87%E6%B3%95%E4%B8%8E%E4%B8%8B%E6%8E%A8%E8%87%AA%E5%8A%A8%E6%9C%BA/</guid>
      <description>没有一个普遍使用的算法，能够消除文法的二义性
有的文法是先天二义性
最左推导 对应 最右归纳；反之。。。
CFG的简化——顺序：（1）231 1. 消无用符号 无用符号包括：不可达符号 和 非生成符号
生成符号：从终结符往前找 可达符号：从起始符开始往后找 先用算法1消非生成符号，再用算法2消不可达符号，顺序不能反；
并且消去相关产生式
2. 消空产生式 可致空符号：能否经过一步或多步推出ε 如何计算：（1）一步可推出空（2）多步可推出空（B-&amp;gt;ACD,其中ACD都是可致空符号，则B也是）
无空文法：若G的生成式中无任何ε产生式,或只有一个生成式S→ε且S不出现在任何生成式的右边,则称G为无e文法 消空产生式：（1）找出可致空符号集合N‘（2）对每个存在可致空符号，加入替换后的式子(不加入S→ε，删除原有的S→ε)==（3）==如果S是可致空符号，加入新的起始符号S1，加入S1-&amp;gt;S|ε
3. 消单产生式 单产生式：形如 A -&amp;gt; B 的产生式，其中A、B 为非终结符
单元偶对：（A，B）是单元偶对，当且仅当A经过一系列单产生式推出B
消单产生式：对于每一个单元偶对（A，B），将B的所有非单产生式给到A
4. 消除递归 直接 和 间接
消除直接左递归 ==消除所有左递归== 生成式的标准形式（给机器看） Chomsky范式（CNF）：二叉树 ==先消空消单消无用在构成CNF==。
Greibach范式 (GNF)：避免左递归 &amp;mdash;&amp;gt; CNF
排序，代换（只代第一个字母）排序之后右边要么是终结符开头，要么相等，要么比左边大。若相等：消左递归
消左递归：代换时可能会消左递归；An一定消左递归
回代：可能会消左递归
消除左递归引入的符号，越后引入的级别越低 A
下推自动机 PDA(Push Down Automaton)
PDA的形式定义：一个七元组M = (Q, T, Γ, δ, q0, z0, F)，其中
Q 有限控制器状态集合 T 有限输入字母表 Γ 有限下推栈字母表 δ 状态转移函数 q0 初始状态 z0 下推栈起始符号 F 终态集合 转换函数的格式：δ(q, a, Z) = {(p, ω)}意为当前状态为q，当前栈顶为Z，接收字符a，转移为状态p，栈顶为ω。如果ω = ε则弹栈</description>
    </item>
    
    <item>
      <title>ch4-语法分析</title>
      <link>/posts/principles-of-compiler/ch4-%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90/</link>
      <pubDate>Tue, 21 Feb 2023 16:29:43 +0000</pubDate>
      
      <guid>/posts/principles-of-compiler/ch4-%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90/</guid>
      <description>4.1 语法分析简介 编译程序的核心工作。
语法分析程序的任务：
从源程序记号序列中识别出各类语法成分 进行语法检查 语法分析程序的地位：
由语法分析程序完成：
输入：语义分析出的记号流/序列 工作依据：源语言的语法规则 功能任务：从记号流中识别出各类语法成分、进行语法检查 输出：分析树 错误处理 常用的分析方法：
自顶向下 自底向上 对输入符号串的扫描顺序：自左向右
4.2 自顶向下分析方法 1. 递归下降分析 依次试探、谋求匹配。
试图为输入符号串建立一个==最左推导序列==。
实践中存在的困难和缺点：
左递归的文法，可能导致分析过程陷入死循环 ==回溯== 工作的重复 效率低、代价高：穷尽一切可能的试探法。 2. 递归调用预测分析 一种确定的、==不带回溯==的递归下降分析方法——能够根据所面临的输入符号准确地指派一个候选式去执行任务。
对文法的要求：
不含左递归
非终结符号的所有候选式的FIRST集两两互不相交
2.1 预测分析程序的构造 改写文法：重写文法、消除左递归、提取左公因子
（1）预测分析程序的转换图 为每个非终结符号创建一个转换图，每个候选式对应一条路径：
（2）转换图的工作过程 从文法开始符号所对应的转换图的开始状态开始分析，经过若干动作，向前分析，直到错误或到达结束状态。
（3）转换图的化简 用代入的方法进行化简：合并减去重复的边和状态，将简化后的代入其他里面化简
（4）预测分析程序的实现 要求用来描述预测分析程序的语言允许递归调用。
实现举例：
3. 非递归预测分析 使用一张分析表和一个栈联合控制，实现对输入符号串的自顶向下分析。
3.1 预测分析程序的模型及工作过程 算法4.1 非递归预测分析方法 3.2 预测分析表的构造 （1）改写文法 （2）FIRST集合及其构造 推导出的开头终结符号集
（3）FOLLOW集合及其构造 后面紧跟的终结符号集
（4）算法4.2 预测分析表的构造 3.2 LL(1)文法 如果一个文法的预测分析表M不含多重定义的表项， 则称该文法为LL(1)文法。
LL(1)的含义：
第一个L表示从左至右扫描输入符号串 第二个L表示生成输入串的一个最左推导 1表示在决定分析程序的每步动作时，向前看一个符号 3.</description>
    </item>
    
    <item>
      <title>ch5-NetworkLayer</title>
      <link>/posts/computer-network/ch5-networklayer/</link>
      <pubDate>Tue, 21 Feb 2023 16:29:43 +0000</pubDate>
      
      <guid>/posts/computer-network/ch5-networklayer/</guid>
      <description>问题 分组和分片的区别 adhoc网络——随机选路，哪学的 flooding序列号 复习Dijkstra DVR构造路径的过程 DVR好消息快，坏消息慢 学习拥塞控制前三个 111页实例 119 计算 习题知识点 电路交换预先分配资源，分组交换（虚电路、数据报）不会 任务 互联——不同网络 编址——统一地址，每个网络接口一个地址 分组——封装上层包，将其拆分成组 分片——适应不同的数据链路层技术 路由选择——路由器 为传输层提供的服务 虚电路 和 数据报
技术 路由算法 路由表 = 路由算法（DVR, LSR, PVR） + 路由协议（ 动态路由协议：RIP, OSPF, BGP）
路由算法：静态 or 自适应
最优化原则：两点间有更短的路径则更新拓扑
Dijkstra的“最短路径”算法：自己复习
选路策略：固定查表选路；洪泛(flooding）；随机选路；==自适应选路==
分级/层次路由：。。。
路由算法 Flooding （Distance Vector Routing）DVR (Link State Routing) LSR router所记录的 无需路由表 路由表：到每个节点的距离和下一跳 entire topology（只记录下一跳） 转发给 所有邻居（除incoming link） 所有邻居 **flooding **==LSP==（acked）（reliably） 转发时间 间隔性（RIP：30s） 拓扑改变时 五个过程：&amp;hellip;&amp;hellip; 超时删除记录（RIP：180s） LSP包：包含邻居的拓扑信息LSP包的构造：周期性/发生变故时集齐后，每个路由器计算自己的最短路径 应用 RIP (Routing Information Protocol) Cisco EIGRP (Enhanced Interior Gateway Routing Protocol) IS-ISOSPF 问题 重复 收敛慢好消息扩散快，坏消息传播慢无穷计数问题==基于谣传的选路== 解决方案 1-跳计数器递减至02-记录序列号 BGP-4 (Border Gateway Protocol) IDRP (Inter-domain Routing Protocol) 拥塞控制 增加资源 网络提供 业务量感知的路由 减少负载 接纳控制 业务量减速 负载掉落 前三个：闭环方案，避免。。。自己学 后两个：开环方案，处理</description>
    </item>
    
    <item>
      <title>ch5-图灵机</title>
      <link>/posts/formal-languages-and-automata/ch5-%E5%9B%BE%E7%81%B5%E6%9C%BA/</link>
      <pubDate>Tue, 21 Feb 2023 16:29:43 +0000</pubDate>
      
      <guid>/posts/formal-languages-and-automata/ch5-%E5%9B%BE%E7%81%B5%E6%9C%BA/</guid>
      <description>图灵机基础 图灵机与双向有限自动机的区别：图灵机可以改变“带(tape)”上的符号
图灵机TM(Turing Machine)的形式定义：一个七元组M = (Q, T, Σ, δ, q0, B, F)
Q 有限状态集 T 有限输入符号集 Σ 有限带符号集 δ 转移函数 q0 初始状态 B 特殊带符：空白符 F 终态集合 δ函数示例：δ(q, a) = (p, B, L)表示状态q接收输入a时转换为状态p，把带上面的a改写为B(空白符)，然后指针左移(L)
图灵机的格局：使用w1qw2来描述图灵机的格局，其中q为当前状态，w1与w2为指针左侧和右侧带上的字符串。约定：w1qw2表示正在扫描w2的最左字符，也就是指针指向w2的最左字符。w2 = ε时视为扫描空白符
图灵机的初态：处于状态q0（初始状态），指针在带的最左单元
图灵机接受的语言：能够使图灵机进入终止状态的串
停机：输入被接受时，图灵机将停止
停机问题 停机问题：任意给定一个图灵机和一个输入的串ω，问此串能否使此图灵机停机？
结论：停机问题不可解，即不可判定能否停机
使用图灵机构造整数函数计算机 使用一进制表示数，即整数k被表示为k个0
这样所有整数都可以通过不同数量的0（或其他字符）表示
图灵机可以实现整数函数的构造。举例：用图灵机实现求真减法：
if x &amp;gt; y then output x - y else output 0 那么初始带上的串应为0^x 1 0^y
思路：自动机把最左端的0改为空白符，然后寻找1后面的0，把它改成1，然后再向左搜索，找到空白符，把空白符之后的0改成空白符，再向右搜，收到1后面的0改成1。。。如果最后发现左侧没有0而右侧还有0就把右侧的所有0变成1。最后统计带子上面的0的个数就是结果
例2：设计图灵机接受L = {0^m | m = 2^n, n &amp;gt;= 0}</description>
    </item>
    
    <item>
      <title>ch5-语法制导翻译技术</title>
      <link>/posts/principles-of-compiler/ch5-%E8%AF%AD%E6%B3%95%E5%88%B6%E5%AF%BC%E7%BF%BB%E8%AF%91%E6%8A%80%E6%9C%AF/</link>
      <pubDate>Tue, 21 Feb 2023 16:29:43 +0000</pubDate>
      
      <guid>/posts/principles-of-compiler/ch5-%E8%AF%AD%E6%B3%95%E5%88%B6%E5%AF%BC%E7%BF%BB%E8%AF%91%E6%8A%80%E6%9C%AF/</guid>
      <description>注释分析树：结点带有属性值的分析树
综合属性：自下而上传递信息，通过子结点、自身的属性值来定义综合属性 （语义规则函数看成是相应产生式左部非终结符号的虚拟综合属性）
继承属性：自上而下传递信息，通过父结点、兄弟结点、自身的属性值来定义继承属性 （终结符没有继承属性。终结符从词法分析器处获得的属性值被归为综合属性值）
S属性定义：仅涉及综合属性的语法制导定义
L属性定义：如果与每个产生式 A-&amp;gt;X~1~X~2~X~3~&amp;hellip;X~n~ 相应的每条语义规则计算的属性都是：
A的综合属性 X~j~（1≤j≤n）的继承属性，且该继承属性仅依赖于： A的继承属性 产生式中X~j~左边的符号X~1~、X~2~、X~3~、&amp;hellip;、X~j-1~的属性 语法制导翻译过程 1 设计语法制导定义 如图</description>
    </item>
    
    <item>
      <title>ch6-TransportLayer</title>
      <link>/posts/computer-network/ch6-transportlayer/</link>
      <pubDate>Tue, 21 Feb 2023 16:29:43 +0000</pubDate>
      
      <guid>/posts/computer-network/ch6-transportlayer/</guid>
      <description>传输层 传输层
端口 用于区分应用层的不同进程
端口号16位
一个IP地址和一个端口号绑定一个套接字(socket)。不允许两个套接字监听同一端口
连接的建立与释放 三次握手建立连接
Client请求连接(seq = x) Server确认请求(seq = y, ACK = x) Client确认请求并发送数据(seq = x + 1, ACK = y) 如果Client发送了重复的请求，Server回复后Client需要用REJECT来释放重复链接
三次握手+定时器释放连接
连接释放方式：violent / graceful（单独释放）
TCP 传输控制协议(Transmission Control Protocol)
面向连接的服务
全双工点对点通信
完全可靠
（无丢失、重复、乱序）
具有自动重传机制，就算某机器断网重连了，原有通信也可以继续进行 一个TCP连接中一端崩溃或突然中断时称为半开连接，TCP设置了定时器定时探测是否出现了半开连接 可靠的连接建立与释放
协议头 长度可变。计算时默认按照20字节计算
源端口 &amp;amp; 目的端口 两字节/16位 序号 通信双方需要商定初始序号 4字节/32位 数据字段每有一个字节，序号+1 确认号ACK 4字节/32位 期望收到的下一个报文段数据的第一个字节的序号 比如收到的包的序列号是x，那么回复的ACK确认号应该是x+1 采用了捎带确认和累计确认技术 数据偏移 4位 因为TCP头长度不定，数据偏移用来说明数据部分在TCP包内的位置 单位为4字节/32位 保留字段 6位，应该置0 紧急比特URG 置1时紧急指针字段有效 确认比特ACK 置1时确认号ACK字段有效 推送比特PSH 置1时接收方一旦受到包就上交应用层而不填满缓冲区 复位比特RST 置1时表明传输出错，释放连接并重连 同步比特SYN 置1时表明这是连接请求或连接接收报文 终止比特FIN 置1时用来释放连接 窗口字段 2字节/16位 通知对方自己的接收窗口，使对方调整发送的数据量 单位为字节 校验和 2字节/16位 校验首部与数据 计算时要在TCP报文段前面加上12字节的伪首部，伪首部仅参与校验和的计算，不向上向下传递 计算方式和IP校验和计算方式相同 紧急指针 2字节/16位 指出本报文段中的紧急数据的最后一个字节的序号 选项字段 长度可变 TCP只规定了一个选项 - 最大报文段长度MSS(Maximum Segment Size) 告知对方本机的缓存的接受能力 默认值为536，单位为字节 来自IP网络层的限制，IP包头的**总长度字段(Total Length)**16位限制一个IP包内最多65535字节，减去IP协议头和TCP协议头，最大为65535-20-20=65495字节 来自数据链路层（以太网）MTU的限制，最大为1460字节 TCP连接的建立和释放 建立连接 三次握手 主动请求连接的进程为客户(Client) 被动接受连接的进程为服务器(Server) 释放连接 TCP是全双工通信，拥有两个单向连接，需要分别释放 四次握手，每释放一个单向连接需要两次握手 TCP连接建立过程（三次握手）：</description>
    </item>
    
    <item>
      <title>ch7-应用层</title>
      <link>/posts/computer-network/ch7-%E5%BA%94%E7%94%A8%E5%B1%82/</link>
      <pubDate>Tue, 21 Feb 2023 16:29:43 +0000</pubDate>
      
      <guid>/posts/computer-network/ch7-%E5%BA%94%E7%94%A8%E5%B1%82/</guid>
      <description>应用层 应用层
许多协议都是基于客户-服务器方式(CS)
DNS - Domain Name System 32位的IP地址难于记忆。DNS实现符号地址到IP地址的转换。DNS域名最长为256字节（包括符号）
基于CS模式 基于UDP包 分布式数据库系统 基于域的多层次命名系统 因特网域名结构 任何一个连接在因特网上的主机或路由器都有一个唯一的层次结构的名字，即域名 域名的结构有若干个分量组成，各分量之间用.隔开，如XXX.三级域名.二级域名.顶级域名 各分量分别代表不同级别的域名 因特网采用了树状的命名方法，一个高级域名下有多个低级域名 域名解析流程 当应用程序（比如浏览器）需要进行域名解析时，它成为域名系统的一个客户，把域名放在DNS报文中向本地域名服务器发出请求。本地域名服务器找到IP地址后响应。
本地域名服务器无法完成解析时，它临时变成其上级域名名服务器的客户，递归或迭代解析，知道域名解析完成
递归解析 主机www.ibm.com获取xyz.usst.edu.cn的IP地址的过程如图
高层服务器的态度是“好的我去给你找”，可以看到如果高层服务器（根域名服务器）的任务量非常重
迭代解析 相同的问题，迭代解析过程如图
高层服务器的态度是“你应该去这里找”，这样就减轻了高层服务器的任务量
实际应用中使用迭代解析
WWW万维网(World Wide Web) 简称WEB
WEB的CS模型 每个WEB服务器上都有一个进程在TCP的80端口监听由浏览器发来的请求。连接建立后浏览器和服务器之间使用HTTP超文本传输协议进行信息传输
HTTP协议基于TCP，工作流程：
建立TCP连接 Client: HTTP请求报文 Server: HTTP响应报文 释放TCP连接 WEB需要的基本技术 统一资源定位符URL 超链接使用URL寻找网页 URL由三部分组成 协议类型 - HTTP/FTP/… 网页所在机器地址 - 域名或IP 网页文件名 URL的一般形式：&amp;lt;Protocol&amp;gt;://&amp;lt;Host&amp;gt;&amp;lt;:Port&amp;gt;&amp;lt;/Path&amp;gt; URL对大小写不敏感 超文本传输协议HTTP 基于TCP 虽然TCP面向连接，但是HTTP不是面向连接的服务，而是面向事务的，一旦事务结束就中断连接 服务器默认端口号80 报文结构图：
注意首部结束之后无论有没有实体都要有一个空行
请求报文 有两个方法：GET &amp;amp; POST，GET在url中附上请求内容，不能附带实体。POST不在url中附上请求，保密性更好。可以附带实体，如表单
请求报文举例：已知一个HTML页面中有标签&amp;lt;a href=&amp;quot;www.info-source.com/welcome.html&amp;quot;&amp;gt;click here for info&amp;lt;/a&amp;gt;，点击超链接后发送的请求为：
GET /welcome.</description>
    </item>
    
    <item>
      <title>ch7-运行时环境</title>
      <link>/posts/principles-of-compiler/ch7-%E8%BF%90%E8%A1%8C%E6%97%B6%E7%8E%AF%E5%A2%83/</link>
      <pubDate>Tue, 21 Feb 2023 16:29:43 +0000</pubDate>
      
      <guid>/posts/principles-of-compiler/ch7-%E8%BF%90%E8%A1%8C%E6%97%B6%E7%8E%AF%E5%A2%83/</guid>
      <description>运行时环境的内容，主要是分配数据位置，确定访问变量时的机制，过程的链接和参数传递等。
本章主题包括存储管理、变量和数据的访问。
存储分配的方式
代码区和静态区位于底部，堆区向上生长，栈区向下生长
静态分配：编译时
动态分配：生成目标程序时
栈式存储：与过程的调用/返回同步进行分配和回收 堆存储：手工进行回收，需要垃圾回收机制 栈式分配
活动树
过程调用在时间上是嵌套的，因此可以用栈来分配空间 程序所有过程活动可以用树表示 活动记录
每个活跃的活动对应栈中的活动记录
实参 返回值 控制链 访问链 保存的机器状态 局部数据 临时变量 调用代码序列
调用代码序列分配空间，返回代码序列恢复机器状态
尽量把代码放在被调用者中
调用代码序列
计算实参值 把返回值和原top sp放到被调者的活动记录，并增加top sp的值 被调者的保存寄存器值等状态 被调者初始化局部数据 返回代码序列
被调用者把返回值放到与参数相邻的位置 恢复top sp和寄存器，跳转到返回地址 从实参到控制链，虽然是被调用者的活动记录，但是其是由调用者负责的 栈中的变长数据
如果数据的生命周期局限于过程活动，那么就可以分配在栈中，变长数组也是可以的 使用两个指针，top指向实际栈顶，top sp寻找顶层记录的定长字段（有点base的感觉） 非局部数据的访问
C语言中，全局变量在静态区，地址在编译时刻可知
Pascal语言中，因为有嵌套过程，所以需要访问链
访问链用于访问非局部的数据 如果过程p的声明嵌套在过程q，那么p的访问链指向上层最近的活动记录 嵌套深度：声明时的嵌套深度，最外层为1 显示表 堆管理
存放生命周期不确定或明确被删除为止的数据对象
例如：new -&amp;gt; delete, malloc -&amp;gt; free
存储管理器
C/C++需要手动回收，Java可以自动回收
基本功能：分配一段连续，大小适当的堆空间；把被回收的空间返回空闲空间缓冲池
评价指标：
空间效率：使程序所需要的对空间最小 程序效率：运用内存系统的层次，使程序运行更快 低开销：使分配/收回内存的操作高效 程序的局部性：空间局部性和时间局部性
堆空间分配方法：
best-fit：选择满足请求的最小窗口 first-fit：放在第一个可容纳的窗口。但是总体性能会较差，但是拥有较好的数据局部性 垃圾回收
什么是垃圾
广义：不需要再被引用的数据 狭义：不能被引用的数据 垃圾回收：自动回收不可达数据的机制</description>
    </item>
    
    <item>
      <title>ch7NF后半部分笔记</title>
      <link>/posts/db/ch7nf%E5%90%8E%E5%8D%8A%E9%83%A8%E5%88%86%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Tue, 21 Feb 2023 16:29:43 +0000</pubDate>
      
      <guid>/posts/db/ch7nf%E5%90%8E%E5%8D%8A%E9%83%A8%E5%88%86%E7%AC%94%E8%AE%B0/</guid>
      <description>无损分解 将关系模式R分解成 关系模式$ R_1和R_2$,则:
$R_1 \cap R_2 \to R_1 或 R_2 $ ; 即$R_1 和 R_2 的交集是R_1 或 R_2 $的super key
函数保持 通过分解后的求闭包，若等于F^+^，则保持
最小依赖集（正则覆盖） 无关属性 函数依赖集F保证了数据库数据的有效性，但是检查F闭包的开销比较大，因此可以检查拥有相同闭包的函数依赖集f，f是F的最小依赖集，它们拥有相同的闭包。如果去除函数依赖中的一个属性而没有改变该函数依赖集的闭包，则称该属性是无关的。
《数据库系统概念》8.4.3节，无关属性的定义：函数依赖集F及F中的函数依赖α→β
如果A∈α并且F逻辑蕴含(F – { α → β }) ∪ { ( α – A ) → β }，则A是在α中是无关属性。 如果A∈β并且函数依赖集(F – { α → β }) ∪ { α → ( β – A ) }逻辑蕴含F，则A在β中是无关属性。 怎么找无关属性A（对于函数依赖 a -&amp;gt; b）：
若 A∈a，看 (a-A)^+^ (F) 是否包含 b，如果包含，则A是无关属性 通过原来的函数依赖集求去掉无关属性后的a的闭包，是否包含b 若 A∈b，看 (a)^+^ (F&amp;rsquo;) 是否包含 A，如果包含，则A是无关属性 (F&amp;rsquo; = F – { a → b }) ∪ { a → ( b – A ) } 通过消去后的函数依赖集求a的闭包，看是否包含b 正则覆盖（最小覆盖） 理解：去除无关属性到不能再去为止（F和Fc等价）</description>
    </item>
    
    <item>
      <title>xv6</title>
      <link>/posts/os/xv6/</link>
      <pubDate>Tue, 21 Feb 2023 16:29:43 +0000</pubDate>
      
      <guid>/posts/os/xv6/</guid>
      <description>教程 ：第零章 操作系统接口 | xv6 中文文档 (gitbooks.io)
刚开始没有装qemu，安装后sudo apt-get install qemu ，运行成功</description>
    </item>
    
    <item>
      <title>历史</title>
      <link>/posts/os/%E5%8E%86%E5%8F%B2/</link>
      <pubDate>Tue, 21 Feb 2023 16:29:43 +0000</pubDate>
      
      <guid>/posts/os/%E5%8E%86%E5%8F%B2/</guid>
      <description>Intel CPU 家谱 </description>
    </item>
    
    <item>
      <title>寄存器</title>
      <link>/posts/os/%E5%AF%84%E5%AD%98%E5%99%A8/</link>
      <pubDate>Tue, 21 Feb 2023 16:29:43 +0000</pubDate>
      
      <guid>/posts/os/%E5%AF%84%E5%AD%98%E5%99%A8/</guid>
      <description>16位 8位 32位 段寄存器 </description>
    </item>
    
    <item>
      <title>概念</title>
      <link>/posts/principles-of-compiler/%E6%A6%82%E5%BF%B5/</link>
      <pubDate>Tue, 21 Feb 2023 16:29:43 +0000</pubDate>
      
      <guid>/posts/principles-of-compiler/%E6%A6%82%E5%BF%B5/</guid>
      <description>短语 简单短语 句柄 </description>
    </item>
    
    <item>
      <title>王道 Part1 概述</title>
      <link>/posts/os/%E7%8E%8B%E9%81%93-part1-%E6%A6%82%E8%BF%B0/</link>
      <pubDate>Tue, 21 Feb 2023 16:29:43 +0000</pubDate>
      
      <guid>/posts/os/%E7%8E%8B%E9%81%93-part1-%E6%A6%82%E8%BF%B0/</guid>
      <description>1 综述 程序接口：一组系统调用
命令接口：
联机命令接口：=交互式命令接口，用户说一句， 系统跟着做一句，如cmd 脱机命令接口：=批处理命令接口，用户说一堆， 系统跟着做一堆，如 *.bat文件 2 特征 并发：表面同时进行，实际交替进行，比如一个CPU同时运行多任务 并行：真正同时进行，如多个CPU，每个CPU运行一个任务
如果失去并发性，则系统中只有一个程序正在运行，则共享性失去存在的意义； 如果失去共享性，则QQ和微信不能同时访问硬盘资源，就无法实现同时发送文件，也就无法并发。
如果失去了并发性，则一个时间段内系统中只需运行一道程序，那么就失去了实现虚拟性的意义了。因此，没有并发性，就谈不上虚拟性。
异步是指，在多道程序环境下，允许多个程序并发执行，但由于资源有限，进程的执行不是一贯到底的， 而是走走停停，以不可预知的速度向前推进，这就是进程的异步性。如果失去了并发性，即系统只能串行地运行各个程序，那么每个程序的执行会一贯到底。只有系统拥有并发性，才有可能导致异步性。
3 发展和分类 多道批处理系统阶段：操作系统正式诞生，用于持多道程序并发运行
4 运行机制 4.1 计算机系统的层次结构 4.2 内核 内核是计算机上配置的底层==软件==，是操作系统最基本、最核心的部分
操作系统的内核程序是系统的管理者， 既可以执行特权指令，也可以执行非特权指令
但是，操作系统的功能未必都在内核里，比如GUI。操作系统分为内核部分和非内核部分。内核只是操作系统最核心重要的部分。
4.3 内核态-用户态 CPU 中有一个寄存器叫 ==程序状态字寄存器==（PSW），其中有个二进制位，1表示 “内核态”，0表示“用户态” 别名：内核态=核心态= ==管态==；用户态= ==目态==
程序状态字（PSW）寄存器用于记录当前处理器的状态和控制指令的执行顺序，并且保留与运行程序相关的各种信息，主要作用是实现程序状态的保护和恢复。 所以中断处理程序要将PSW保存，子程序调用在进程内部执行，不会更改PSW。
内核态 &amp;mdash;&amp;gt; 用户态：执行一条特权指令——修改PSW的标志位为“用户态”，这个动作意味着操作系统将主动让出CPU使用权 用户态 &amp;mdash;&amp;gt; 内核态：由“中断”引发，硬件自动完成变态过程，触发中断信号意味着操作系统将强行夺回CPU的使用权
4.4 操作系统的体系结构 此处只讲了两种：
大内核/宏内核/单内核： Linux、UNIX
微内核： Windows NT
微内核降低性能举例：
4.5 总结 5 中断和异常 “中断”是让操作系统内核夺回CPU使用权的唯一途径
如果没有“中断”机制，那么一旦应用程序上CPU运行，CPU就会一直运行这个应用程序
内中断/外中断：与当前执行的指令有无关系；中断信号来源于CPU内部还是外部
==举例==
内中断 试图在用户态下执行特权指令 &amp;mdash;-abort 【abort：由致命错误引起，内核程序无法 修复该错误，因此一般不再将CPU 使用权还给引发终止的应用程序， 而是直接终止该应用程序】 执行除法指令时发现除数为 0 &amp;mdash;-abort 系统调用 &amp;mdash;-trap 【trap：有时候应用程序想请求操作系统内核的服务，此时会执行一条特殊的指令——陷入指令，该指令会引发一个内部中断信号（执行“陷入指令”，意味着应用程序主动地将CPU控制权还给操作系统内核。 “系统调用”就是通过陷入指令完成的）】 缺页故障 &amp;mdash;-fault 【fault：由错误条件引起的，可能被内核程序修复。内核程序修复故障后会把 CPU使用权还给应用程序，让它继续执行 下去】 外中断 时钟中断——由时钟部件发来的中断信号（时钟部件每隔一个时间 片（如 50ms）会给CPU 发送一个时钟中断信号） I/O中断——由输入/输出设备发来的中断信号（当输入输出任务完成时， 向CPU发送中断信号） 大多数的教材、试卷中，“中断”特指狭义的中断，即外中断。而内中断一般称为“异常”</description>
    </item>
    
    <item>
      <title>王道 Part2 进程管理</title>
      <link>/posts/os/%E7%8E%8B%E9%81%93-part2-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/</link>
      <pubDate>Tue, 21 Feb 2023 16:29:43 +0000</pubDate>
      
      <guid>/posts/os/%E7%8E%8B%E9%81%93-part2-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/</guid>
      <description>==1 进程组成== 1.1 PCB PCB不包括==user data==
1.2 总结 PCB 是给 操作系统 用的； 程序段、数据段是 给进程自己用的， 与进程自身的运行 逻辑有关。
进程是动态的，进程实体（进程映像）是静态的。 进程实体反应了进程在某一时刻的状态（如：x++后，x=2）。
进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位。
程序是静态的，进程是动态的。进程是程序的一次执行过程，动态地产生、变化、消亡。
2 进程的组织方式 3 进程状态与转换 进程PCB中，会有一个变量 state 来表示进程的当前状态。如：1表示创建态、2表示就绪态、3表示运行态… 为了对同一个状态下的各个进程进行统一的管理，操作系统会将各个进程的PCB组织起来。
进程的整个生命周期 中，大部分时间都处 于三种基本状态。
单CPU情况下，同一时刻只会有一 个进程处于运行态，多核CPU情况 下，可能有多个进程处于运行态
4 进程控制 如果不能“一气呵成”，就有可能导致操作系 统中的某些关键数据结构信息不统一的情况， 这会影响操作系统进行别的管理工作。
4.1 如何实现原语的“原子性”？ 原语的执行具有原子性，即执行过程只能一气呵成，期间不允许被中断。 可以用 “关中断指令”和“开中断指令”这两个特权指令实现原子性。
==正常情况==：CPU每执行完一条指令都会例 行检查是否有中断信号需要处理，如果有， 则暂停运行当前这段程序，转而执行相应 的中断处理程序。中断处理结 束之后也不一定 会直接回到原进 程执行。
==原语==：CPU执行了关中断指令之后，就不再例行 检查中断信号，直到执行开中断指令之后 才会恢复检查。 这样，关中断、开中断 之间的这些指令序 列就是不可被中断的，这就实现了“原子 性”
4.2 进程控制相关的原语 5 进程通信 进程是分配系统资源的单位（包括内存地址空间），因此各进程拥有的内存地址空间相互独立。
为了保证安全，一个进程不能直接访问另一个进程的地址空间。但是进程之间的信息交换又是必须实现的。 为了保证进程间的安全通信，操作系统提供了一些方法。
共享内存：
基于数据结构的共享：比如共享空间里只能放 一个长度为10的数组。这种共享方式速度慢、 限制多，是一种低级通信方式 基于存储区的共享：在内存中画出一块共享存 储区，数据的形式、存放位置都由进程控制， 而不是操作系统。相比之下，这种共享方式速 度更快，是一种高级通信方式。 消息传递：</description>
    </item>
    
    <item>
      <title>王道 Part3 内存管理</title>
      <link>/posts/os/%E7%8E%8B%E9%81%93-part3-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</link>
      <pubDate>Tue, 21 Feb 2023 16:29:43 +0000</pubDate>
      
      <guid>/posts/os/%E7%8E%8B%E9%81%93-part3-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</guid>
      <description>1 预备知识 逻辑地址 to 物理地址：（地址绑定）
==绝对装入==：在编译的时候就转换为最终的地址。需要提前知道装入模块要装到哪，只适用于单道程序环境。 ==静态重定位/可重定位装入==：编译链接后还是从0开始，装入内存的时候转换为最终的地址。要求装入的内存连续且运行中不能移动。 ==动态重定位/动态运行时装入==：（现在使用的）装入内存后不一定立刻转换，而是在程序真正执行时转换。转换用到重定位寄存器。装入的内存可以不连续且运行中可以移动。（需要基址MMU） 链接的三种方式：
静态链接：先链接成一个装入模块，再装入 装入时动态链接：所有模块边装入边链接 运行时动态链接：用到的模块边装入边链接 2 内存管理概述 内存空间的分配与回收 连续分配——单一、固定分区、动态分区 非连续分配——基本分页、段、段页 内存空间的扩充 覆盖技术 交换技术 虚拟存储技术 地址转换 编译时绑定 加载时绑定 （可重定位装入） 运行时绑定 存储保护——利用寄存器 3 内存空间的分配与回收 3.1 连续分配管理方式 3.1.1 单一连续分配 分为系统区和用户区
只能有一道用户程序
有内部碎片（分配给某进程的内存中没用上的部分）
3.1.2 固定分区分配 把用户区划分为若干个固定大小的分区
可进行多道用户程序
数据结构——分区说明表：每个分区的大小、起始状态、是否已分配（状态）
有内部碎片（分配给某进程的内存中没用上的部分）
3.1.3 动态分区分配 进程装入内存时，动态建立分区
系统分区的大小和数目是可变的
数据结构——空闲分区表/空闲分区链
动态分区分配算法
首次适应算法（first fit）—— 从低地址开始查找第一个能满足大小的空闲分区（按地址大小排列） 最佳适应算法（best fit）——优先使用更小的空闲分区（按容量递增排列）&amp;mdash;&amp;gt; 会产生很多碎片 最坏适应算法（worst fit）——同最佳适应算法相反&amp;mdash;&amp;gt;大进程无法进行了 邻近适应算法（next fit）——在首次适应算法上改进：每次从上次查找结束的位置开始查找，减少开销 只有外部碎片（内存中某些空闲分区由于太小了不能用）——用紧凑技术来解决
3.2 非连续分配管理方式 3.2.0 总结 ==访存次数==
基本分页、分段：2 &amp;mdash;&amp;mdash;- 先表后内存 具有快表的分页： 多级页表：n级——n+1次 段页式：3 ———— 段表 页表 内存 ==判断越界==</description>
    </item>
    
    <item>
      <title>王道 Part4 文件管理</title>
      <link>/posts/os/%E7%8E%8B%E9%81%93-part4-%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/</link>
      <pubDate>Tue, 21 Feb 2023 16:29:43 +0000</pubDate>
      
      <guid>/posts/os/%E7%8E%8B%E9%81%93-part4-%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/</guid>
      <description>1 文件管理简介 2 文件的逻辑结构 3 文件目录 4 文件的物理结构 5 物理结构 vs 逻辑结构 </description>
    </item>
    
    <item>
      <title>王道 Part5 IO-Systems</title>
      <link>/posts/os/%E7%8E%8B%E9%81%93-part5-io-systems/</link>
      <pubDate>Tue, 21 Feb 2023 16:29:43 +0000</pubDate>
      
      <guid>/posts/os/%E7%8E%8B%E9%81%93-part5-io-systems/</guid>
      <description>设备管理</description>
    </item>
    
    <item>
      <title>第1章 计算机概述</title>
      <link>/posts/principles-of-computer-organization/%E7%AC%AC1%E7%AB%A0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%A6%82%E8%BF%B0/</link>
      <pubDate>Tue, 21 Feb 2023 16:29:43 +0000</pubDate>
      
      <guid>/posts/principles-of-computer-organization/%E7%AC%AC1%E7%AB%A0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%A6%82%E8%BF%B0/</guid>
      <description>1.1 计 算 机 的 分 类 和 应 用 面 向 应 用 的 分 类 通 用 计 算 机 超 级 计 算 机 、 大 型 机 、 服 务 器 、 工 作 站 、 微 型 机 、 单 片 机 专 用 计 算 机/ 嵌 入 式 （Embedded ） 计 算 机 计 算 机 的 应 用 领 域 科 学 计 算， 信 息 处 理，实 时 控 制，人 工 智 能，计 算 机 辅 助 设 计，娱 乐 和 游 戏</description>
    </item>
    
    <item>
      <title>第2章 运算方法与运算器-上</title>
      <link>/posts/principles-of-computer-organization/%E7%AC%AC2%E7%AB%A0-%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95%E4%B8%8E%E8%BF%90%E7%AE%97%E5%99%A8-%E4%B8%8A/</link>
      <pubDate>Tue, 21 Feb 2023 16:29:43 +0000</pubDate>
      
      <guid>/posts/principles-of-computer-organization/%E7%AC%AC2%E7%AB%A0-%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95%E4%B8%8E%E8%BF%90%E7%AE%97%E5%99%A8-%E4%B8%8A/</guid>
      <description>第2章 运算方法和运算器 数据与文字的表示方法 数据的表示方法 真值与机器码 常见有符号数机器码包括：原码、补码、反码、移码
原码：十进制数据的二进制表现形式，最左边为符号位，0为正，1为负 弊端：计算时，正数没问题，但负数的运算方向和正确方向相反 反码：为了解决原码不能计算负数的问题而出现的。正数不变，负数在原码的基础上，符号位不变，其它位取反 弊端：负数运算时，结果不能跨0，否则，跟实际结果会有1的偏差 补码：为了解决负数计算跨0的问题而出现的。正数不变，负数在反码的基础上，加一 补码还能多记录一个特殊的值-128，该数据在一个字节下，没有原码和反码 计算机的存储和计算都是以补码形式进行 采 用 补 码 进 行 减 法 运 算 比 原 码 方 便 ， 减 法 运 算 可 变 成 加 法 运 算。 补 码 、 反 码 和 移 码 的 符 号 位 在 加 减 运 算 时 可 以 当 作 为 数 值 看 待 ， 但 原 码 的 符 号 位 必 须 单 独 处 理 移码：在真值上加一个偏移值。假设x为n（不包括符号位）位， ~移~ = 2^n^ + x (2^n^ &amp;gt; x &amp;gt;= -2^n^) 移码和补码符号相反，尾数相同，[＋0] ~移~ ＝[－0] ~移~ ＝10000000 易于比较大小 数据类型所占字节数 符号位扩展 符号位为0：补0</description>
    </item>
    
    <item>
      <title>第2章 运算方法与运算器-下</title>
      <link>/posts/principles-of-computer-organization/%E7%AC%AC2%E7%AB%A0-%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95%E4%B8%8E%E8%BF%90%E7%AE%97%E5%99%A8-%E4%B8%8B/</link>
      <pubDate>Tue, 21 Feb 2023 16:29:43 +0000</pubDate>
      
      <guid>/posts/principles-of-computer-organization/%E7%AC%AC2%E7%AB%A0-%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95%E4%B8%8E%E8%BF%90%E7%AE%97%E5%99%A8-%E4%B8%8B/</guid>
      <description>2.3 定点乘法运算 硬件能实现的 软件都可以
原码乘法：（以定点小数为例） 符号位异或，然后小数部分（绝对值）相乘
部分积： 阵列乘法器（计算更快）的延时计算 图中红线延时最长：
a1b1&amp;mdash;&amp;ndash;T 前4个：4*6T（这里多算一T）&amp;mdash;&amp;ndash;前三个：被加数到和输出6T；最后一个：被加数到进位输出5T。 前4个：4*2T（这里少算一T）&amp;mdash;&amp;ndash;前三个：进位输出到和进位输出2T；最后一个：进位输出到和输出3T。 总共：T + (n-1)6T + (n-1)2T = (8n-7)T
2.4 定点除法运算 2.4.1 原码除法算法原理 基本原理：符号位异或，数值部分相除。
计算机内的两种计算方法：
恢复余数法：默认商1，相减后如果是负数，再恢复回去。 加减交替法：比较 余数的2倍（被减数） - 减数，然后根据正负选择 商为1/0 以及 下一个余数=2*此余数 +/- y 2.4.2 并行除法器 （1） 可控加法/减法（CAS）单元 当输入P=0时，是一位全加器；P=1时，求差。
一个CAS单元的延迟为3T。
CAS单元将应用于阵列除法器中。
（2） 加减交替的阵列除法器 2n位小数（尾数部分）除以n位小数（尾数部分）&amp;mdash;-&amp;gt; 需要 n^2^ 个CAS单元（看除数位数） &amp;mdash;-&amp;gt; 延迟为 3(n+1)^2^T
2.5 定点运算器的组成 2.5.1 逻辑运算 计算机中的运算分为：
算术运算&amp;mdash;&amp;ndash;加减乘除
逻辑运算&amp;mdash;-逻辑非（求反），逻辑加（或），逻辑乘（与），逻辑异（按位加，按位求模2和）
逻辑运算的应用
2.5.2 多功能算术/逻辑运算单元（ALU） 基于 **一位加法器（FA）**改进，使其具备两个功能：
进行多种算术运算和逻辑运算，而不是只能加减 具备先行进位逻辑，从而实现高速运算 改进方法：
将输入的Ai 和 Bi通过S0、S1、S2、S3组合成多种形式，再作为一位加法器的输入。 通过**先行进位发生器(CLA)**可以将低位的进位输出直接传送给高位，从而实现高速运算。 运算实现：</description>
    </item>
    
    <item>
      <title>第3章 存储系统</title>
      <link>/posts/principles-of-computer-organization/%E7%AC%AC3%E7%AB%A0-%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/</link>
      <pubDate>Tue, 21 Feb 2023 16:29:43 +0000</pubDate>
      
      <guid>/posts/principles-of-computer-organization/%E7%AC%AC3%E7%AB%A0-%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/</guid>
      <description>基本概念 主存：RAM + ROM（BIOS），二者统一编址
存储器的分类 按层次结构：（即 内存/外存）
主存、高速缓存 —— 可直接被CPU读写 辅存 —— 不可&amp;hellip;&amp;hellip; 按存储介质：
半导体存储器（主存、Cache） 磁介质存储器（磁盘、磁带） 光存储器 按存取方式： （1：并行访问存储器；2、3：串行访问存储器）
随机存取存储器 RAM —— 访问速度不受地址（物理位置）影响 （部分ROM也是随机存取） 顺序存取存储器 SAM 直接存取存储器 DAM （寻址方式介于两者之间） 相联存储器 CAM （按照内容访问，前面都是按照地址访问） 按信息的可更改性：
RAM 可读写 ROM 只读 按信息的可保存性：
易失性存储器（主存、Cache）—— 断电后数据是否消失
非易失性存储器（磁盘、光盘）
破坏性读出（DRAM芯片）—— 读出后数据是否被破坏
非破坏性读出（==SRAM芯片==、磁盘、光盘）
存储器的性能指标 存储容量：存储字数（MAR）× 字长（MDR） 存储字数即存储单元数 单位成本：每位价格=总成本/总容量 存储速度：数据传输率=数据的宽度/存储周期 通常 存取周期 &amp;raquo; 存取时间
主存储器的基本组成 主存：RAM + ROM（BIOS），二者统一编址
基本的半导体元件 MOS场效应管：可以理解为一种电控开关，当电压达到一定值时导通。
利用MOS管就可以 监测/写入 存储元存储的信息；字长（数据总线宽度）个存储元构成一个存储单元。
存储器芯片的基本原理 译码器：通过译码器将地址总线（n位）对应上存储单元（2^n^个），每一个地址对应一条字选线。
控制电路：当地址总线数据或译码器译出的数据稳定后，再进行操作。还要控制读、写、片选等操作
判断一个芯片有多少条暴露在外的金属引脚：地址线，数据线，片选线，读写控制线（1/2根）。（DRAM地址线为位数的一半）
寻址：
现在计算机通常按字节寻址。</description>
    </item>
    
    <item>
      <title>第4章 指令系统</title>
      <link>/posts/principles-of-computer-organization/%E7%AC%AC4%E7%AB%A0-%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/</link>
      <pubDate>Tue, 21 Feb 2023 16:29:43 +0000</pubDate>
      
      <guid>/posts/principles-of-computer-organization/%E7%AC%AC4%E7%AB%A0-%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/</guid>
      <description>基本概念 **指令(Instruction)**指计算机执行某种操作的命令
**指令系统（ISA Instruction Set Architecture）**也称 指令集架构，一台计算机中所有机器指令的集合
高级语言 - 语句和用法与具体机器的指令系统无关 低级语言 - 面向机器的语言，和具体机器的指令系统密切相关 比较 高级语言 低级语言 通用算法 有 有 语言规则 少 多 编程需要硬件知识 不需要 需要 独立于机器 独立 不独立 编程难易度 易 难 编程时间 短 长 程序执行时间 长 短 编译过程中对计算机资源的占用 多 少 指令格式 基础 指令字（简称指令），即表示一条指令的机器字（机器码）
指令的构成：
操作码字段 - 定义操作 操作数地址字段 - 指定操作数的地址 操作码：表示指令对应的操作。操作码字段的长度取决于计算机指令系统的规模。如某指令系统有8条（种）指令，操作码只需3位即可。指令字中的操作码长度可以使固定的也可以是变长的
按操作数地址数量分类 按照指令中操作数（地址）的个数X（类似于高级语言中函数的参数），可以把指令称为X操作数指令或X地址指令
通常指令可以根据操作数地址数量划分为：
三地址指令 二地址指令 一地址指令 零地址指令 零地址指令：只有操作码，没有地址码
一地址指令：称为单操作数指令，指令中只有一个操作数或者是指令默认以运算器中累加寄存器AC中的数为操作数1，操作结果又放回累加寄存器AC中，类似于高级语言函数中的默认参数。符号表达为(AC) OP (A) -&amp;gt; AC，其中OP表示操作，AC和A表示地址。AC为累加寄存器地址。地址加括号表示取地址中的数据，类似于C语言中对指针的解引用
二地址指令：称为双操作数指令。两个地址码表明两个操作数的地址，结果存放在其中一个地址处。符号表达为(A1) OP (A2) -&amp;gt; A1
三地址指令：指令字中有三个操作数地址。符号表达为(A1) OP (A2) -&amp;gt; A3。A1为被操作数地址或源操作数地址。A1为操作数地址或终点操作数地址。A3为存放结果的地址</description>
    </item>
    
    <item>
      <title>第5章 中央处理器</title>
      <link>/posts/principles-of-computer-organization/%E7%AC%AC5%E7%AB%A0-%E4%B8%AD%E5%A4%AE%E5%A4%84%E7%90%86%E5%99%A8/</link>
      <pubDate>Tue, 21 Feb 2023 16:29:43 +0000</pubDate>
      
      <guid>/posts/principles-of-computer-organization/%E7%AC%AC5%E7%AB%A0-%E4%B8%AD%E5%A4%AE%E5%A4%84%E7%90%86%E5%99%A8/</guid>
      <description>中央处理器 中央处理器
CPU的功能 指令控制 控制程序按照顺序执行 操作控制 传送不同的信号 时间控制 各种操作的同步 数据加工 算数逻辑运算 中断处理 对异常情况和特殊请求的处理 CPU的基本组成 控制器与运算器 控制器 由程序计数器PC、指令寄存器IR、指令译码器、操作控制器和时序产生器组成（不包括地址译码器） 运算器 由算数逻辑单元ALU、累加寄存器AC、数据缓冲寄存器DR和状态条件寄存器PSW组成 重要的寄存器 数据缓冲寄存器
DR
存放从cache读出的字或来自外部接口的字或ALU运算结果 写数据cache时也先用DR暂存 用来作为ALU运算结果和通用寄存器之间信息传送时时间上的缓冲 补偿CPU和内存、外设之间速度的差别 指令寄存器
IR
用来保存当前正在执行的一条指令 指令的操作码会流向指令译码器，译码后即可向控制器发出信号 程序计数器
PC
也叫指令计数器。用来保存下一条指令的地址 程序开始执行前先把程序的第一条指令所在地址置入PC CPU会自行修改PC的值 地址寄存器
AR
用来保存当前处理器访问的数据cache中的单元地址 通用寄存器R0-R3
不同的计算机的通用寄存器数量不同。可以几十上百个。教学举例通常使用四个 为ALU提供暂存数据的工作区 其中的累加寄存器AC暂存ALU的运算结果 状态条件寄存器
PSW
根据算数结果、逻辑指令等信息得到了状态条件 包括运算结果进位标志C，运算结果溢出标志V，运算结果为0表示Z，最算结果为负标志N 每个标志位由一个触发器保存 保存中断和系统工作状态等信息 CPU的寄存器中 对用户透明的（不可见的）：存储器地址寄存器、存储器数据寄存器、指令寄存器 可见的：通用寄存器、程序状态寄存器、程序计数器 数据通路 各寄存器之间、寄存器与ALU之间传送数据的通路称为数据通路。信息从哪里出发，中间经过哪个寄存器或多路开关，最后传送到哪个寄存器，都要加以控制。
在各寄存器之间建立数据通路的任务由操作控制器完成
操作控制器 根据指令操作码和时序信号，产生各种操作控制信号，以便正确地建立数据通路
根据设计方法不同，操作控制器可以分为
时序逻辑型 - 使用时序逻辑技术实现，称为硬布线控制器 存储逻辑型 - 使用存储逻辑实现，称为微程序控制器 时序产生器 对各种操作信号进行时间上先后顺序的控制
指令周期 基本概念 冯诺依曼机，即存储程序式计算机，在程序运行前需要把程序和数据放入内存
执行程序流程：
把程序首地址送入PC 从内存cache中取指，执行，并形成下一条指令的地址 自动执行直到程序的最后一条指令 也就是“取指-执行”的循环</description>
    </item>
    
    <item>
      <title>第6章 总线系统</title>
      <link>/posts/principles-of-computer-organization/%E7%AC%AC6%E7%AB%A0-%E6%80%BB%E7%BA%BF%E7%B3%BB%E7%BB%9F/</link>
      <pubDate>Tue, 21 Feb 2023 16:29:43 +0000</pubDate>
      
      <guid>/posts/principles-of-computer-organization/%E7%AC%AC6%E7%AB%A0-%E6%80%BB%E7%BA%BF%E7%B3%BB%E7%BB%9F/</guid>
      <description>总线系统 总线系统
概念 解决外部设备种类多样的问题。使用相同的总线标准的外设可以在不同计算机之间兼容
缺点：成为信息通道的瓶颈。总线带宽限制了整条总线的吞吐量
总线的层次结构：
早期总线内部结构：
当代总线内部结构：
总线的性能指标 总线宽度 - 数据线的条数 总线传输率（总线带宽） - 每秒传输最大字节或比特数 总线定时协定 - 同步方式、异步方式、半同步方式、分离方式 信号线数 - 地址线、数据线、控制线的总和 总线接口 计算机传输信息有两种基本方式：
串行传送 并行传送 处于速度与效率上的考虑，总线使用并行传送
串行传送 只需要一根传输线，长距离传输有优势。但是速度慢
并行传送 每一位数据需要一根传输线
地址和数据分时传送，即总线的分时复用
总线上的多个部件分时共享总线
接口的基本功能 控制 缓冲 状态控制 转换数据 程序中断 总线仲裁 主设备与从设备 总线事务包括两个部分：
发起命令与地址 传输数据 主设备与从设备之间可以双向数据传输
只有主设备可以给从设备发出命令与地址，是总线事务的发起者
从设备是总线事务的响应者
主设备发出读命令时把数据发送到主设备 主设备发出写命令时接收主设备发来的数据并写入 仲裁基础 总线仲裁解决多个主设备争用总线的问题。因为在外设给CPU发送消息时外设是主设备
总线占用期：主设备持续控制总线的时间
总线仲裁的基本方式：
集中仲裁 链式查询 计数器定时查询 独立请求方式 分布仲裁 集中仲裁由主设备统一管理，就像有红绿灯的十字路口的车辆统一受红绿灯的控制。分布仲裁就像没有红绿灯的十字路口，所有车辆先停下确认没有其他车辆后通行
链式查询方式 总线申请者通过置/BR=0发出总线申请 如果/BR=0且总线空闲(/BB=1)时，总线控制器置BG=1，响应总线请求 若模块没有申请总线却收到了BG=1则继续传递BG=1 若模块发出了总线申请，且/BR=0, /BB=1，此时收到了BG=1，则把BG置0（即不再向下传输），并把/BB置0，表示总线已被占用 使用完总线后把/BB置1表示归还总线 优点：
实现简单，只需要固定数量的控制线实现优先级控制 便于增删总线上的设备，总线控制器的结构与总线上的模块数量无关 缺点：
故障敏感，某个模块故障之后，后面的模块都不能正常查询 仲裁速度慢，主设备越多时间越长 优先级不能改变，低优先级设备可能饿死 计数器定时查询方式 设备申请总线时，通过/BR发出总线请求，中央仲裁器接收到请求后在BB线为0（总线空闲）的情况下启动计数器开始计数，计数值通过一组地址线发给各设备，每个设备接口都有一个设备地址判别电路，当地址线上的计数值与总线请求的设备的设备地址一致时，该设备获得使用权，把BB线置1，计数器暂停计数</description>
    </item>
    
    <item>
      <title>第7章 外设</title>
      <link>/posts/principles-of-computer-organization/%E7%AC%AC7%E7%AB%A0-%E5%A4%96%E8%AE%BE/</link>
      <pubDate>Tue, 21 Feb 2023 16:29:43 +0000</pubDate>
      
      <guid>/posts/principles-of-computer-organization/%E7%AC%AC7%E7%AB%A0-%E5%A4%96%E8%AE%BE/</guid>
      <description>外围设备 外围设备
磁盘存储设备 优缺点 优点：
存储量大，位价格低 记录介质可重复使用 记录信息可长期保存不丢失 非破坏性读出 缺点：
存取速度慢 机械结构复杂 工作环境要求高（无尘） 分类 按盘片结构分 可换盘式 固定盘式 按磁头分 可移动磁头 固定磁头 基本组成 磁记录介质 硬质圆形盘片的磁表面存储器 驱动器 写入电路与读出电路 读写转换开关 读写磁头与磁头定位私服系统 磁盘控制器 控制逻辑与时序 数据并-串变换电路和串-并变换电路 磁盘驱动器 对环境要求高，必须在超净的环境下组装
主要包括
定位驱动系统 主轴系统 数据转换系统 磁盘控制器 磁盘存储器是高速外存设备，与主机之间采用成批交换数据方式
是主机与磁盘驱动器之间的接口（控制器），所以有两个接口：
与主机的接口 - 控制外存与主机总线之间交换数据 与设备的接口 - 根据主机命令控制设备的操作 磁盘上信息的分布 磁盘地址：面-磁道-扇区
寻址过程：驱动器号 - 磁头号（面） - 磁道号（柱面） - 扇区号
因为距离圆心的距离不同，磁道长度不同，但是同一面上的不同磁道的信息总量是相同的，所以越远离圆心，磁道上的信息越稀疏
技术指标 存储密度 道密度 - 沿磁盘半径方向单位长度上的磁道数，单位为“道/英寸” 位密度 - 磁道单位长度能记录的二进制代码位数，单位“位/英寸”，随磁道位置的不同而不同。同一张磁盘上有最大位密度和最小位密度 面密度 - 道密度与位密度的乘积，单位“位/平方英寸” 存储容量 一个磁盘存储器所能存储的字节总量。分为格式化容量和非格式化容量 格式化容量 - 按照某种特定的记录格式所能存储信息的总量，也就是用户可以使用的容量 非格式化容量 - 磁记录表面可利用的磁化单元总数=磁头数（面数）*每个面的磁道数（柱面数）每个磁道的扇区数每个扇区的字节数 格式化容量一般为非格式化的60%-70% 平均存取时间 平均寻道时间(seek time) - 把磁头定位到目标磁道上所需的时间。是最大找道时间与最小找道时间的平均值。5-10ms 平均等待时间(rotational latency) - 已经找到指定磁道后需要访问的信息到达磁头下面的时间。简称等待时间，与磁盘转速有关，用磁盘旋转一周所需时间的一半来表示。3-6ms 平均存取时间 = 平均寻道时间 + 平均等待时间 数据传输率 单位时间内能够读出的数据量。等于每个磁道的信息量除磁盘转一周的时间 优化磁盘存储技术 提高磁盘机主轴转速 提高IO总线速度 使用磁盘cache弥补慢速磁盘与高速主存之间的速度差异 独立/廉价磁盘冗余阵列RAID Redundant Arrays of Independent/Inexpensive Disks</description>
    </item>
    
    <item>
      <title>第8章 输入输出系统</title>
      <link>/posts/principles-of-computer-organization/%E7%AC%AC8%E7%AB%A0-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F/</link>
      <pubDate>Tue, 21 Feb 2023 16:29:43 +0000</pubDate>
      
      <guid>/posts/principles-of-computer-organization/%E7%AC%AC8%E7%AB%A0-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F/</guid>
      <description>输入与输出系统 输入与输出系统
外围设备的定时方式和信息交换方式 根据外设速度把外设分类：
速度极慢或简单的外设 CPU只需要接收或者发送数据即可。无条件传送 慢速或者中速的设备 异步传送方式（应答） 高速外设 同步传送 数据传输方式：
程序查询方式(Polling) 程序中断方式 直接存储器存取(DMA: Direct Memory Access) 通道方式（过时） 程序查询方式 最简单的输入输出方式
CPU需要不断查询并等待慢速外设 效率低，CPU与外设不能并行工作。如果外设多，可能还需要链式查询，慢 接口电路简单，硬件开销小 程序中断方式 外设通过接口向CPU发出中断请求，CPU有能力执行中断时转去执行中断，执行完毕后再回到主程序
中断系统是计算机实现中断功能的软硬件总称，一般包括：
在CPU中设置的中断机构 在系统中设置的中断控制器 在软件上设置相应的中断服务程序 中断处理过程：
中断请求 中断排队与判优 中断响应 暂时中断主程序（即现在执行的程序），发出中断响应信号 保存断点（即返回地址） 关中断（不再允许中断） 查找中断源，获取中断服务程序的入口地址 中断处理 保护现场（即保护主程序目前的状态） 中断服务（即给中断源提供服务） 恢复现场并中断返回，开中断（允许中断） 中断源的识别：
单级中断中采用串行排队链实现公共请求线的中断源判优识别 也可以采用中断控制器判断 转中断服务程序的方法：
预先规定中断服务程序的入口地址 或使用中断向量（类似于设备的名字），通过链式查表的方式找到入口地址 如图，使用中断向量和中断控制器，首先根据中断控制器获取中断向量
然后根据中断向量链式查找设备入口地址
单级中断不允许其他程序在中断中再次中断，中断响应不允许嵌套
多级中断通常称为中断嵌套方式，优先级高的中断可以打断优先级低的中断。类似于高级语言中的函数嵌套。使用堆栈保存现场
二维多级中断结构
DMA方式 正常情况下外设从内存获得数据需要通过CPU的中转。而CPU为运算设计，所以单独设计一个用于数据转移的部件DMA控制器
基本思想：通过硬件实现主存与IO设备的直接数据传送，传送过程中无需CPU干预，速度快
过程：
申请阶段 - DMA控制器收到DMA传送请求后向CPU发出总线请求信号申请占用总线 响应阶段 - CPU响应总线请求，释放总线，回送总线应答信号，表示已经让出总线 数据传送阶段 - DMA控制器收到总线应答信号后占用总线，分别向存储器和外设发出读写控制信号，完成数据传送操作，记录传送字的个数 传送结束阶段 - 规定字数传送完毕后DMA控制器以中断方式或状态位的方式向CPU报告，释放总线，CPU重新占用总线 DMA传送方式：
成组传送 传送过程中CPU停止访存 控制简单，适用于数据传输率很高的设备 但是CPU无法处理紧急事件，数据块也不能太大 周期窃取 每次占用一个CPU周期，只让CPU暂停工作一个周期 但是总线申请和归还存在过多的时间开销 DMA与CPU交替访存 不需要总线使用权的申请与归还，总线使用权通过C1和C2分时进行(C1+C2=CPU周期) 也称为透明DMA方式，CPU不停止主程序也不等待 前提条件：CPU工作周期比内存存取周期长很多 通道方式 通道是计算机系统中代替CPU管理外设的独立部件，是一种能执行有限IO指令集的处理机 一个主机可以连接几个通道，每个通道可以连接多个IO设备 通道完成IO操作而不需CPU介入，数据交换结束后向CPU发出中断请求交换数据 通道类型：</description>
    </item>
    
    <item>
      <title>计算机启动</title>
      <link>/posts/os/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%90%AF%E5%8A%A8/</link>
      <pubDate>Tue, 21 Feb 2023 16:29:43 +0000</pubDate>
      
      <guid>/posts/os/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%90%AF%E5%8A%A8/</guid>
      <description>计算机的整个启动过程分成四个阶段 加载ROM里的BIOS——BIOS程序主要包括硬件自检和初始化程序、CMOS设置程序、系统自动装载程序和主要I/O驱动程序和中断服务（BIOS和硬件直接打交道，需要加载I/O驱动程序）。
硬件自检 硬件自检完成后，BIOS把控制权转交给下一阶段的启动程序，即读取指定软盘的主引导扇区（依据”启动顺序“） 读取主引导扇区加载到内存地址 0x7c00
BIOS把控制权转交给下一阶段的启动程序后，计算机将读取该软盘的第一个扇区（512字节）：
如果该扇区最后两个字节是0x55和0xAA，则说明这个扇区的开头是启动程序，所以该设备可以用于启动，然后就开始执行这个程序 如果不是，表明该设备不能用于启动，控制权于是被转交给“启动顺序”中的下一个设备 这个被读取的第一个扇区或者该扇区的前446字节就被称为主引导记录（MBR）或主引导扇区。
主引导记录只有512个字节，放不了太多东西。它的主要作用是，告诉计算机到硬盘的哪一个位置去找操作系统。
主引导记录（master boot record,MBR）位于硬盘的第一物理扇区。由于历史原因，硬盘的一个扇区大小是512字节，包含最多446字节的启动代码（调用操作系统的机器码）、4个硬盘分区表项（每个表项16字节，共64字节，作用：将硬盘分成若干个区）、2个签名字节（0x55,0xAA）。
第二部分&amp;quot;分区表&amp;quot;的作用，是将硬盘分成若干个区（每个区可以安装各自的操作系统，所以最多4个系统共存），在启动时确定将控制权交给哪个操作系统
​	（1） 第1个字节：如果为0x80，就表示该主分区是激活分区，控制权要转交给这个分区。四个主分区里面只能有一个是激活的。
（2） 第2-4个字节：主分区第一个扇区的物理位置（柱面、磁头、扇区号等等）。
（3） 第5个字节：主分区类型。
（4） 第6-8个字节：主分区最后一个扇区的物理位置。
（5） 第9-12字节：该主分区第一个扇区的逻辑地址。
（6） 第13-16字节：主分区的扇区总数（≤2^32^个）。
分区表将硬盘分为多个主分区，每个主分区又由一个个扇区组成，要使用更大的硬盘，有两种手段：提高扇区数，提高每个扇区的大小。
硬盘启动
通过分区表，计算机的控制权就要转交给硬盘的某个分区了，这里又分成三种情况。
卷引导记录——将活动分区中第一逻辑扇区数据加载到内存中。在DOS分区中, 该扇区内容被称为DOS引导记录, 简称DBR。&amp;ldquo;卷引导记录&amp;quot;的主要作用是，告诉计算机，操作系统在这个分区里的位置。然后，计算机就会加载操作系统了。
扩展分区和逻辑分区——四个主分区中有一个可以扩展，扩展后的是逻辑分区，逻辑分区的第一个扇区是扩展引导记录，它里面也包含一张64字节的分区表，但是最多只有两项（也就是两个逻辑分区）。但是，似乎很少通过这种方式启动操作系统。如果操作系统确实安装在扩展分区，一般采用下一种方式启动。
启动管理器——在这种情况下，计算机读取&amp;quot;主引导记录&amp;quot;前面446字节的机器码之后，不再把控制权转交给某一个分区，而是运行事先安装的&amp;ldquo;启动管理器&amp;rdquo;（boot loader），由用户选择启动哪一个操作系统。
Linux环境中，目前最流行的启动管理器是Grub。
加载操作系统内核 将控制权交给内核
控制权转交给操作系统后，操作系统的内核首先被载入内存。
以Linux系统为例，先载入/boot目录下面的kernel。内核加载成功后，第一个运行的程序是/sbin/init。它根据配置文件（Debian系统是/etc/initab）产生init进程。这是Linux启动后的第一个进程，pid进程编号为1，其他进程都是它的后代。
然后，init线程加载系统的各个模块，比如窗口程序和网络程序，直至执行/bin/login程序，跳出登录界面，等待用户输入用户名和密码。
至此，全部启动过程完成。
启动区为什么加载到内存中的地址0x7C00处 0x7C00这个地址来自Intel的第一代个人电脑芯片8088，以后的CPU为了保持兼容，一直使用这个地址。1981年8月，IBM公司最早的个人电脑IBM PC 5150上市，就用了这个芯片。
当时，搭配的操作系统是86-DOS。这个操作系统需要的内存最少是32KB。我们知道，内存地址从0x0000开始编号，32KB的内存就是0x0000～0x7FFF。
8088芯片本身需要占用0x0000～0x03FF，用来保存各种中断处理程序的储存位置。（主引导记录本身就是中断信号INT 19h的处理程序。）所以，内存只剩下0x0400～0x7FFF可以使用。
**为了把尽量多的连续内存留给操作系统，主引导记录就被放到了内存地址的尾部。**由于一个扇区是512字节，主引导记录本身也会产生数据，需要另外留出512字节保存。所以，它的预留位置就变成了：
0x7FFF - 512 - 512 + 1 = 0x7C00 计算机启动后，32KB内存的使用情况如下。
+--------------------- 0x0 | Interrupts vectors +--------------------- 0x400 | BIOS data area +--------------------- 0x5?</description>
    </item>
    
    <item>
      <title>Python基础</title>
      <link>/posts/python/python%E5%9F%BA%E7%A1%80/</link>
      <pubDate>Sat, 18 Feb 2023 22:55:42 +0800</pubDate>
      
      <guid>/posts/python/python%E5%9F%BA%E7%A1%80/</guid>
      <description>变量 变量的赋值传递通过引用 改变x的值，y的值也变
拷贝 浅拷贝——复制表层（默认，更快） 对于一维列表：拷贝整个列表对象。修改原本不影响副本。功能相当于深拷贝
对于嵌套列表：只拷贝外层对象，而内层对象拷贝的是引用
❌： 副本也被修改，此时需要用深拷贝
下面的B即浅拷贝： 深拷贝——完全复制 copy：浅拷贝
deepcopy：深拷贝，拷贝每个子对象
交换两个变量 x, y = y, x
随机数攻击 浮点数操作 复数 数字操作 短路逻辑 运算符优先级 流程图 条件表达式 判断素数 列表 切片 方法 增 append/extend：在末尾添加一个元素/可迭代对象
用切片的方法在末尾添加： insert(pos, element)： 删 remove：只删除第一个，没有就报错
pop：删除指定下标元素
clear
改 指定下标替换元素原理： 排序、倒序： 查 count、index函数： 列表推导式 速度比循环快。
循环修改原来的列表，列表推导式创建新的列表然后赋值。
用列表推导式创建嵌套列表（这样各个子列表互不影响）： 列表推导式的嵌套 实现 笛卡尔乘积： kiss原则： 元组 打包解压
不可修改
没有元组推导式，有生成器： 生成只有一个元素的元组： 序列类型对象的打包解包（多重赋值的实现原理）： 元组内的可变元素是可变的： 字符串 回文数判断 方法 拆分：
拼接：join比+快
格式化字符串 f-string python 3.6
序列——列表 元组 字符串 列表：可变序列</description>
    </item>
    
    <item>
      <title>第8章 排序</title>
      <link>/posts/ds/%E7%AC%AC8%E7%AB%A0-%E6%8E%92%E5%BA%8F/</link>
      <pubDate>Tue, 15 Nov 2022 00:08:41 +0000</pubDate>
      
      <guid>/posts/ds/%E7%AC%AC8%E7%AB%A0-%E6%8E%92%E5%BA%8F/</guid>
      <description>概念 排序算法的稳定性：排序之后元素的相对顺序不变。
稳定的是否一定比不稳定的好：不一定，看实际需求。
分类：
内部排序：数据都在内存中——关注时间、空间复杂度 外部排序：数据太多，无法全部放入内存——还要关注如何使磁盘读写次数更少 插入排序 直接插入排序 普通实现：
void InsertSort(int A[], int n) { int i, j, temp; for (i=1; i&amp;lt;n; i++) if (A[i]&amp;lt;A[i-1]) { temp = A[i]; for (j=i-1; j&amp;gt;=0 &amp;amp;&amp;amp; A[j]&amp;gt;temp; --j) A[j+1] = A[j]; A[j+1] = temp; } } 带哨兵实现：不用每轮都判断 j&amp;gt;=0
void InsertSort(int A[], int n) { int i, j; for (i=2; i&amp;lt;n; i++) if (A[i]&amp;lt;A[i-1]) { A[0] = A[i]; for (j=i-1; A[j]&amp;gt;A[0]; --j) A[j+1] = A[j]; A[j+1] = A[0]; } } 算法效率分析：</description>
    </item>
    
    <item>
      <title>第7章 查找</title>
      <link>/posts/ds/%E7%AC%AC7%E7%AB%A0-%E6%9F%A5%E6%89%BE/</link>
      <pubDate>Tue, 15 Nov 2022 00:08:33 +0000</pubDate>
      
      <guid>/posts/ds/%E7%AC%AC7%E7%AB%A0-%E6%9F%A5%E6%89%BE/</guid>
      <description>概念 关键字：唯一标识数据元素的数据项。
查找表分为静态、动态。
查找算法的评价指标：
评价一个查找算法的效率时，通常考虑查找成功/失败两种情况的ASL。
ASL的数量级反应了查找算法时间复杂度。
顺序查找 又称==线性查找==，通常用于线性表，适用于==顺序链式、有序无序==都可。
一般的 以顺序表、不带哨兵为例：
typedef struct { ElemType *elem; // 动态数组基址 int TableLen; } int Search_Seq(SSTable ST, ElemType key) { int i; for (i=0; i&amp;lt;ST.TableLen &amp;amp;&amp;amp; ST.elem[i]!=key; ++i) return i==ST.TableLen ? -1 : i; } 可在0号位置设置“哨兵”，从尾部向头部挨个查找，优点是：循环时无需判断下标是否越界。
ASL：
成功：$\frac{1+2+3+···+n}{n}=\frac{n+1}{2}$，O(n) 失败：$n+1$，O(n) 优化的 若==元素有序==：当前关键字大于（或小于）目标关键字时，查找失败。查找失败的ASL变小（查找成功的ASL没有变小）
查找判定树：
n个成功结点，n+1个失败结点。
成功结点的查找长度 = 自身所在层数
失败结点的查找长度 = 其父结点所在层数
若各个关键字==被查概率不等==：可按概率降序排列，使查找成功时ASL更小（查找失败的ASL没有变小）
折半查找 又称==二分查找==，仅适用于==有序==的==顺序表==。
实现：可以看出，取下标为mid的元素值，要求随机访问的特性，所以仅适用于顺序表，不适用于链表。
查找效率分析：
由于查找次数不超过树高，所以时间复杂度为O(log~2~n)
示例：
顺序查找时间复杂度为O(n)，那么折半查找是否一定比顺序查找快？——不一定，看具体情况，如：
判定树 构造：
性质：
是平衡二叉排序树 只有最下面一层不满，所以树高为 h = log~2~(n+1)取下界，和完全二叉树高度相同 成功结点n个，失败结点n+1个（等于成功结点的空链域数量） 拓展：当时，判定树怎么画：</description>
    </item>
    
    <item>
      <title>第6章 图</title>
      <link>/posts/ds/%E7%AC%AC6%E7%AB%A0-%E5%9B%BE/</link>
      <pubDate>Mon, 14 Nov 2022 23:51:17 +0000</pubDate>
      
      <guid>/posts/ds/%E7%AC%AC6%E7%AB%A0-%E5%9B%BE/</guid>
      <description>概念 图G由顶点集V和边集E组成。|V|表示图中顶点的个数，也称为图的阶。|E|表示边的条数。
树可以是空树，但图不可以空，可以没有边，不能没有顶点。
顶点的度：
无向图：全部顶点的度的和等于边数的2倍 有向图：全部顶点的入度之和=出度之和=边数 简单图（默认）：不存在重复边、到自身的边 多重图：存在重复边，或到自身的边
简单路径：顶点不重复出现 简单回路：除起点和终点外，其余顶点不重复出现
针对无向图
连通：两个顶点之间存在路径
连通图：任意两个顶点间存在路径 连通分量：
连通图的生成树：包含所有顶点、尽可能少的边。n个顶点，n-1条边。少一条边则不连通，多一条边则形成回
非连通图的生成森林：连通分量的生成树构成生成森林。
针对有向图
强连通：两个顶点之间存在往来路径
强连通图：任意两个顶点之间存在往来路径 强连通分量：
子图：V&amp;rsquo;是V的子集，E&amp;rsquo;是E的子集，且能构成图 生成子图：V&amp;rsquo;=V
完全图：任意两个顶点间都存在边（或方向相反的两条弧）
图的存储 邻接矩阵 空间复杂度：O(|V|^2^)。
不带权
带权
性质
邻接表 类似树的孩子表示法。
邻接表表示方式不唯一，因为指向相邻结点的顺序不一定。
无向图：O(|V|+2|E|)，一条边会存储两次，冗余，删除顶点删除边等操作时间复杂度高。
有向图：O(|V|+|E|)
邻接矩阵 vs 邻接表 十字链表 只能用于有向图。
弥补邻接矩阵和临界表的缺点：即节省空间，又方便找到找结点的入边。
找结点的出边：顺着绿色线路找 找结点的入边：顺着橙色线路找
空间复杂度：O(|V|+|E|)
邻接多重表 只能用于无向图。
弥补邻接矩阵和临界表的缺点：即节省空间，又不会把一条边存储两遍（便于删除边和顶点）。
空间复杂度：O(|V|+|E|)
图的基本操作 图的遍历 广度优先遍历 对比树的广度优先遍历（层次遍历）：可知图的BFS需要标记哪些顶点被访问过，其它方面与树的BFS相同。
图的广度优先遍历（Breadth-First-Search, BFS）：
找到与一个顶点相邻的所有顶点：FirstNeighbor(G, x) NextNeighbor(G, x, y) 标记哪些顶点被访问过：bool visited[MAX_VERTEX_NUM] 需要辅助队列 代码实现：
代码实现改进：对于非连通图，在BFS外再套一层循环。遍历寻找没有访问过的顶点，即一个连通分量，对它进行遍历。如图从1开始访问到8后，第一个BFS执行结束，再找到一个没有被访问过的结点即9，从9开始访问到11，完成。
遍历序列的可变性：
同一个图的==邻接矩阵==表示方式==唯一==，因此广度优先遍历序列、广度优先生成树==唯一== 同一个图的==邻接表==表示方式==不唯一==，因此广度优先遍历序列、广度优先生成树==不唯一==
复杂度分析：
空间复杂度：辅助队列的长度，最坏需要O(|V|)，如图中情况： 时间复杂度：分为==访问顶点==和==寻找相邻结点==两部分 访问顶点：O(|V|) 找相邻结点： 邻接矩阵存储：每个顶点找一次，每次需要遍历临界矩阵中的一行元素，即 O(|V|^2^) 邻接表存储：遍历每个顶点的单链表，即遍历所有边，即 O(|E|) （对于无向图是 O(2|E|)，等于O(|E|)） 综上：邻接矩阵存储：==O(|V|^2^)==，邻接表存储：==O(|V|+|E|)== 广度优先生成树：结点被访问时，是从哪条边过去的。由遍历序列的可变性可知，基于邻接表的广度优先生成树也不唯一。</description>
    </item>
    
    <item>
      <title>第5章 树与二叉树</title>
      <link>/posts/ds/%E7%AC%AC5%E7%AB%A0-%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91/</link>
      <pubDate>Mon, 14 Nov 2022 23:50:49 +0000</pubDate>
      
      <guid>/posts/ds/%E7%AC%AC5%E7%AB%A0-%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91/</guid>
      <description>概念和性质 树可以是空树，森林可以是空森林。
结点间的路径只能从上到下单向。 树的路径长度：从树根到每个结点的路径长度的总和。
有序树/无序树：结点的左右位置是否反应某些逻辑关系。
结点的度：该结点有几个孩子； 树的度：各结点的度的最大值。
度为m的树：树中必存在有m个孩子的结点（一定是非空树，结点数≥m+1）；——孩子不区分左右次序 m叉树：结点的孩子数最多为m，可以不存在这样的结点，甚至可以是m叉空树。——区分左右次序
性质：
结点数=总度数+1（根节点没有被指向） m叉树 第$$i$$层最多有$$m^{i-1}$$个结点 度为m的树 第$$i$$层最多有$$m^{i-1}$$个结点 高度为h的m叉树 最多共$\frac{m^h-1}{m-1}$个结点（等比数列求和），最少h个结点 高度为h的度为m的树 最多共$\frac{m^h-1}{m-1}$个结点（等比数列求和），最少h+m-1个结点 具有n个结点的m叉树最小高度为 二叉树 满二叉树：每一层都长满（左孩子：2i，右孩子：2i+1，父节点：i/2取下界）
完全二叉树：从上到下从左到右长的树，与满二叉树一一对应（区分叶子结点和非叶子结点：n/2取下界）
二叉排序树：左&amp;lt;根&amp;lt;右，且左右子树都是一棵二叉排序树
平衡二叉树：左右子树深度之差不超过1
性质：
==n~0~=n~2~+1==（叶子结点个数比二分支节点个数多一个） 假设结点总数为n，则n=n~1~+2n~2~+1=n~0~+n~1~+n~2~ 对于完全二叉树，给出结点总数可以求出n~0~，n~1~，n~2~ 突破口：最多只有一个度为1的结点，所以n~1~=0或1 n~0~=n~2~+1 存储结构 顺序存储：把二叉树的结点编号和完全二叉树对应起来。只适合完全/满二叉树，不然浪费空间。
对于高度为n的二叉树，采用顺序存储，不管有多少个结点，都要用2^0^+2^1^+2^2^+&amp;hellip;=2^n^-1个存储单元。 链式存储：n个结点的二叉树有n+1个空指针域，可用来构造线索二叉树。(2n个链域，n-1个结点被指向，头结点没有被指向)
二叉树定义
// typedef int ElemType; struct ElemType { int value; } typedef struct BiTNode { ElemType data; struct BiTNode *lchild, *rchild; }BiTNode, *BiTree; // BiTNode *p; 等价于 BiTree p; BiTree root = NULL; 插入根结点
root = (BiTree)malloc(sizeof(BiTNode)); root-&amp;gt;data = {1}; root-&amp;gt;lchild = NULL; root-&amp;gt;rchild = NULL; 插入新结点</description>
    </item>
    
    <item>
      <title>第4章 串</title>
      <link>/posts/ds/%E7%AC%AC4%E7%AB%A0-%E4%B8%B2/</link>
      <pubDate>Mon, 14 Nov 2022 23:50:36 +0000</pubDate>
      
      <guid>/posts/ds/%E7%AC%AC4%E7%AB%A0-%E4%B8%B2/</guid>
      <description>线性表：具有相同数据类型的n个(n&amp;gt;=0)数据元素的有限序列，基本操作以==单个元素==为操作对象
串：由零个或多个==字符==组成的有限序列，基本操作以==子串==为操作对象
朴素模式匹配算法 int Index(SString S, SString T) { int i = 1, j = 1; while (i&amp;lt;=S.length &amp;amp;&amp;amp; j&amp;lt;=T.length) { if (S.ch[i] == T.ch[j]) { ++i; ++j; } else { i = i-j+2; j = 1; } } if (j &amp;gt; T.length) return i-T.length; else return 0; } 最坏：O(mn)
a a a a a a b (n个) a a b (m个) KMP算法 O(m+n)：
求next数组 O(m)：
模式匹配过程 O(n)
优化的KMP算法 </description>
    </item>
    
    <item>
      <title>第3章 栈、队列、数组</title>
      <link>/posts/ds/%E7%AC%AC3%E7%AB%A0-%E6%A0%88%E9%98%9F%E5%88%97%E6%95%B0%E7%BB%84/</link>
      <pubDate>Mon, 14 Nov 2022 23:50:26 +0000</pubDate>
      
      <guid>/posts/ds/%E7%AC%AC3%E7%AB%A0-%E6%A0%88%E9%98%9F%E5%88%97%E6%95%B0%E7%BB%84/</guid>
      <description>栈、队列、数组具有相同的逻辑结构：线性 使用栈和队列把队列逆置：
void Inverser(Stack &amp;amp;S, Queue &amp;amp;Q) { while(!QueueEmpty(Q)) { x = DeQueue(Q); Push(S, x); } while(!StackEmpty(S)) { Pop(S, x); EnQueue(Q, x); } } 栈 LIFO 栈的存储结构 顺序 定义（这里令top指向栈顶元素）
#define MaxSize 10 typedef struct { ElemType data[MaxSize]; int top; } SqStack; 初始化
SqStack S; InitStack(S); //令 top=-1 进栈
bool Push(SqStack &amp;amp;S, ElemType x){ if (S.top == MaxSize-1) return false; S.top = S.top + 1; S.data[S.top] = x; // 上面两句也可以写成 S.</description>
    </item>
    
    <item>
      <title>第1章 绪论</title>
      <link>/posts/ds/%E7%AC%AC1%E7%AB%A0-%E7%BB%AA%E8%AE%BA/</link>
      <pubDate>Mon, 14 Nov 2022 23:50:09 +0000</pubDate>
      
      <guid>/posts/ds/%E7%AC%AC1%E7%AB%A0-%E7%BB%AA%E8%AE%BA/</guid>
      <description>数据结构三要素：
逻辑结构 集合 线性：一对一 树：一对多 图：多对多 物理结构/存储结构 连续：顺序 离散：链式、索引、散列 运算 栈是一种抽象数据类型，可采用顺序或者链式存储，只表示逻辑结构。
数据的逻辑结构独立于存储结构；存储结构是逻辑结构在计算机上的映射，不独立于逻辑结构。
链式存储设计时，结点间可以是离散的，但是结点内的存储单元地址必连续。
不同的数据结构，逻辑结构和物理结构完全有可能相同。比如二叉排序树可以采用二叉树的逻辑表示和存储方式。
相同逻辑结构，在不同物理结构下，运算的效率可能不同。比如线性表在顺序存储方式下，插入删除元素的时间复杂度是O(n)，在链式存储下为O(1)。
算法的五大特征：
有穷性 确定性 可行性 输入 输出 算法的目标：
正确性 可读性 健壮性 效率与低存储量需求 算法原地工作：所需辅助空间为常量
将长度为m、n的升序链表合并为一个升序/降序链表，最好情况下的时间复杂度为O(min(m, n))，最坏为O(m+n-1)即O(max(m, n))
斐波那契数列
递归 O(2^n^)
#include&amp;lt;iostream&amp;gt; using namespace std; long Fibonacci(int n) { if (n == 0) return 0; else if (n == 1) return 1; else return Fibonacci(n - 1) + Fibonacci(n-2); } int main() { cout &amp;lt;&amp;lt; &amp;#34;Enter an integer number:&amp;#34; &amp;lt;&amp;lt; endl; int N; cin &amp;gt;&amp;gt; N; cout &amp;lt;&amp;lt; Fibonacci(N) &amp;lt;&amp;lt; endl; system(&amp;#34;pause&amp;#34;); return 0; } 非递归 O(n)</description>
    </item>
    
    <item>
      <title>第2章 线性表</title>
      <link>/posts/ds/%E7%AC%AC2%E7%AB%A0-%E7%BA%BF%E6%80%A7%E8%A1%A8/</link>
      <pubDate>Mon, 14 Nov 2022 23:48:49 +0000</pubDate>
      
      <guid>/posts/ds/%E7%AC%AC2%E7%AB%A0-%E7%BA%BF%E6%80%A7%E8%A1%A8/</guid>
      <description>线性表是逻辑结构，顺序表链表是存储结构
给定n个元素的一维数组，建立一个有序单链表的时间复杂度最小是 O(nlog~2~n)：排序最短O(nlog~2~n)，建表O(n)
时间复杂度分析 尾插 头删 单链表/双链表 O(n) O(1) 不带头结点的单循环链表 O(n) O(n) 不带头结点有尾指针的单循环链表 O(1) O(1) 有无头结点对头插的影响：没有头结点，需要遍历到表尾才能将尾节点指向插入的结点，复杂度为O(n)；有头结点为O(1)
概念 逻辑结构（定义）：具有相同数据类型的n（==&amp;gt;=0==）个数据元素的有限序列
物理结构：
顺序存储
顺序表 静态分配空间 动态分配空间 链式存储
单链表 双链表 循环链表 静态链表（借助数组实现） 基本操作：
- InitList(&amp;amp;L) - Length(L) - LocateElem(L, e) - GetElem(L, i) - ListInsert(&amp;amp;L, i, e) - ListDelete(&amp;amp;L, i, &amp;amp;e) 用e返回删除的元素 - PrintList(L) - Empty(L) - DestroyList(&amp;amp;L) 顺序表 特点：元素的逻辑顺序和物理顺序相同，随机存取，存储密度高，插入删除需移动大量元素。
实现方式 静态分配 typedef int ElemType; #define MaxSize 50 typedef struct { ElemType data[MaxSize]; int length; }Sqlist; 动态分配 #define MaxSize 50 #define InitSize 50 typedef struct { ElemType *data; int length; }Sqlist; Sqlist L; L.</description>
    </item>
    
    <item>
      <title>2</title>
      <link>/posts/nlp/02english-lexical-morphology/</link>
      <pubDate>Fri, 08 Apr 2022 11:25:09 +0000</pubDate>
      
      <guid>/posts/nlp/02english-lexical-morphology/</guid>
      <description>why need this 因为基于已有词典的分词遇到未登录词（没见过的新词）时，就完了。
可以从语料中自动获取比词更小的构词单元（subwords 子词）来解决此问题，常用算法：byte-pair encoding(BPE)。
步骤 token learner：从语料中获取词表（token） token segmenter(parser)：基于词表（token）切分语料 实现 token learner 初始化：子词表为语料中所有单个字母符号集。 重复如下操作： 选择在语料中最频繁邻接的两个符号（如&amp;rsquo;A&amp;rsquo;, &amp;lsquo;B&amp;rsquo;）； 合并成一个新符号 &amp;lsquo;AB&amp;rsquo;，并加入词表； 将语料中所有邻接的 &amp;lsquo;A&amp;rsquo;, &amp;lsquo;B&amp;rsquo; 替换为 &amp;lsquo;AB&amp;rsquo;； 直到合并得到的新符号数量达到预定的k个。 token parser(segmenter) 给定测试语料集，在其上进行：（先拆再合）
初始化：在每个单词末尾加 &amp;lsquo;__&amp;rsquo;，将每个词==分割==为单个字母 按训练集上的合并顺序==合并==测试集中的符号 贪婪 按训练集上学到的合并次序 不考虑测试集上的频次 </description>
    </item>
    
    <item>
      <title>4-6</title>
      <link>/posts/nlp/04-06lexcial-semantics/</link>
      <pubDate>Fri, 08 Apr 2022 11:25:09 +0000</pubDate>
      
      <guid>/posts/nlp/04-06lexcial-semantics/</guid>
      <description>lexical semantics 词义分析
词义 语义
几个语言学术语 词义：词的内容
概念义——客观 色彩义——主观 义素（Sememe）：最小词义单位，又叫语义特征 、义原等。
义位（glosseme）：能独立运用的最小词义单位（义素）
义素是可以通过比较分析一组相关词语的义位(义素分析法)而得到的词义的区别特征 义位是由义素合成的 义素分析法：
确定对比分析的义位，通常是同一语义场内的一些义位 寻找义位之间的共性特征和区别性特征 将寻找出的各种义素用结构式描述出来 提供词义的词典，目前都是给人使用的，机器不能用，如何为机器提供词义呢？
基于符号的方法 从借鉴词典的词义定义开始：用有限的基本词或者用与其他词(不一定是基本词)的关系来表达词义
基于基本词 基于一个基本词(概念)集合来表示其他所有词的语义
基本词是义素 (语义特征\义原)
构建基本词集合：
专家定义 知网（HowNet）是一个基于义原的常识知识库，基于义原揭示概念与概念之间以及概念所具有的属性之间的关系 义原定义过程：将词的关系归结到其义原间的关系 首先对汉字（单纯词）进行考察和分析，获取一些义原 然后用这些义原作为标注集去标注多音节的词，当发现这些义原不满足要求时，便进行调整或扩充 这样最终形成了2000多个义原的标注集以及由它们标注的10万个中文/英文词或短语 例：打的意思有（1）买：打酱油（2）辫编：打毛衣。那么判断”打手套“中的打是什么意思只需要比较d(手套，酱油)和d(手套，毛衣) 很多词典是基于专家确定的一些基本词而构建出来的，如Oxford学生词典：专家确定2000基础词，其他词均由基础词定义，因此从这些词典中可以获取方式 缺点：主观性，不一致，费时费力；新词不断出现、词义逐渐变化 自动发现 近年来出现了一些基于语料来自动获取基本词的研究 提出新义原还没有 基于词间关系 词间关系，主要是词义之间的关系，当词有多个义位时，看其中一义位间的关系。所以更准确地说两个词之间的关系是指这两个词的某两个义位之间的关系
上下义位关系(Hyponymy)——名词、动词等都可以有
上位(Superordinate上位词)：从特殊概念到一般概念 (IS-A)
哺乳动物&amp;mdash;&amp;gt;动物
下位(Subordinate下位词)： 从一般概念到特殊概念 (Include)
动物&amp;mdash;&amp;gt;哺乳动物
全体-成员关系(Ensemble-Member)
从全体到成员关系 (Has-Member) 从成员到全体 整体-部分关系(Whole-part)
从整体到部分: Part Meronym(Has-Part) 从部分到整体:Part Holonym(Part-Of) 同义关系(Synonymy)
两个词(基于音、义位)之间的关系 同音词 (Homonyms) 同形(同音)异义词 (Homographs) 同形异音异义词(Heteronyms) 近义词 (Synonyms): 具有相同或相近义位的不同词 反义词(Antonyms): 互补 分级 关系 自反 换喻 (Metonyms) 用一个对象来指称另一个对象 用一个对象的属性或某个侧面来指称另一个对象 用一个属性来指称一个对象 区分：</description>
    </item>
    
    <item>
      <title>Chapter3 - Chinese Lexical Morphology</title>
      <link>/posts/nlp/chapter3-chinese-lexical-morphology/</link>
      <pubDate>Fri, 08 Apr 2022 11:25:09 +0000</pubDate>
      
      <guid>/posts/nlp/chapter3-chinese-lexical-morphology/</guid>
      <description>汉语词形态分析 [toc]
汉语切分基础 回顾词形态分析的两个基本任务：
外部：断词——确定词的外部边界 内部：词形还原——内部结构分析 汉语是独立语，主要在于断词，即汉语切分/分词。词性还原基本没有。
汉语切分任务说明 关于汉语的词的定义/看法：大方之家们各持己见 ··································································由”词“到”切分单元“：汉语切分而非汉语切词 不同的切分标注：反映在各自的切分数据上 汉语切分的两个主要难点问题 边界歧义（Boundary Ambiguity）：从哪里切分
交集歧义（Overlap ambiguity: OA）：XJ/Y/ and X/JY/
检测：通过FMM(正向)和BMM(负向)最大匹配算法。链长为奇数(ABC,ABCDE)的两者切分结果不同，可基于此检测到歧义；链长为偶数(ABCD)，结果相同，检测不出
组合歧义（Combination ambiguity: CA）：X/Y/ and XY/，即 X、Y、XY都是词典中的词
还有 混合歧义 真实歧义 伪歧义
未登录词（Out of Vocabulary: OOV）（Unknow words）：词典/训练数据中没有此切分单元
如：派生词、命名实体、新词 边界歧义常与OOV混合出现 朴素的切分算法——基于规则 前向最大匹配算法 FMM forward maximum match
早期一个朴素的切分算法，基于词表
例：
算法参数：最大匹配长度 MaxLen = 3
切分句子：语言学很重要
过程：取”语言学“查词表，在其中，ok；取”很重要”，不在词表中；取“很重”，不在；取“很”，不在，但是只有一个字，ok；取“重要“，在，ok
算法影响因素：
MaxLen：太小，不能切对长的词；太大，经常回退；合适的=词表的平均词长+1/+2 词典 性能评估：
评测数据（带有标准答案的数据）
评测指标：常用 P/R/F1
后向最大匹配算法 BMM backward maximum match
基于规则的切分方法总结 FMM BMM
简单快速，可以用来发现OA
不能提供高质量的切分，没有进行不同切分选择的消歧能力：
OA：总是切分成 XJ/Y（而BMM总是切分成 X/JY，所以用他俩可以检测歧义 CA：总是把XY切分为一个词 OOV：不能处理，一般切成单个字（也可提供某种信息） 扩展以处理歧义：</description>
    </item>
    
    <item>
      <title>1-概率图模型</title>
      <link>/posts/ml/1-%E6%A6%82%E7%8E%87%E5%9B%BE%E6%A8%A1%E5%9E%8B/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/posts/ml/1-%E6%A6%82%E7%8E%87%E5%9B%BE%E6%A8%A1%E5%9E%8B/</guid>
      <description>有向图模型（贝叶斯网络） 朴素贝叶斯分类器、隐马尔可夫模型HMM、深度信念网络DBN
对于结点和边 y&amp;ndash;&amp;gt;x，有 P(x|y)
依据条件独立性假设，将联合概率分布分解成简单条件概率组合，从而求得联合概率分布——学习
通过联合概率分布，计算想要的条件概率——推断
无向图模型（马尔可夫网络） 马尔可夫随机场、条件随机场、玻尔兹曼机、对数线性模型（最大熵模型）
利用极大团上的势函数定义概率分布：势能函数g + 能量函数E
马尔可夫随机场 &amp;amp;&amp;amp; 条件随机场 马尔可夫随机场 MRF 条件随机场 CRF ？什么都没给出，所有结点平行 由观测变量推测标记变量（给定观测值的MRF） 模型 生成式（对联合概率建模），HMM也是 判别式（对条件概率建模） 图类型 无向图 &amp;lt;&amp;mdash; 势函数 定义在（极大）团上，刻画团中变量的相关关系，在所偏好的变量取值上值较大 &amp;lt;&amp;mdash; 利用团上的势函数定义 联合概率 条件概率 马尔可夫性概念区分 无向图中
全局马尔可夫性：给定两个变量子集的分离集，则这两个子集条件独立。 局部马尔可夫性：给定某变量的邻接变量，则该变量条件独立于其他变量。 成对马尔可夫性：给定所有其它变量，则两个非邻接变量条件独立。 有向图中
局部马尔可夫性：每个随机变量在给定父节点的情况下，条件独立于它的非后代节点。 马尔科夫链的马尔可夫性（也称服从马尔可夫假设）：某节点只与前面L个节点相关。 隐马尔可夫模型中的两个假设：（条件独立性假设）某一时刻的观测变量仅依赖于状态变量；（一阶马尔可夫假设）t+1时刻的状态变量仅依赖于 t 时刻的状态变量；前两条可推出第三条：观测变量是条件独立的。 HMM关注的问题 推断问题：
推断观测序列的似然：计算$P(O|λ)$ 推断最可能的隐序列 推断现在 推断过去 推断未来 学习问题：
求模型参数 ：最大化给定观测序列出现的概率 精确推断 近似推断 变分推断 采样法 Sampling method 我们知道了一个变量的分布，要生成一批样本服从这个分布，这个过程就叫采样。听起来好像很简单，对一些简单的分布函数确实如此，比如，均匀分布、正太分布，但只要分布函数稍微复杂一点，采样这个事情就没那么简单了。
在讲具体的采样方法之前，有必要弄清楚采样的目的。为什么要采样呢？有人可能会这样想，样本一般是用来估计分布参数的，现在我都知道分布函数了，还采样干嘛呢？其实采样不只是可以用来估计分布参数，还有其他用途，比如说用来估计分布的期望、高阶动量等。其实在机器学习中，采样的主要用途是用来估计某个函数在某个分布上的期望 ，比如在EM算法中，计算E步的时候，已知隐变量的分布，用采样的方法估计对数似然的期望。
也称为蒙特卡罗方法 (Monte Carlo method)，或统计模拟方法。
对于简单的分布，直接随机采样或间接采样。
对于更复杂的分布：</description>
    </item>
    
    <item>
      <title>2-聚类分析</title>
      <link>/posts/ml/2-%E8%81%9A%E7%B1%BB%E5%88%86%E6%9E%90/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/posts/ml/2-%E8%81%9A%E7%B1%BB%E5%88%86%E6%9E%90/</guid>
      <description>有监督学习：分类、回归、目标检测、语义切分、图像描述。
无监督学习：学习关于数据的某种隐藏结构。聚类、特征降维、特征学习、密度估计。
聚类 类簇划分的角度：
良态可分类 基于最近邻的聚类 基于密度的聚类 基于中心点的聚类 基于共有属性或概念的聚类 聚类方法：
基于划分（Partitional Clustering） 基于层次（Hierarchical clustering） 自顶向下 自底向上 其它： 排它性聚类 vs. 非排它性聚类 模糊聚类 vs. 非模糊聚类 部分聚类 vs. 完全聚类 异构型聚类 vs. 同构型聚类 聚类模型 K-means 基于中心点
思想：类内距离最小化，类间距离最大化
算法过程：
假设有k个类簇，每个簇一个中心点(centriod)【中心点可看作有监督学习中的标签y】
将每个样本点划分到距离最近的中心点所属的簇中
迭代：
更新每个簇的中心点 然后重新划分 直到中心点不变
转换为有监督学习模型 目标函数：每个样本点与其簇中心点的距离之和。这里的距离可以是各种距离。
μk 表示簇Ck 的中心点（或其它能代表Ck的点） 若x~n~被划分到簇C~k~则r~nk~=1，否则r~nk~= 0 优化目标：找到簇的中心点μk及簇的划分r~nk~使得目标函数SSE最小
算法过程：
choose some initial values for the μ~k~ (k=1,&amp;hellip;,K)
迭代：
minimize SSE with respect to the r~nk~ (n=1,&amp;hellip;,N)
minimize SSE with respect to the m~k~</description>
    </item>
    
    <item>
      <title>3-特征降维和特征学习</title>
      <link>/posts/ml/3-%E7%89%B9%E5%BE%81%E9%99%8D%E7%BB%B4%E5%92%8C%E7%89%B9%E5%BE%81%E5%AD%A6%E4%B9%A0/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/posts/ml/3-%E7%89%B9%E5%BE%81%E9%99%8D%E7%BB%B4%E5%92%8C%E7%89%B9%E5%BE%81%E5%AD%A6%E4%B9%A0/</guid>
      <description>深度学习 &amp;lt;&amp;mdash; 无监督特征学习
介绍 特征是关于样本属性和特性的集中描述。多特征大样本提供了丰富的信息，然而
采集大规模数据往往很困难 一些特征区分样本的能力可能较差 一些特征之间可能存在相关性（房屋年龄、房屋新旧程度） 盲目减少特征可能损失很多信息 为什么要特征降维（特征选择）：发现主要的特征
为什么要特征学习：有效的表示特征
有哪些数学手段：
主成分分析（ Principle Component Analysis ） 独立成分分析（Independent Component Analysis） 线性判别分析（ Linear Discriminant Analysis） 等 PCA 通过特征值分解获取原始数据的新的特征或表示（主成分）：
是原始特征或表示的线性组合 彼此不相关（正交） 尽可能多地捕捉样本的原始方差 基本概念 方差、协方差：度量偏离均值的程度
方差：描述某一维度上的偏离程度
协方差：描述两个变量偏离各自均值的程度，从而表现其相关程度
协方差矩阵：描述多个变量。。。
步骤 结果：特征降维后得到正交的特征，且每一维的方差都很大
目标：寻找能够解释输入数据的方差的一组少量的正交的“方向”，将输入数据映射到这些“方向”上
假设：
数据是连续的（实际是离散的） 输入数据和学习得到的表示成线性关系 过程：
数据中心化（减去均值） 计算特征协方差矩阵C~d×d~ 计算C的m个最大特征值及其对应的特征向量~m×m~：得到m个主成分 Tips：通过np.linalg.eig计算得到的特征值并不是按照一定次序排列的，特征向量的每一列对应每一个特征值。 这些特征向量构成新的矩阵U~d×m~，进而将每一个d维的样本x映射到新的低维向量 z~m×1~ = U^T^~m×d~x~d×1~==（为什么不生成1×m的？一般的数据应该都是横向量吧？maybe：np.cov计算时默认每一行是一个属性，每一列是一个样本，可能这是规范形式）== 与SVD词向量分解不同之处：分解的原始矩阵不同，SVD是词共现矩阵。
两种证明思路 两种视角：最大化方差、最小化错误（等价的）
最大化方差 直觉：因为方差包含重要信息，所以希望降维后方差依然很大 计算：给定一个初始方向，计算样本点映射后的方差，优化方向使方差最大。 结果：公式推导可得，方差=协方差矩阵的特征值，所以，要使方差最大，应选择最大的特征值，用这些特征值对应的特征向量，构建新的正交基。有了正交基，即可计算样本点降维后的表示。 最小化错误（最小化重构误差） 基本思想：降维后的x与原来的x相差越小越好 计算：公式推导得，误差应取协方差矩阵的(d-m)个最小特征值的和 结果：构成主成分子空间的特征向量就是协方差矩阵的m个最大特征值所对应的特征向量 总结 简单有效
非线性问题PCA则无法发挥其作用
多数情况下，难以解释PCA所保持的主成分的意义
PCA将所有的样本作为一个整体对待，而忽略了类别属性
Autoencoder Autoencoder是一种采用无监督方式进行 特征学习的神经网络。</description>
    </item>
    
    <item>
      <title>4-生成模型&#43;VAE</title>
      <link>/posts/ml/4-%E7%94%9F%E6%88%90%E6%A8%A1%E5%9E%8B&#43;vae/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/posts/ml/4-%E7%94%9F%E6%88%90%E6%A8%A1%E5%9E%8B&#43;vae/</guid>
      <description>判别模型——给定X, Y，通过学习判别函数 f(x, y) 或 y = f(x) 来建模条件分布 P(Y|X)
​	——不能建模 P(X) 或 P(x, y)，所以不能生成新的X
生成模型——Y不是必须的。建模 P(x), P(x, y), P(X|Y)等，能生成新的X
如何构建生成模型：
显式密度估计：显式定义和求解p~model~(x)（最大似然估计法、近似法、马尔科夫链方法） 隐式密度估计：不显式定义p~model~(x)，而是学习一个可以从p~model~(x)中采样的模型，目标使X的采样概率似然最大 下面讲显式密度估计中的变分自动编码器，下次讲GAN
P(X)的极大似然估计 过程：采样$x_i$，计算概率$p(x_i)$，优化参数使概率 $\prod_{i}{}{p(x_i)}$ 最大
计算：通过log，推导得：最优参数=使原始分布和采样分布最接近（KL散度最小）的值
问题：在缺少领域知识的先验，对生成过程不了解时， 假设的分布基本都是错误的；如果选择的分布和真实分布不一致时，结果可 能很差；参数规模巨大，例如28 * 28维的手写数字，均值 和协方差的参数规模是784+784*784
解决方案：
引入隐变量模型，先找到一些要素z，然后再由z生成x。然后做MLE。
p(x|z; θ) 可以用 f(z, θ) 逼近，进而把概率密度 估计问题转化更加容易求解的函数逼近问题。
基本假设：任何一个概率分布经过一个足够复杂的函数后可以 映射到任意概率分布。
然而关于参数的梯度中分子分母中关于连续变量z的积分难以计算！
蒙特卡罗采样法 变分推断（VI）&amp;mdash;&amp;gt; VAE 变分自动编码器 Variational inference (VI)：机器学习中 ，变分推断是一种通过最优化的方 法近似估计概率的方法。VI背后的思想是提出一个分布家族，进一步从 中得到一个接近目标分布的分布，接近程度通 常用Kullback-Leibler散度计算
AutoEncoder：一种从无标记数据中，学习其低维特征表示的 无监督方法
基本思想 假设样本是从一个不可观测的隐变量z生成的，即
将直接求解p(x)化简为两步：
从先验分布 p~θ*~(z) 中抽样一个 z 从条件分布 p~θ*~(x|z^i^) 中抽样得到 x 目标：估计生成模型的真实参数 θ*</description>
    </item>
    
    <item>
      <title>5-GAN</title>
      <link>/posts/ml/5-gan/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/posts/ml/5-gan/</guid>
      <description>VAE与GAN：
Generative：学习一个生成模型
Adversarial：在对抗学习的设置下训练模型
Networks：深度神经网络
对抗学习的思想 对抗学习是一种机器学习领域常用的学习策略， 通过引入假样本迷惑模型（增强模型的鲁棒性、 降低过拟合）
一般实现方式：
构造对抗任务：生成对抗样本以迷惑判别模型（★★★） 促使模型在完成主任务的时候，同时完成对抗任务 重复训练过程，提升判别模型的学习能力 GAN的基本思想 GANs 将上述思想拓展到生成模型，基本思想是训练两个网络：生成器和判别器，二者对抗训练，获得更好的生成器和判别器。
GAN组织结构 整体结构：
Z 是样本的隐变量表示，也被称为随机噪声。
训练过程：将生成的样本和真实样本一起交给判别器做判断，误差反传轮流更新判别器参数和生成器参数：
最终，通过充分训练，渴望算法收敛于一个好的关于数据分布的估计p~g~，即由它生成的样本无法被判别器清楚分辨是真是假。同时，训练出一个好的判别器D，即给定任意的生成器G，训练判别器D的标准是最大化V (G, D) 。
具体代价函数 判别器 判别器是一个分类器，试图为生成的数据输出0，为真实的数据输出1，min代价函数：
生成器 生成器希望判别器输出为1，min代价函数：
极大极小博弈（minimax game） 生成器和判别器之间互为对抗的零和博弈 （zero-sum game）</description>
    </item>
    
    <item>
      <title>6-RNN</title>
      <link>/posts/ml/6-rnn/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/posts/ml/6-rnn/</guid>
      <description> 序列学习：给定训练样例$(x, y)$，二者皆为序列或只有一个是序列，找一个$f$将$x$映射到$y$。特别地，若$x,y$长度相同，称为序列标注。
RNN：将HMM中的分布函数变成判别函数
序列内部的关联$f_\theta(h)$ 序列之间的关系$g_w(h)$ </description>
    </item>
    
    <item>
      <title>决策树</title>
      <link>/posts/ml/%E5%86%B3%E7%AD%96%E6%A0%91/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/posts/ml/%E5%86%B3%E7%AD%96%E6%A0%91/</guid>
      <description>ID3 entropy
conditional entropy
information gain
find min(conditional entropy) to get max(information gain)
Occam&amp;rsquo;s razor: Entities are not to be multiplied beyond necessity (law of parsimony).
C4.5 information-gain ratio
choose max(information-gain ratio)
for continuous-valued attributes: find the threshold.
for unknown attribute values: ignore the unknown then calc; divide the sample by weight.
CART-CLASSIFICATION TREE Gini In=dex [p~k~ for k~th~ class]=
Gini index for binary classification problem [p for 1~th~ class]</description>
    </item>
    
  </channel>
</rss>
