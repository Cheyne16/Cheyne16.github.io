<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>OS on Home</title>
    <link>/categories/os/</link>
    <description>Recent content in OS on Home</description>
    <image>
      <title>Home</title>
      <url>%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E</url>
      <link>%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E</link>
    </image>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Tue, 21 Feb 2023 16:29:43 +0000</lastBuildDate><atom:link href="/categories/os/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>BUPT ch2 operating-system structures</title>
      <link>/posts/os/bupt-ch2-operating-system-structures/</link>
      <pubDate>Tue, 21 Feb 2023 16:29:43 +0000</pubDate>
      
      <guid>/posts/os/bupt-ch2-operating-system-structures/</guid>
      <description>BUPT ch2 operating-system structures 操作系统服务 一个操作系统的服务可以提供给：用户、进程、其他os
to user User interface - UI分为命令行CLI，图形化用户界面GUI，Batch Program execution I/O operations File-system manipulation communications - 进程间交换信息 Error detection to os 通过资源共享确保os自身的有效操作
Resource allocation Accounting Protection and security 用户接口 CLI 实现方式：内核、系统程序、多因素
GUI 用户友好
许多os同时存在CLI和GUI
系统调用 运行在用户空间的程序向操作系统内核请求需要更高权限运行的服务
为什么要用系统调用 它为用户空间提供了一种统一的硬件的抽象接口。
保证了系统的稳定和安全。
为什么使用API而不是系统调用？ 使用API来实现
Win32 API for Windows POSIX API for POSIX-based systems Java API for the Java virtual machine(JVM) 只需要遵循API，不用理解系统调用的内部实现。
系统调用参数传递方式 寄存器——最简单、参数少时、在用户态设置好寄存器的值然后进入内核态 块——参数放在块中，传递块的地址（地址放在栈中），在内核把参数拷贝过来 栈——程序将参数压入栈中，os将参数出栈 块、栈不限制参数的长度/数量
系统调用类型 进程控制
文件管理</description>
    </item>
    
    <item>
      <title>BUPT ch3 processes</title>
      <link>/posts/os/bupt-ch3-processes/</link>
      <pubDate>Tue, 21 Feb 2023 16:29:43 +0000</pubDate>
      
      <guid>/posts/os/bupt-ch3-processes/</guid>
      <description>BUPT ch3 processes 进程概念 即：运行中的程序
一个进程包括：程序计数器、栈、数据区域
进程的几种状态：new、running、waiting、ready、terminated
PCB（进程控制块）：包括 描述信息、控制信息、资源占用、现场保护
进程调度 进程切换 原因：中断 / 系统调用
过程：保存现场 —&amp;gt; 加载另一个进程的现场
进程调度队列 Job queue：所有进程
Ready queue：等待CPU资源
Device queue：等待IO设备
调度器 长期调度
短期调度
长期调度（控制进程的多道程度） 短期调度 中期调度 选择进程去 进入ready队列 分配CPU执行 效率 低 高 调用频率 不频繁 频繁 消耗时间 长 短 选取时要协调IO和计算的任务量 将进程从内存（或CPU竞争）中取出，降低内存中多道数据程度 进程上的操作 进程创建 父进程创建子进程，绵延成一棵进程树，他们之间有各种可能的情况：
资源共享——3种 执行次序——2种 地址空间——2种 进程终止 exit——正常退出 abort——异常退出 级联终止 非级联终止 合作进程 进程间通信 CS系统通信 </description>
    </item>
    
    <item>
      <title>xv6</title>
      <link>/posts/os/xv6/</link>
      <pubDate>Tue, 21 Feb 2023 16:29:43 +0000</pubDate>
      
      <guid>/posts/os/xv6/</guid>
      <description>教程 ：第零章 操作系统接口 | xv6 中文文档 (gitbooks.io)
刚开始没有装qemu，安装后sudo apt-get install qemu ，运行成功</description>
    </item>
    
    <item>
      <title>历史</title>
      <link>/posts/os/%E5%8E%86%E5%8F%B2/</link>
      <pubDate>Tue, 21 Feb 2023 16:29:43 +0000</pubDate>
      
      <guid>/posts/os/%E5%8E%86%E5%8F%B2/</guid>
      <description>Intel CPU 家谱 </description>
    </item>
    
    <item>
      <title>寄存器</title>
      <link>/posts/os/%E5%AF%84%E5%AD%98%E5%99%A8/</link>
      <pubDate>Tue, 21 Feb 2023 16:29:43 +0000</pubDate>
      
      <guid>/posts/os/%E5%AF%84%E5%AD%98%E5%99%A8/</guid>
      <description>16位 8位 32位 段寄存器 </description>
    </item>
    
    <item>
      <title>王道 Part1 概述</title>
      <link>/posts/os/%E7%8E%8B%E9%81%93-part1-%E6%A6%82%E8%BF%B0/</link>
      <pubDate>Tue, 21 Feb 2023 16:29:43 +0000</pubDate>
      
      <guid>/posts/os/%E7%8E%8B%E9%81%93-part1-%E6%A6%82%E8%BF%B0/</guid>
      <description>1 综述 程序接口：一组系统调用
命令接口：
联机命令接口：=交互式命令接口，用户说一句， 系统跟着做一句，如cmd 脱机命令接口：=批处理命令接口，用户说一堆， 系统跟着做一堆，如 *.bat文件 2 特征 并发：表面同时进行，实际交替进行，比如一个CPU同时运行多任务 并行：真正同时进行，如多个CPU，每个CPU运行一个任务
如果失去并发性，则系统中只有一个程序正在运行，则共享性失去存在的意义； 如果失去共享性，则QQ和微信不能同时访问硬盘资源，就无法实现同时发送文件，也就无法并发。
如果失去了并发性，则一个时间段内系统中只需运行一道程序，那么就失去了实现虚拟性的意义了。因此，没有并发性，就谈不上虚拟性。
异步是指，在多道程序环境下，允许多个程序并发执行，但由于资源有限，进程的执行不是一贯到底的， 而是走走停停，以不可预知的速度向前推进，这就是进程的异步性。如果失去了并发性，即系统只能串行地运行各个程序，那么每个程序的执行会一贯到底。只有系统拥有并发性，才有可能导致异步性。
3 发展和分类 多道批处理系统阶段：操作系统正式诞生，用于持多道程序并发运行
4 运行机制 4.1 计算机系统的层次结构 4.2 内核 内核是计算机上配置的底层==软件==，是操作系统最基本、最核心的部分
操作系统的内核程序是系统的管理者， 既可以执行特权指令，也可以执行非特权指令
但是，操作系统的功能未必都在内核里，比如GUI。操作系统分为内核部分和非内核部分。内核只是操作系统最核心重要的部分。
4.3 内核态-用户态 CPU 中有一个寄存器叫 ==程序状态字寄存器==（PSW），其中有个二进制位，1表示 “内核态”，0表示“用户态” 别名：内核态=核心态= ==管态==；用户态= ==目态==
程序状态字（PSW）寄存器用于记录当前处理器的状态和控制指令的执行顺序，并且保留与运行程序相关的各种信息，主要作用是实现程序状态的保护和恢复。 所以中断处理程序要将PSW保存，子程序调用在进程内部执行，不会更改PSW。
内核态 &amp;mdash;&amp;gt; 用户态：执行一条特权指令——修改PSW的标志位为“用户态”，这个动作意味着操作系统将主动让出CPU使用权 用户态 &amp;mdash;&amp;gt; 内核态：由“中断”引发，硬件自动完成变态过程，触发中断信号意味着操作系统将强行夺回CPU的使用权
4.4 操作系统的体系结构 此处只讲了两种：
大内核/宏内核/单内核： Linux、UNIX
微内核： Windows NT
微内核降低性能举例：
4.5 总结 5 中断和异常 “中断”是让操作系统内核夺回CPU使用权的唯一途径
如果没有“中断”机制，那么一旦应用程序上CPU运行，CPU就会一直运行这个应用程序
内中断/外中断：与当前执行的指令有无关系；中断信号来源于CPU内部还是外部
==举例==
内中断 试图在用户态下执行特权指令 &amp;mdash;-abort 【abort：由致命错误引起，内核程序无法 修复该错误，因此一般不再将CPU 使用权还给引发终止的应用程序， 而是直接终止该应用程序】 执行除法指令时发现除数为 0 &amp;mdash;-abort 系统调用 &amp;mdash;-trap 【trap：有时候应用程序想请求操作系统内核的服务，此时会执行一条特殊的指令——陷入指令，该指令会引发一个内部中断信号（执行“陷入指令”，意味着应用程序主动地将CPU控制权还给操作系统内核。 “系统调用”就是通过陷入指令完成的）】 缺页故障 &amp;mdash;-fault 【fault：由错误条件引起的，可能被内核程序修复。内核程序修复故障后会把 CPU使用权还给应用程序，让它继续执行 下去】 外中断 时钟中断——由时钟部件发来的中断信号（时钟部件每隔一个时间 片（如 50ms）会给CPU 发送一个时钟中断信号） I/O中断——由输入/输出设备发来的中断信号（当输入输出任务完成时， 向CPU发送中断信号） 大多数的教材、试卷中，“中断”特指狭义的中断，即外中断。而内中断一般称为“异常”</description>
    </item>
    
    <item>
      <title>王道 Part2 进程管理</title>
      <link>/posts/os/%E7%8E%8B%E9%81%93-part2-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/</link>
      <pubDate>Tue, 21 Feb 2023 16:29:43 +0000</pubDate>
      
      <guid>/posts/os/%E7%8E%8B%E9%81%93-part2-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/</guid>
      <description>==1 进程组成== 1.1 PCB PCB不包括==user data==
1.2 总结 PCB 是给 操作系统 用的； 程序段、数据段是 给进程自己用的， 与进程自身的运行 逻辑有关。
进程是动态的，进程实体（进程映像）是静态的。 进程实体反应了进程在某一时刻的状态（如：x++后，x=2）。
进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位。
程序是静态的，进程是动态的。进程是程序的一次执行过程，动态地产生、变化、消亡。
2 进程的组织方式 3 进程状态与转换 进程PCB中，会有一个变量 state 来表示进程的当前状态。如：1表示创建态、2表示就绪态、3表示运行态… 为了对同一个状态下的各个进程进行统一的管理，操作系统会将各个进程的PCB组织起来。
进程的整个生命周期 中，大部分时间都处 于三种基本状态。
单CPU情况下，同一时刻只会有一 个进程处于运行态，多核CPU情况 下，可能有多个进程处于运行态
4 进程控制 如果不能“一气呵成”，就有可能导致操作系 统中的某些关键数据结构信息不统一的情况， 这会影响操作系统进行别的管理工作。
4.1 如何实现原语的“原子性”？ 原语的执行具有原子性，即执行过程只能一气呵成，期间不允许被中断。 可以用 “关中断指令”和“开中断指令”这两个特权指令实现原子性。
==正常情况==：CPU每执行完一条指令都会例 行检查是否有中断信号需要处理，如果有， 则暂停运行当前这段程序，转而执行相应 的中断处理程序。中断处理结 束之后也不一定 会直接回到原进 程执行。
==原语==：CPU执行了关中断指令之后，就不再例行 检查中断信号，直到执行开中断指令之后 才会恢复检查。 这样，关中断、开中断 之间的这些指令序 列就是不可被中断的，这就实现了“原子 性”
4.2 进程控制相关的原语 5 进程通信 进程是分配系统资源的单位（包括内存地址空间），因此各进程拥有的内存地址空间相互独立。
为了保证安全，一个进程不能直接访问另一个进程的地址空间。但是进程之间的信息交换又是必须实现的。 为了保证进程间的安全通信，操作系统提供了一些方法。
共享内存：
基于数据结构的共享：比如共享空间里只能放 一个长度为10的数组。这种共享方式速度慢、 限制多，是一种低级通信方式 基于存储区的共享：在内存中画出一块共享存 储区，数据的形式、存放位置都由进程控制， 而不是操作系统。相比之下，这种共享方式速 度更快，是一种高级通信方式。 消息传递：</description>
    </item>
    
    <item>
      <title>王道 Part3 内存管理</title>
      <link>/posts/os/%E7%8E%8B%E9%81%93-part3-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</link>
      <pubDate>Tue, 21 Feb 2023 16:29:43 +0000</pubDate>
      
      <guid>/posts/os/%E7%8E%8B%E9%81%93-part3-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</guid>
      <description>1 预备知识 逻辑地址 to 物理地址：（地址绑定）
==绝对装入==：在编译的时候就转换为最终的地址。需要提前知道装入模块要装到哪，只适用于单道程序环境。 ==静态重定位/可重定位装入==：编译链接后还是从0开始，装入内存的时候转换为最终的地址。要求装入的内存连续且运行中不能移动。 ==动态重定位/动态运行时装入==：（现在使用的）装入内存后不一定立刻转换，而是在程序真正执行时转换。转换用到重定位寄存器。装入的内存可以不连续且运行中可以移动。（需要基址MMU） 链接的三种方式：
静态链接：先链接成一个装入模块，再装入 装入时动态链接：所有模块边装入边链接 运行时动态链接：用到的模块边装入边链接 2 内存管理概述 内存空间的分配与回收 连续分配——单一、固定分区、动态分区 非连续分配——基本分页、段、段页 内存空间的扩充 覆盖技术 交换技术 虚拟存储技术 地址转换 编译时绑定 加载时绑定 （可重定位装入） 运行时绑定 存储保护——利用寄存器 3 内存空间的分配与回收 3.1 连续分配管理方式 3.1.1 单一连续分配 分为系统区和用户区
只能有一道用户程序
有内部碎片（分配给某进程的内存中没用上的部分）
3.1.2 固定分区分配 把用户区划分为若干个固定大小的分区
可进行多道用户程序
数据结构——分区说明表：每个分区的大小、起始状态、是否已分配（状态）
有内部碎片（分配给某进程的内存中没用上的部分）
3.1.3 动态分区分配 进程装入内存时，动态建立分区
系统分区的大小和数目是可变的
数据结构——空闲分区表/空闲分区链
动态分区分配算法
首次适应算法（first fit）—— 从低地址开始查找第一个能满足大小的空闲分区（按地址大小排列） 最佳适应算法（best fit）——优先使用更小的空闲分区（按容量递增排列）&amp;mdash;&amp;gt; 会产生很多碎片 最坏适应算法（worst fit）——同最佳适应算法相反&amp;mdash;&amp;gt;大进程无法进行了 邻近适应算法（next fit）——在首次适应算法上改进：每次从上次查找结束的位置开始查找，减少开销 只有外部碎片（内存中某些空闲分区由于太小了不能用）——用紧凑技术来解决
3.2 非连续分配管理方式 3.2.0 总结 ==访存次数==
基本分页、分段：2 &amp;mdash;&amp;mdash;- 先表后内存 具有快表的分页： 多级页表：n级——n+1次 段页式：3 ———— 段表 页表 内存 ==判断越界==</description>
    </item>
    
    <item>
      <title>王道 Part4 文件管理</title>
      <link>/posts/os/%E7%8E%8B%E9%81%93-part4-%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/</link>
      <pubDate>Tue, 21 Feb 2023 16:29:43 +0000</pubDate>
      
      <guid>/posts/os/%E7%8E%8B%E9%81%93-part4-%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/</guid>
      <description>1 文件管理简介 2 文件的逻辑结构 3 文件目录 4 文件的物理结构 5 物理结构 vs 逻辑结构 </description>
    </item>
    
    <item>
      <title>王道 Part5 IO-Systems</title>
      <link>/posts/os/%E7%8E%8B%E9%81%93-part5-io-systems/</link>
      <pubDate>Tue, 21 Feb 2023 16:29:43 +0000</pubDate>
      
      <guid>/posts/os/%E7%8E%8B%E9%81%93-part5-io-systems/</guid>
      <description>设备管理</description>
    </item>
    
    <item>
      <title>计算机启动</title>
      <link>/posts/os/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%90%AF%E5%8A%A8/</link>
      <pubDate>Tue, 21 Feb 2023 16:29:43 +0000</pubDate>
      
      <guid>/posts/os/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%90%AF%E5%8A%A8/</guid>
      <description>计算机的整个启动过程分成四个阶段 加载ROM里的BIOS——BIOS程序主要包括硬件自检和初始化程序、CMOS设置程序、系统自动装载程序和主要I/O驱动程序和中断服务（BIOS和硬件直接打交道，需要加载I/O驱动程序）。
硬件自检 硬件自检完成后，BIOS把控制权转交给下一阶段的启动程序，即读取指定软盘的主引导扇区（依据”启动顺序“） 读取主引导扇区加载到内存地址 0x7c00
BIOS把控制权转交给下一阶段的启动程序后，计算机将读取该软盘的第一个扇区（512字节）：
如果该扇区最后两个字节是0x55和0xAA，则说明这个扇区的开头是启动程序，所以该设备可以用于启动，然后就开始执行这个程序 如果不是，表明该设备不能用于启动，控制权于是被转交给“启动顺序”中的下一个设备 这个被读取的第一个扇区或者该扇区的前446字节就被称为主引导记录（MBR）或主引导扇区。
主引导记录只有512个字节，放不了太多东西。它的主要作用是，告诉计算机到硬盘的哪一个位置去找操作系统。
主引导记录（master boot record,MBR）位于硬盘的第一物理扇区。由于历史原因，硬盘的一个扇区大小是512字节，包含最多446字节的启动代码（调用操作系统的机器码）、4个硬盘分区表项（每个表项16字节，共64字节，作用：将硬盘分成若干个区）、2个签名字节（0x55,0xAA）。
第二部分&amp;quot;分区表&amp;quot;的作用，是将硬盘分成若干个区（每个区可以安装各自的操作系统，所以最多4个系统共存），在启动时确定将控制权交给哪个操作系统
​	（1） 第1个字节：如果为0x80，就表示该主分区是激活分区，控制权要转交给这个分区。四个主分区里面只能有一个是激活的。
（2） 第2-4个字节：主分区第一个扇区的物理位置（柱面、磁头、扇区号等等）。
（3） 第5个字节：主分区类型。
（4） 第6-8个字节：主分区最后一个扇区的物理位置。
（5） 第9-12字节：该主分区第一个扇区的逻辑地址。
（6） 第13-16字节：主分区的扇区总数（≤2^32^个）。
分区表将硬盘分为多个主分区，每个主分区又由一个个扇区组成，要使用更大的硬盘，有两种手段：提高扇区数，提高每个扇区的大小。
硬盘启动
通过分区表，计算机的控制权就要转交给硬盘的某个分区了，这里又分成三种情况。
卷引导记录——将活动分区中第一逻辑扇区数据加载到内存中。在DOS分区中, 该扇区内容被称为DOS引导记录, 简称DBR。&amp;ldquo;卷引导记录&amp;quot;的主要作用是，告诉计算机，操作系统在这个分区里的位置。然后，计算机就会加载操作系统了。
扩展分区和逻辑分区——四个主分区中有一个可以扩展，扩展后的是逻辑分区，逻辑分区的第一个扇区是扩展引导记录，它里面也包含一张64字节的分区表，但是最多只有两项（也就是两个逻辑分区）。但是，似乎很少通过这种方式启动操作系统。如果操作系统确实安装在扩展分区，一般采用下一种方式启动。
启动管理器——在这种情况下，计算机读取&amp;quot;主引导记录&amp;quot;前面446字节的机器码之后，不再把控制权转交给某一个分区，而是运行事先安装的&amp;ldquo;启动管理器&amp;rdquo;（boot loader），由用户选择启动哪一个操作系统。
Linux环境中，目前最流行的启动管理器是Grub。
加载操作系统内核 将控制权交给内核
控制权转交给操作系统后，操作系统的内核首先被载入内存。
以Linux系统为例，先载入/boot目录下面的kernel。内核加载成功后，第一个运行的程序是/sbin/init。它根据配置文件（Debian系统是/etc/initab）产生init进程。这是Linux启动后的第一个进程，pid进程编号为1，其他进程都是它的后代。
然后，init线程加载系统的各个模块，比如窗口程序和网络程序，直至执行/bin/login程序，跳出登录界面，等待用户输入用户名和密码。
至此，全部启动过程完成。
启动区为什么加载到内存中的地址0x7C00处 0x7C00这个地址来自Intel的第一代个人电脑芯片8088，以后的CPU为了保持兼容，一直使用这个地址。1981年8月，IBM公司最早的个人电脑IBM PC 5150上市，就用了这个芯片。
当时，搭配的操作系统是86-DOS。这个操作系统需要的内存最少是32KB。我们知道，内存地址从0x0000开始编号，32KB的内存就是0x0000～0x7FFF。
8088芯片本身需要占用0x0000～0x03FF，用来保存各种中断处理程序的储存位置。（主引导记录本身就是中断信号INT 19h的处理程序。）所以，内存只剩下0x0400～0x7FFF可以使用。
**为了把尽量多的连续内存留给操作系统，主引导记录就被放到了内存地址的尾部。**由于一个扇区是512字节，主引导记录本身也会产生数据，需要另外留出512字节保存。所以，它的预留位置就变成了：
0x7FFF - 512 - 512 + 1 = 0x7C00 计算机启动后，32KB内存的使用情况如下。
+--------------------- 0x0 | Interrupts vectors +--------------------- 0x400 | BIOS data area +--------------------- 0x5?</description>
    </item>
    
  </channel>
</rss>
