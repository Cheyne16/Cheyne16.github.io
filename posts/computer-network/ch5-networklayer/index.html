<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>ch5-NetworkLayer | Home</title><meta name=keywords content="Computer Network"><meta name=description content="问题 分组和分片的区别 adhoc网络——随机选路，哪学的 flooding序列号 复习Dijkstra DVR构造路径的过程 DVR好消息快，坏消息慢 学习拥塞控制前三个 111页实例 119 计算 习题知识点 电路交换预先分配资源，分组交换（虚电路、数据报）不会 任务 互联——不同网络 编址——统一地址，每个网络接口一个地址 分组——封装上层包，将其拆分成组 分片——适应不同的数据链路层技术 路由选择——路由器 为传输层提供的服务 虚电路 和 数据报
技术 路由算法 路由表 = 路由算法（DVR, LSR, PVR） + 路由协议（ 动态路由协议：RIP, OSPF, BGP）
路由算法：静态 or 自适应
最优化原则：两点间有更短的路径则更新拓扑
Dijkstra的“最短路径”算法：自己复习
选路策略：固定查表选路；洪泛(flooding）；随机选路；==自适应选路==
分级/层次路由：。。。
路由算法 Flooding （Distance Vector Routing）DVR (Link State Routing) LSR router所记录的 无需路由表 路由表：到每个节点的距离和下一跳 entire topology（只记录下一跳） 转发给 所有邻居（除incoming link） 所有邻居 **flooding **==LSP==（acked）（reliably） 转发时间 间隔性（RIP：30s） 拓扑改变时 五个过程：&mldr;&mldr; 超时删除记录（RIP：180s） LSP包：包含邻居的拓扑信息LSP包的构造：周期性/发生变故时集齐后，每个路由器计算自己的最短路径 应用 RIP (Routing Information Protocol) Cisco EIGRP (Enhanced Interior Gateway Routing Protocol) IS-ISOSPF 问题 重复 收敛慢好消息扩散快，坏消息传播慢无穷计数问题==基于谣传的选路== 解决方案 1-跳计数器递减至02-记录序列号 BGP-4 (Border Gateway Protocol) IDRP (Inter-domain Routing Protocol) 拥塞控制 增加资源 网络提供 业务量感知的路由 减少负载 接纳控制 业务量减速 负载掉落 前三个：闭环方案，避免。。。自己学 后两个：开环方案，处理"><meta name=author content="Chan"><link rel=canonical href=/posts/computer-network/ch5-networklayer/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.6a98292fb8fa8cf0f3ba4042d4b75515c04267550f3ad49ff6271b5af9562443.css integrity="sha256-apgpL7j6jPDzukBC1LdVFcBCZ1UPOtSf9icbWvlWJEM=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-123-45","auto"),ga("send","pageview"))</script><meta property="og:title" content="ch5-NetworkLayer"><meta property="og:description" content="问题 分组和分片的区别 adhoc网络——随机选路，哪学的 flooding序列号 复习Dijkstra DVR构造路径的过程 DVR好消息快，坏消息慢 学习拥塞控制前三个 111页实例 119 计算 习题知识点 电路交换预先分配资源，分组交换（虚电路、数据报）不会 任务 互联——不同网络 编址——统一地址，每个网络接口一个地址 分组——封装上层包，将其拆分成组 分片——适应不同的数据链路层技术 路由选择——路由器 为传输层提供的服务 虚电路 和 数据报
技术 路由算法 路由表 = 路由算法（DVR, LSR, PVR） + 路由协议（ 动态路由协议：RIP, OSPF, BGP）
路由算法：静态 or 自适应
最优化原则：两点间有更短的路径则更新拓扑
Dijkstra的“最短路径”算法：自己复习
选路策略：固定查表选路；洪泛(flooding）；随机选路；==自适应选路==
分级/层次路由：。。。
路由算法 Flooding （Distance Vector Routing）DVR (Link State Routing) LSR router所记录的 无需路由表 路由表：到每个节点的距离和下一跳 entire topology（只记录下一跳） 转发给 所有邻居（除incoming link） 所有邻居 **flooding **==LSP==（acked）（reliably） 转发时间 间隔性（RIP：30s） 拓扑改变时 五个过程：&mldr;&mldr; 超时删除记录（RIP：180s） LSP包：包含邻居的拓扑信息LSP包的构造：周期性/发生变故时集齐后，每个路由器计算自己的最短路径 应用 RIP (Routing Information Protocol) Cisco EIGRP (Enhanced Interior Gateway Routing Protocol) IS-ISOSPF 问题 重复 收敛慢好消息扩散快，坏消息传播慢无穷计数问题==基于谣传的选路== 解决方案 1-跳计数器递减至02-记录序列号 BGP-4 (Border Gateway Protocol) IDRP (Inter-domain Routing Protocol) 拥塞控制 增加资源 网络提供 业务量感知的路由 减少负载 接纳控制 业务量减速 负载掉落 前三个：闭环方案，避免。。。自己学 后两个：开环方案，处理"><meta property="og:type" content="article"><meta property="og:url" content="/posts/computer-network/ch5-networklayer/"><meta property="og:image" content="%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-02-21T16:29:43+00:00"><meta property="article:modified_time" content="2023-02-21T16:29:43+00:00"><meta property="og:site_name" content="Chancellor16's Blog"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="ch5-NetworkLayer"><meta name=twitter:description content="问题 分组和分片的区别 adhoc网络——随机选路，哪学的 flooding序列号 复习Dijkstra DVR构造路径的过程 DVR好消息快，坏消息慢 学习拥塞控制前三个 111页实例 119 计算 习题知识点 电路交换预先分配资源，分组交换（虚电路、数据报）不会 任务 互联——不同网络 编址——统一地址，每个网络接口一个地址 分组——封装上层包，将其拆分成组 分片——适应不同的数据链路层技术 路由选择——路由器 为传输层提供的服务 虚电路 和 数据报
技术 路由算法 路由表 = 路由算法（DVR, LSR, PVR） + 路由协议（ 动态路由协议：RIP, OSPF, BGP）
路由算法：静态 or 自适应
最优化原则：两点间有更短的路径则更新拓扑
Dijkstra的“最短路径”算法：自己复习
选路策略：固定查表选路；洪泛(flooding）；随机选路；==自适应选路==
分级/层次路由：。。。
路由算法 Flooding （Distance Vector Routing）DVR (Link State Routing) LSR router所记录的 无需路由表 路由表：到每个节点的距离和下一跳 entire topology（只记录下一跳） 转发给 所有邻居（除incoming link） 所有邻居 **flooding **==LSP==（acked）（reliably） 转发时间 间隔性（RIP：30s） 拓扑改变时 五个过程：&mldr;&mldr; 超时删除记录（RIP：180s） LSP包：包含邻居的拓扑信息LSP包的构造：周期性/发生变故时集齐后，每个路由器计算自己的最短路径 应用 RIP (Routing Information Protocol) Cisco EIGRP (Enhanced Interior Gateway Routing Protocol) IS-ISOSPF 问题 重复 收敛慢好消息扩散快，坏消息传播慢无穷计数问题==基于谣传的选路== 解决方案 1-跳计数器递减至02-记录序列号 BGP-4 (Border Gateway Protocol) IDRP (Inter-domain Routing Protocol) 拥塞控制 增加资源 网络提供 业务量感知的路由 减少负载 接纳控制 业务量减速 负载掉落 前三个：闭环方案，避免。。。自己学 后两个：开环方案，处理"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"/posts/"},{"@type":"ListItem","position":3,"name":"ch5-NetworkLayer","item":"/posts/computer-network/ch5-networklayer/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"ch5-NetworkLayer","name":"ch5-NetworkLayer","description":"问题 分组和分片的区别 adhoc网络——随机选路，哪学的 flooding序列号 复习Dijkstra DVR构造路径的过程 DVR好消息快，坏消息慢 学习拥塞控制前三个 111页实例 119 计算 习题知识点 电路交换预先分配资源，分组交换（虚电路、数据报）不会 任务 互联——不同网络 编址——统一地址，每个网络接口一个地址 分组——封装上层包，将其拆分成组 分片——适应不同的数据链路层技术 路由选择——路由器 为传输层提供的服务 虚电路 和 数据报\n技术 路由算法 路由表 = 路由算法（DVR, LSR, PVR） + 路由协议（ 动态路由协议：RIP, OSPF, BGP）\n路由算法：静态 or 自适应\n最优化原则：两点间有更短的路径则更新拓扑\nDijkstra的“最短路径”算法：自己复习\n选路策略：固定查表选路；洪泛(flooding）；随机选路；==自适应选路==\n分级/层次路由：。。。\n路由算法 Flooding （Distance Vector Routing）DVR (Link State Routing) LSR router所记录的 无需路由表 路由表：到每个节点的距离和下一跳 entire topology（只记录下一跳） 转发给 所有邻居（除incoming link） 所有邻居 **flooding **==LSP==（acked）（reliably） 转发时间 间隔性（RIP：30s） 拓扑改变时 五个过程：\u0026hellip;\u0026hellip; 超时删除记录（RIP：180s） LSP包：包含邻居的拓扑信息LSP包的构造：周期性/发生变故时集齐后，每个路由器计算自己的最短路径 应用 RIP (Routing Information Protocol) Cisco EIGRP (Enhanced Interior Gateway Routing Protocol) IS-ISOSPF 问题 重复 收敛慢好消息扩散快，坏消息传播慢无穷计数问题==基于谣传的选路== 解决方案 1-跳计数器递减至02-记录序列号 BGP-4 (Border Gateway Protocol) IDRP (Inter-domain Routing Protocol) 拥塞控制 增加资源 网络提供 业务量感知的路由 减少负载 接纳控制 业务量减速 负载掉落 前三个：闭环方案，避免。。。自己学 后两个：开环方案，处理","keywords":["Computer Network"],"articleBody":"问题 分组和分片的区别 adhoc网络——随机选路，哪学的 flooding序列号 复习Dijkstra DVR构造路径的过程 DVR好消息快，坏消息慢 学习拥塞控制前三个 111页实例 119 计算 习题知识点 电路交换预先分配资源，分组交换（虚电路、数据报）不会 任务 互联——不同网络 编址——统一地址，每个网络接口一个地址 分组——封装上层包，将其拆分成组 分片——适应不同的数据链路层技术 路由选择——路由器 为传输层提供的服务 虚电路 和 数据报\n技术 路由算法 路由表 = 路由算法（DVR, LSR, PVR） + 路由协议（ 动态路由协议：RIP, OSPF, BGP）\n路由算法：静态 or 自适应\n最优化原则：两点间有更短的路径则更新拓扑\nDijkstra的“最短路径”算法：自己复习\n选路策略：固定查表选路；洪泛(flooding）；随机选路；==自适应选路==\n分级/层次路由：。。。\n路由算法 Flooding （Distance Vector Routing）DVR (Link State Routing) LSR router所记录的 无需路由表 路由表：到每个节点的距离和下一跳 entire topology（只记录下一跳） 转发给 所有邻居（除incoming link） 所有邻居 **flooding **==LSP==（acked）（reliably） 转发时间 间隔性（RIP：30s） 拓扑改变时 五个过程：…… 超时删除记录（RIP：180s） LSP包：包含邻居的拓扑信息LSP包的构造：周期性/发生变故时集齐后，每个路由器计算自己的最短路径 应用 RIP (Routing Information Protocol) Cisco EIGRP (Enhanced Interior Gateway Routing Protocol) IS-ISOSPF 问题 重复 收敛慢好消息扩散快，坏消息传播慢无穷计数问题==基于谣传的选路== 解决方案 1-跳计数器递减至02-记录序列号 BGP-4 (Border Gateway Protocol) IDRP (Inter-domain Routing Protocol) 拥塞控制 增加资源 网络提供 业务量感知的路由 减少负载 接纳控制 业务量减速 负载掉落 前三个：闭环方案，避免。。。自己学 后两个：开环方案，处理\n业务量减速 预测是否发生拥塞 告知发送方 抑制分组：对数据包的源端发送抑制分组，使其减少发送量，只作用于发送方 逐跳反压：上面的抑制分组会作用到途径的每一个router 显式拥塞通知：改变拥塞标记位，目的端回显拥塞标志以告知发送方 发送方作出反应，减少发送量 负载掉落 （即将）发生拥塞（路由器被数据包淹没）时，丢弃数据包。\n随机早期检测：通过缓冲队列长度来判断是否即将发生拥塞，从而在发生拥塞前进行丢包处理。\n隐式通知：发送方收不到接受方的确认信息，从而判定发生了丢包，对拥塞作出反应。\n无线网络不能使用这种方式：因为其丢包一般是因为传输错误，而不是缓冲区溢出。\n服务质量Qos 带宽 延迟\n抖动\n误码率\n提高Qos方法 业务量整形\n漏桶 令牌桶 发送方每发送一包 往桶里放 从桶里取令牌，有令牌就随便发，没令牌时发送速率=产生令牌速率 桶满了 来的包排队或丢弃 丢弃令牌，不丢包 是否支持突发 不支持，始终匀速 支持小段突发 （计算：B+RS=MS） 分包调度\n先进先出 优先级 公平 公平加权 接纳控制\n资源预留、流协商、流描述\n网络互联 互联网：internet\n美国的那个：Internet\n目的：连接使用不同协议的网络\nDevices 设备的选择\n考虑以下设备\n中继器(Repeater)、集线器(HUB) 工作在物理层 仅仅是将信号从一根导线移动到另一根导线 多为模拟设备 不了解网络协议 网桥(Bridges)、交换机(Switches) 工作在链路层 仅了解以太网协议，做轻微协议转换 路由器(Router) 网络层 合适 网关(Gateway)等其他高层设备 以后介绍 路由器工作机理：收到数据包后去掉包头取出数据，需要转发时重新添加包头并发送数据包，所以在网络互联中可以使用不同的包头以转发到不同网络\n而网桥在转发数据包时并不去掉包头，直接转发整个数据包，因此并不能进行协议的处理。而且网桥基于MAC地址寻找目的而不是基于网络层地址\nTunneling隧道技术 如果发送方主机和目的主机使用的协议相同而中间经过的路径使用了不同的协议，可以使用**隧道(Tunneling)**技术\n使用中间网络的协议封装源主机发送的带有协议的数据包\nInternetwork Routing 因特网互连时使用一个两层的路由算法\n域内(intradomain)协议或内部网关协议(interior gateway protocol) 域间(interdomain)协议或外部网关协议(exterior gateway protocol) Packet Fragment 数据包分段\nMTU: Maximum Transmission Unit （信道的）最大传输单元，理应是数据链路层的属性\n决定MTU的因素\n硬件 操作系统 协议 国标 为了减少错误 为了增加信道利用率 分段方法\n透明分段 分段后一旦到达新的路由器就重组 对接收方来说透明，感知不到被分段 非透明分段 一旦分段就不再重组 目的主机接收到分段后自行重组 详见后文IPv4分段与重装\nPath MTU Discovery 路径MTU发现\n为了避免路由器分段，使源主机主动分段的策略\n发送数据包时设置数据包不可被分段。如果某个路由器发现数据包太大则返回一个错误信息，源端根据此错误信息重新将数据分段并重发。缺点是增加了发送数据包的启动延迟\nThe Network Layer in the Internet IPv4 Packet format IPv4协议头\nstructure 至少20字节\n重要的模块：\nIHL 头长度，以32位为单位，最小值为5，即20字节，最大值为15，即60字节 Total Length IP数据包总长度，单位为字节。即数据包最大65535字节 Identification 标识，表明此分段属于哪个数据报。相同数据报的标识相同 NU not used 未使用 DF Don’t Fragment =1时不允许路由器把此数据报分段 MF More Fragmens =1时代表此数据报还有更多分段 Fragment offset 分段偏移量 单位为8字节 Time to live 生存期 防止数据报永远在网络中循环 Protocol 目标协议，接收方应该使用哪种传输层协议(TCP/UDP等) Header checksum 头检验和 checksum 头校验和，只校验IP头是否正确。因为IP头的错误会引起更大的问题（错误转发等）。数据的校验交给高层，因为每次经过网络层都校验太复杂\n计算方法：\n把IP头分为以16位为单位的块 把所有块相加（包括checksum块，这一块初始为全0），得到sum。超过16位的进位加到末位 对sum取反，得到checksum 把checksum填充到checksum块 接收方校验\n把IP头分为以16位为单位的块 把所有块相加（包括checksum），得到sum。超过16位的进位加到末位 sum理论值应该是全1 对sum取反，得到checksum checksum理论值应该为全0 为什么不使用CRC校验？使用CRC需要在包内包含生成多项式G(X)，在网络层不具有通用性\nFragmentation and Re-assembly 分段与重装\n传输过程中可能会经过其他协议的网络，因为协议的MTU不同，所以数据可能会被分段与重装\n重要：因为offset块的单位为8字节，所以非尾数据段的数据长度必须为8字节的整数倍\n举例：一个原始IP数据包有424字节，offset=0，more=0，DF=0，经过一个MTU为230字节的信道，如何分段？\n解：424字节的数据包包括20字节协议头和404字节数据。230字节的信道减去20字节协议头还剩下210字节可以发送数据。第一段数据段长度必须是8字节的整数倍，所以应该是小于210的最大8的倍数208。所以第一段数据为\n20字节头 offset=0 more=1 DF=0 208字节数据 第二段数据是尾段，无长度限制\n20字节头 offset=208/8=26 more=0 DF=0 196字节数据 因特网中的网络层\nIP协议(Internet Protocol)\n使用最广泛的因特网协议 无连接网络层协议 不可靠(best-effort)，只提供尽力而为的服务 IPv4 Address IP地址的发展\n1981-分类地址(Classful Addressing) 1985-子网(Subnetting) 1993-超网(Supernetting) 1995-无类别地址(Classless Addressing) IP地址代表网络借口，如果一个主机连接了多个网络就会有多个IP地址\n路由器有多个接口，所以有多个IP地址\n32位，每8位(一个字节)为一组，通常使用点分十进制表示法\nClassful Addressing IP地址由两部分组成\n网络地址 主机地址 路由选择就是找网络地址\nA类地址 开头为0 7位网络地址 24位主机地址 B类地址 开头为10 14位网络地址 16位主机地址 C类地址 开头为110 21位网络地址 8位主机地址 D类地址 广播地址，略 E类地址 保留地址，略 记法：ABC类地址的开头分别是1、2、3位，主机地址分别是24/16/8位，其他为网络地址\n特殊地址：\n全0地址=本机 网络地址全0+主机地址=本地网络主机 全1地址=本地网络广播 网络地址+主机地址全1=目标网络广播 127.x.x.x=环回地址 网络地址+主机地址全0=网络地址 Default Mask 默认掩码/缺省掩码\n用来确定IP地址中的网络地址（和IP地址进行与运算）\nABC类网络的默认掩码分别为\n255.0.0.0 255.255.0.0 255.255.255.0 Subnetting 子网，把一个大网络拆分成多个小网络\n分类地址只有ABC三种尺寸，机构申请到一大块地址需要分配给不同部门。\n子网划分对外部不可见\n通过子网掩码(Subnet Mask)实现\n子网划分技术：每个子网的地址数量必须是2的n次方，其中包括2个特殊地址（网络地址+广播地址），容纳主机数量为2n-2。子网大小为m个地址（包括网络地址和广播地址）时，子网掩码后log2(m)位全是0\nSupernetting 超网\n分类地址只有ABC三种尺寸而且大块地址（即AB类地址）即将耗尽。解决方法：聚合小块地址（即C类地址），即路由聚合(Route Agregation)\n条件\nC类地址的数量必须是2的n次方 地址必须连续且可通过掩码计算 使用超网掩码(Supernet Mask)实现\nClassless Addressing 无类别地址\n不分类 网络地址长度不固定 CIDR(Classless InterDomain Routing)无类别域间选路\n使用前缀表示法(Slass Notation)，写为a.b.c.d/x，其中abcd仍为点分十进制中的十进制数，x为网络地址长度\n类似于超网，需要满足\n主机地址数量为2的n次方 地址连续且可通过掩码计算 路由聚合的计算与最长前缀匹配法\n可用地址的计算\n根据前缀得到网络地址长度 32-网络地址长度=主机地址长度n 共有2^n个地址，其中全0为网络地址，全1为广播地址 故可用地址数量为2^n-2个 NAT NAT Network Address Translation 网络地址翻译\n为了解决IP地址不够用的问题\n思路：使用两层IP地址，一层私有，一层共有。向外通信时需要把私有地址转换为共有地址（翻译）\n私有地址的范围\n10.0.0.0~10.255.255.255/8 172.16.0.0~192.31.255.255/12 192.168.0.0~192.168.255.255/16 以上私有地址不可能出现在因特网上，只能出现在网络内部\n设备：NAT盒子（可以被集成到路由器或ADSL调制解调器中）\n举例：校园网、手机热点\n新的问题：内部设备对外的IP地址都一样，NAT盒子如何把返回的数据送给指定的主机？\n解决方法：使用传输层的端口。NAT盒子可以记录如下传输表\n私有地址 私有端口 共有地址（只有一个） 共有端口 传输层协议 通过端口确定私有地址\nIPv6 更长的地址 128位\n更简单的协议头 路由器处理更迅速\n只是简单，因为有扩展头和选项字段的存在，IPv6的协议头比IPv4更长，只是路由器转发时不需要考虑罢了 新的“选项(Options)”字段 提供更多元功能\n更安全 新的安全措施也已经应用到了IPv4中\n服务质量更高\nIPv6 Header 相比于IPv4协议头的13个字段，IPv6协议头只有8个最主要的字段。其他内容通过“选项”字段添加\n下图为IP固定头，即必须的头（无选项字段） Version 版本 4位 IPv4为4 IPv6为6 Traffic class/Diff.services/PRI/Priority of packets 区分服务 8位 用来描述数据包的服务质量，对实时传递的要求 Flow label 流标签 20位 发送方和接收方之间存在一个“流”，在服务质量需要时路由器会为流预留带宽以保证这个流的延迟要求得到满足 Payload Length 有效载荷长度 16位 类似于IPv4中的总长度(Total Length)，但是不完全相同 记录的是IPv6的40字节固定头后面还有多少字节（选项字段+数据） Next Header 下一个头 8位 与IPv4的主要区别 IPv6使用扩展头来实现更多的功能，类似一个属性链表。如果当前头是最后一个IP头，那么下一个头指向传输层协议(TCP/UDP等) Hop Limit 跳数限制 8位 略 源地址与目的地址各32位*4=128位 详见IPv6 Address IPv6 Address 128位，16字节，最后4字节为IPv4地址\n表示方法：冒分十六进制，16个字节分为8组书写，每组4个16进制数，组之间使用冒号隔开\n如8000:0000:0000:0000:0123:4567:89AB:CDEF\n由于地址很长，有如下三个缩写规则\n如果存在完全由0构成的一个组或连续多个组，可以使用两个冒号代替 上述地址可缩写为8000::0123:4567:89AB:CDEF 为防止混淆，这种缩写方式只能使用一次 一个组中的前导0可以省略 上述地址可以缩写为8000::123:4567:89AB:CDEF IPv4地址可以表示为两个冒号加原本点分十进制数 上述地址可以缩写为::137.171.205.239 IPv4 vs IPv6 对比IPv4与IPv6，后者为了优化取消了哪些字段\n取消了IHL字段，因为IPv6协议拥有固定头，长度是定值 取消了Protocol字段，因为IPv6有下一个头字段 取消了分段相关的字段，根据路径MTU发现策略使防止路由器分段 取消Checksum校验和字段，当今网络已经比较可靠。相信数据链路层的校验 ARP, DHCP and ICMP ICMP(Internet Control Message Protocol) 因特网报文控制协议\n用来监视与报告路由器处理数据包时产生的异常。如路径MTU发现时出现的MTU不足以发送数据包的异常。协议定义了一系列事件，这些事件被触发时将被封装在IP数据包中报告给源主机。\n常见消息：\nDestination unreachable 目的地不可达 Packet could not be delivered 数据包无法传递 如果路由器无法定位一个目标或路由器MTU不足以发送数据包时报告 Time exceeded 超时 Time to live field hit 0 TTL字段减少到0 Parameter problem 参数问题 Invalid header field 协议头出错 Source quench 源抑制 Choke packet 使源主机减速（现在很少用） Redirect 重定向 Teach a router about geography 当一个数据包似乎被错误路由时报告 Echo and echo reply 回显与回显应答 Check if a machine is alive 判断某主机是否可达(ping) Timestamp request/reply 时间戳请求/应答 Same as Echo, but with timestamp 和回显类似，应答消息中还包含了请求消息的到达时间和应答消息的发出时间，可以用来测试网络性能 Router advertisement/solicitation 路由器通告/路由器恳求 Find a nearby router 寻找附近路由器 ARP(Address Resolution Protocol) 地址解析协议，IP Address -\u003e MAC Address\nExample 考虑如下网络\n第一种情况-同一局域网传输 假设Host1试图给Host2发送数据且Host1已经知道Host2的IP地址。交换机需要处理这个转发过程。交换机通过MAC地址工作，所以Host1需要发送的应该有Host2的MAC地址。但是Host1只通过DNS或其他方式得到了Host2的IP地址。如何使Host1发送的包内含有Host2的MAC地址？可以在Host1内保存一个配置文件（一个表），记录IP和MAC的对应关系。但是这个表会非常大，难以保存或查找。 解决方案：Host1在以太网发送一个广播包，请拥有Host2的IP地址的主机返回其MAC地址。以太网内所有主机都会接收到但是只有Host2会应答。Host2发送自己的MAC地址时也需要知道Host1的MAC地址（否则就只能像Host1一样广播），所以Host1在一开始发送广播包时应该带上自己的MAC地址。现在Host1和Host2都已经知道了对方的MAC地址，就可以正常通信。 第二种情况-非同一局域网传输 假设Host1试图给Host3发送数据且已经知道了Host3的IP地址。Host1发现Host3的IP地址所在网络和自己的网络不同，所以需要把包发给路由器。Host1已经知道了Router的IP地址但是不知道MAC地址。和第一种情况一样。使用同样方法解决。 Router也需要发送包给Host3，仍然使用同样的方法。所以在不同网络内发送数据包需要多次上述过程。 优化：\n每台主机保存一个规模比较小的IP地址与MAC地址的映射表 当有主机获得新的IP地址时发起一次广播，请求查找自己的IP地址。如果有别的主机应答说明IP地址分配有问题，网络管理员需要解决这个问题。如果没有应答则IP分配正确，而且其他主机还获得了这个主机的IP与MAC映射表。这被称为“免费ARP(Gratuitous ARP)” (Gratuitous 免费的 无偿的 无理由的) 注意路由器不会转发ARP包，因为这是以太网级别的包\nConclusion 结论：ARP协议工作流程如下。假设Host1和Host2在同一个局域网，Host1试图主动和Host2建立连接。Host1知道Host2的IP地址\nHost1在局域网内广播自己的IP-MAC映射表，并请求拥有Host2的IP的主机应答 Host2发现自己的IP地址和ARP请求中的地址相符，于是缓存下Host1的IP-MAC映射，给Host1发送自己的IP-MAC映射（非广播） 连接建立。开始通信 DHCP(Dynamic Host Configuration Protocol) 动态主机配置协议\n解决的问题：给主机分配IP地址\n电脑开机时发送一个DHCP包向DHCP服务器请求自己的IP地址。DHCP会返回一个IP地址和一个租赁期，在租赁期满之前主机必须请求DHCP续订，否则DHCP服务器将收回IP地址，防止DHCP的地址池被无效主机耗尽\nDHCP服务器可能有多个，返回多个IP地址，主机需要选择一个IP地址并返回租赁信息告诉对应的DHCP服务器：我已经选中了这个IP地址\nRouting Protocols: OSPF and BGP RIP(Routing Information Protocol) 路由信息协议\n应用在自治系统(AS)内部 使用距离矢量路由 距离使用跳数计算，最大跳数限制为16 使用UDP包 三个主要思想：\n分享自己知道的路由（距离矢量路由） 只给自己的直接邻居分享自己的路由表 没隔一段固定时间分享一次 主要问题：\n路由表冗余的比对升级过程 无穷计数响应慢（距离矢量路由） 路由表很大 OSPF(Open Shortest Path First) 开放的最短路径优先，内部网关路由协议，域内路由算法\n自治系统内部 使用链路状态路由 直接使用IP包 BGP 使用路径矢量路由-距离矢量路由的改进版：记录整条路径，避免了无穷计数问题\nRouting Protocol Summary RIP OSPF BGP 应用范围 AS内部 AS内部 AS之间 选路算法 距离矢量 链路状态 路径矢量 路由器交换的信息 到各网络的距离 网络拓扑结构 到各网络的路径 无穷计数问题 有 无 无 路由报文承载协议 UDP IP TCP ","wordCount":"649","inLanguage":"en","datePublished":"2023-02-21T16:29:43Z","dateModified":"2023-02-21T16:29:43Z","author":{"@type":"Person","name":"Chan"},"mainEntityOfPage":{"@type":"WebPage","@id":"/posts/computer-network/ch5-networklayer/"},"publisher":{"@type":"Organization","name":"Home","logo":{"@type":"ImageObject","url":"%3Clink%20/%20abs%20url%3E"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href accesskey=h title="Cheyne16's Blog (Alt + H)"><img src=/apple-touch-icon.png alt aria-label=logo height=35>Cheyne16's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=/categories/ title=categories><span>categories</span></a></li><li><a href=/tags/ title=tags><span>tags</span></a></li><li><a href=https://example.org title=example.org><span>example.org</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href>Home</a>&nbsp;»&nbsp;<a href=/posts/>Posts</a></div><h1 class=post-title>ch5-NetworkLayer</h1><div class=post-meta><span title='2023-02-21 16:29:43 +0000 UTC'>February 21, 2023</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;649 words&nbsp;·&nbsp;Chan&nbsp;|&nbsp;<a href=https://github.com/%3cpath_to_repo%3e/content/posts/Computer%20Network/ch5-NetworkLayer.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=post-content><h1 id=问题>问题<a hidden class=anchor aria-hidden=true href=#问题>#</a></h1><ol><li>分组和分片的区别</li><li>adhoc网络——随机选路，哪学的</li><li>flooding序列号</li><li>复习Dijkstra</li><li>DVR构造路径的过程</li><li>DVR好消息快，坏消息慢</li><li>学习拥塞控制前三个</li><li>111页实例</li><li>119 计算</li></ol><h1 id=习题知识点>习题知识点<a hidden class=anchor aria-hidden=true href=#习题知识点>#</a></h1><ul><li>电路交换预先分配资源，分组交换（虚电路、数据报）不会</li></ul><h1 id=任务>任务<a hidden class=anchor aria-hidden=true href=#任务>#</a></h1><ol><li>互联——不同网络</li><li>编址——统一地址，每个网络接口一个地址</li><li>分组——封装上层包，将其拆分成组</li><li>分片——适应不同的数据链路层技术</li><li>路由选择——路由器</li></ol><h1 id=为传输层提供的服务>为传输层提供的服务<a hidden class=anchor aria-hidden=true href=#为传输层提供的服务>#</a></h1><p>虚电路 和 数据报</p><h1 id=技术>技术<a hidden class=anchor aria-hidden=true href=#技术>#</a></h1><h2 id=路由算法>路由算法<a hidden class=anchor aria-hidden=true href=#路由算法>#</a></h2><p>路由表 = 路由算法（DVR, LSR, PVR） + 路由协议（ 动态路由协议：RIP, OSPF, BGP）</p><p>路由算法：静态 or 自适应</p><p>最优化原则：两点间有更短的路径则更新拓扑</p><p>Dijkstra的“最短路径”算法：自己复习</p><p>选路策略：固定查表选路；洪泛(flooding）；随机选路；==自适应选路==</p><p>分级/层次路由：。。。</p><table><thead><tr><th>路由算法</th><th>Flooding</th><th>（Distance Vector Routing）DVR</th><th>(Link State Routing) LSR</th></tr></thead><tbody><tr><td>router所记录的</td><td>无需路由表</td><td>路由表：到每个节点的<strong>距离</strong>和<strong>下一跳</strong></td><td>entire topology（只记录<strong>下一跳</strong>）</td></tr><tr><td>转发给</td><td>所有邻居（除incoming link）</td><td>所有邻居</td><td>**flooding **==LSP==（acked）（reliably）</td></tr><tr><td>转发时间</td><td></td><td>间隔性（RIP：30s）</td><td>拓扑改变时</td></tr><tr><td></td><td></td><td></td><td>五个过程：&mldr;&mldr;</td></tr><tr><td></td><td></td><td>超时删除记录（RIP：180s）</td><td>LSP包：包含邻居的拓扑信息LSP包的构造：周期性/发生变故时集齐后，每个路由器计算自己的最短路径</td></tr><tr><td>应用</td><td></td><td>RIP (Routing Information Protocol) Cisco EIGRP (Enhanced Interior Gateway Routing Protocol)</td><td>IS-ISOSPF</td></tr><tr><td>问题</td><td>重复</td><td>收敛慢好消息扩散快，坏消息传播慢无穷计数问题==基于谣传的选路==</td><td></td></tr><tr><td>解决方案</td><td>1-跳计数器递减至02-记录序列号</td><td>BGP-4 (Border Gateway Protocol) IDRP (Inter-domain Routing Protocol)</td><td></td></tr></tbody></table><h2 id=拥塞控制>拥塞控制<a hidden class=anchor aria-hidden=true href=#拥塞控制>#</a></h2><ul><li>增加资源<ul><li>网络提供</li><li>业务量感知的路由</li></ul></li><li>减少负载<ul><li>接纳控制</li><li>业务量减速</li><li>负载掉落</li></ul></li></ul><p>前三个：闭环方案，避免。。。自己学
后两个：开环方案，处理</p><h4 id=业务量减速>业务量减速<a hidden class=anchor aria-hidden=true href=#业务量减速>#</a></h4><ol><li>预测是否发生拥塞</li><li>告知发送方<ol><li>抑制分组：对数据包的源端发送抑制分组，使其减少发送量，只作用于发送方</li><li>逐跳反压：上面的抑制分组会作用到途径的每一个router</li><li>显式拥塞通知：改变拥塞标记位，目的端回显拥塞标志以告知发送方</li></ol></li><li>发送方作出反应，减少发送量</li></ol><h4 id=负载掉落>负载掉落<a hidden class=anchor aria-hidden=true href=#负载掉落>#</a></h4><p>（即将）发生拥塞（路由器被数据包淹没）时，丢弃数据包。</p><p>随机早期检测：通过缓冲队列长度来判断是否即将发生拥塞，从而在发生拥塞前进行丢包处理。</p><p>隐式通知：发送方收不到接受方的确认信息，从而判定发生了丢包，对拥塞作出反应。</p><p>无线网络不能使用这种方式：因为其丢包一般是因为传输错误，而不是缓冲区溢出。</p><h2 id=服务质量qos>服务质量Qos<a hidden class=anchor aria-hidden=true href=#服务质量qos>#</a></h2><p>带宽 延迟</p><p>抖动</p><p>误码率</p><h4 id=提高qos方法>提高Qos方法<a hidden class=anchor aria-hidden=true href=#提高qos方法>#</a></h4><ol><li><p>业务量整形</p><table><thead><tr><th></th><th>漏桶</th><th>令牌桶</th></tr></thead><tbody><tr><td>发送方每发送一包</td><td>往桶里放</td><td>从桶里取令牌，有令牌就随便发，没令牌时发送速率=产生令牌速率</td></tr><tr><td>桶满了</td><td>来的包排队或丢弃</td><td>丢弃令牌，不丢包</td></tr><tr><td>是否支持突发</td><td>不支持，始终匀速</td><td>支持小段突发 （计算：B+RS=MS）</td></tr><tr><td></td><td></td><td></td></tr></tbody></table></li><li><p>分包调度</p><ol><li>先进先出</li><li>优先级</li><li>公平</li><li>公平加权</li></ol></li><li><p>接纳控制</p><p>资源预留、流协商、流描述</p></li></ol><h2 id=网络互联>网络互联<a hidden class=anchor aria-hidden=true href=#网络互联>#</a></h2><p>互联网：internet</p><p>美国的那个：Internet</p><p>目的：连接使用不同协议的网络</p><h3 id=devices>Devices<a hidden class=anchor aria-hidden=true href=#devices>#</a></h3><p>设备的选择</p><p>考虑以下设备</p><ul><li>中继器(Repeater)、集线器(HUB)<ul><li>工作在物理层</li><li>仅仅是将信号从一根导线移动到另一根导线</li><li>多为模拟设备</li><li>不了解网络协议</li></ul></li><li>网桥(Bridges)、交换机(Switches)<ul><li>工作在链路层</li><li>仅了解以太网协议，做轻微协议转换</li></ul></li><li>路由器(Router)<ul><li>网络层</li><li><strong>合适</strong></li></ul></li><li>网关(Gateway)等其他高层设备<ul><li>以后介绍</li></ul></li></ul><p>路由器工作机理：收到数据包后<strong>去掉包头</strong>取出数据，需要转发时重新<strong>添加包头</strong>并发送数据包，所以在网络互联中可以使用不同的包头以转发到不同网络</p><p>而网桥在转发数据包时并不去掉包头，直接转发整个数据包，因此并不能进行协议的处理。而且网桥基于MAC地址寻找目的而不是基于网络层地址</p><h3 id=tunneling隧道技术>Tunneling隧道技术<a hidden class=anchor aria-hidden=true href=#tunneling隧道技术>#</a></h3><p>如果发送方主机和目的主机使用的协议相同而中间经过的路径使用了不同的协议，可以使用**隧道(Tunneling)**技术</p><p>使用中间网络的协议封装源主机发送的带有协议的数据包</p><h3 id=internetwork-routing>Internetwork Routing<a hidden class=anchor aria-hidden=true href=#internetwork-routing>#</a></h3><p>因特网互连时使用一个两层的路由算法</p><ul><li>域内(intradomain)协议或内部网关协议(interior gateway protocol)</li><li>域间(interdomain)协议或外部网关协议(exterior gateway protocol)</li></ul><h3 id=packet-fragment>Packet Fragment<a hidden class=anchor aria-hidden=true href=#packet-fragment>#</a></h3><p>数据包分段</p><p>MTU: Maximum Transmission Unit （信道的）最大传输单元，理应是数据链路层的属性</p><p>决定MTU的因素</p><ul><li>硬件</li><li>操作系统</li><li>协议</li><li>国标</li><li>为了减少错误</li><li>为了增加信道利用率</li></ul><p>分段方法</p><ul><li>透明分段<ul><li>分段后一旦到达新的路由器就重组</li><li>对接收方来说透明，感知不到被分段</li></ul></li><li>非透明分段<ul><li>一旦分段就不再重组</li><li>目的主机接收到分段后自行重组</li></ul></li></ul><p>详见后文<a href=https://discretetom.github.io/academic/ComputerNetwork/5/#Fragmentation-and-Re-assembly>IPv4分段与重装</a></p><h3 id=path-mtu-discovery>Path MTU Discovery<a hidden class=anchor aria-hidden=true href=#path-mtu-discovery>#</a></h3><p>路径MTU发现</p><p>为了避免路由器分段，使源主机主动分段的策略</p><p>发送数据包时设置数据包不可被分段。如果某个路由器发现数据包太大则返回一个错误信息，源端根据此错误信息重新将数据分段并重发。缺点是增加了发送数据包的启动延迟</p><h1 id=the-network-layer-in-the-internet>The Network Layer in the Internet<a hidden class=anchor aria-hidden=true href=#the-network-layer-in-the-internet>#</a></h1><h2 id=ipv4--packet-format>IPv4 Packet format<a hidden class=anchor aria-hidden=true href=#ipv4--packet-format>#</a></h2><p>IPv4协议头</p><h4 id=structure>structure<a hidden class=anchor aria-hidden=true href=#structure>#</a></h4><p>至少20字节</p><p><img loading=lazy src=https://discretetom.github.io/_nuxt/img/16ef9db.png alt=5-1></p><p>重要的模块：</p><ul><li>IHL<ul><li>头长度，以32位为单位，最小值为5，即20字节，最大值为15，即60字节</li></ul></li><li>Total Length<ul><li>IP数据包总长度，单位为字节。即数据包最大65535字节</li></ul></li><li>Identification<ul><li>标识，表明此分段属于哪个数据报。相同数据报的标识相同</li></ul></li><li>NU<ul><li>not used</li><li>未使用</li></ul></li><li>DF<ul><li>Don’t Fragment</li><li>=1时不允许路由器把此数据报分段</li></ul></li><li>MF<ul><li>More Fragmens</li><li>=1时代表此数据报还有更多分段</li></ul></li><li>Fragment offset<ul><li>分段偏移量</li><li>单位为8字节</li></ul></li><li>Time to live<ul><li>生存期</li><li>防止数据报永远在网络中循环</li></ul></li><li>Protocol<ul><li>目标协议，接收方应该使用哪种传输层协议(TCP/UDP等)</li></ul></li><li>Header checksum<ul><li>头检验和</li></ul></li></ul><h4 id=checksum>checksum<a hidden class=anchor aria-hidden=true href=#checksum>#</a></h4><p>头校验和，只校验IP头是否正确。因为IP头的错误会引起更大的问题（错误转发等）。数据的校验交给高层，因为每次经过网络层都校验太复杂</p><p>计算方法：</p><ul><li>把IP头分为以16位为单位的块</li><li>把所有块相加（包括checksum块，这一块初始为全0），得到sum。<strong>超过16位的进位加到末位</strong></li><li>对sum取反，得到checksum</li><li>把checksum填充到checksum块</li></ul><p>接收方校验</p><ul><li>把IP头分为以16位为单位的块</li><li>把所有块相加（包括checksum），得到sum。<strong>超过16位的进位加到末位</strong></li><li>sum理论值应该是全1</li><li>对sum取反，得到checksum</li><li>checksum理论值应该为全0</li></ul><p>为什么不使用CRC校验？使用CRC需要在包内包含生成多项式G(X)，在网络层不具有通用性</p><h4 id=fragmentation-and-re-assembly>Fragmentation and Re-assembly<a hidden class=anchor aria-hidden=true href=#fragmentation-and-re-assembly>#</a></h4><p>分段与重装</p><p>传输过程中可能会经过其他协议的网络，因为协议的MTU不同，所以数据可能会被分段与重装</p><p>重要：因为offset块的单位为8字节，所以<strong>非尾</strong>数据段的<strong>数据长度</strong>必须为<strong>8字节</strong>的整数倍</p><p>举例：一个原始IP数据包有424字节，offset=0，more=0，DF=0，经过一个MTU为230字节的信道，如何分段？</p><p>解：424字节的数据包包括20字节协议头和404字节数据。230字节的信道减去20字节协议头还剩下210字节可以发送数据。第一段数据段长度必须是8字节的整数倍，所以应该是小于210的最大8的倍数208。所以第一段数据为</p><ul><li>20字节头<ul><li>offset=0</li><li>more=1</li><li>DF=0</li></ul></li><li>208字节数据</li></ul><p>第二段数据是尾段，无长度限制</p><ul><li>20字节头<ul><li>offset=208/8=26</li><li>more=0</li><li>DF=0</li></ul></li><li>196字节数据</li></ul><p>因特网中的网络层</p><p>IP协议(Internet Protocol)</p><ul><li>使用最广泛的因特网协议</li><li><strong>无连接</strong>网络层协议</li><li><strong>不可靠</strong>(best-effort)，只提供<strong>尽力而为</strong>的服务</li></ul><h2 id=ipv4-address>IPv4 Address<a hidden class=anchor aria-hidden=true href=#ipv4-address>#</a></h2><p>IP地址的发展</p><ul><li>1981-分类地址(Classful Addressing)</li><li>1985-子网(Subnetting)</li><li>1993-超网(Supernetting)</li><li>1995-无类别地址(Classless Addressing)</li></ul><p>IP地址代表网络借口，如果一个主机连接了多个网络就会有多个IP地址</p><p>路由器有多个接口，所以有多个IP地址</p><p>32位，每8位(一个字节)为一组，通常使用<strong>点分十进制</strong>表示法</p><h4 id=classful-addressing>Classful Addressing<a hidden class=anchor aria-hidden=true href=#classful-addressing>#</a></h4><p>IP地址由两部分组成</p><ul><li>网络地址</li><li>主机地址</li></ul><p>路由选择就是找网络地址</p><ul><li>A类地址<ul><li>开头为0</li><li>7位网络地址</li><li>24位主机地址</li></ul></li><li>B类地址<ul><li>开头为10</li><li>14位网络地址</li><li>16位主机地址</li></ul></li><li>C类地址<ul><li>开头为110</li><li>21位网络地址</li><li>8位主机地址</li></ul></li><li>D类地址<ul><li>广播地址，略</li></ul></li><li>E类地址<ul><li>保留地址，略</li></ul></li></ul><p>记法：ABC类地址的开头分别是1、2、3位，主机地址分别是24/16/8位，其他为网络地址</p><p>特殊地址：</p><ul><li>全0地址=本机</li><li>网络地址全0+主机地址=本地网络主机</li><li>全1地址=本地网络广播</li><li>网络地址+主机地址全1=目标网络广播</li><li>127.x.x.x=环回地址</li><li>网络地址+主机地址全0=网络地址</li></ul><h4 id=default-mask>Default Mask<a hidden class=anchor aria-hidden=true href=#default-mask>#</a></h4><p>默认掩码/缺省掩码</p><p>用来确定IP地址中的网络地址（和IP地址进行与运算）</p><p>ABC类网络的默认掩码分别为</p><ul><li>255.0.0.0</li><li>255.255.0.0</li><li>255.255.255.0</li></ul><h4 id=subnetting>Subnetting<a hidden class=anchor aria-hidden=true href=#subnetting>#</a></h4><p>子网，把一个大网络拆分成多个小网络</p><p>分类地址只有ABC三种尺寸，机构申请到一大块地址需要分配给不同部门。</p><p>子网划分对外部不可见</p><p>通过子网掩码(Subnet Mask)实现</p><p>子网划分技术：每个子网的地址数量必须是2的n次方，其中包括2个特殊地址（网络地址+广播地址），容纳主机数量为2n-2。子网大小为m个地址（包括网络地址和广播地址）时，<strong>子网掩码后log2(m)位全是0</strong></p><h4 id=supernetting>Supernetting<a hidden class=anchor aria-hidden=true href=#supernetting>#</a></h4><p>超网</p><p>分类地址只有ABC三种尺寸而且大块地址（即AB类地址）即将耗尽。解决方法：聚合小块地址（即C类地址），即<strong>路由聚合(Route Agregation)</strong></p><p>条件</p><ul><li>C类地址的数量必须是2的n次方</li><li>地址必须连续<strong>且可通过掩码计算</strong></li></ul><p>使用超网掩码(Supernet Mask)实现</p><h4 id=classless-addressing>Classless Addressing<a hidden class=anchor aria-hidden=true href=#classless-addressing>#</a></h4><p>无类别地址</p><ul><li>不分类</li><li>网络地址长度不固定</li></ul><p>CIDR(Classless InterDomain Routing)无类别域间选路</p><p>使用前缀表示法(Slass Notation)，写为a.b.c.d/x，其中abcd仍为点分十进制中的十进制数，x为网络地址长度</p><p>类似于超网，需要满足</p><ul><li>主机地址数量为2的n次方</li><li>地址连续且可通过掩码计算</li></ul><p><strong>路由聚合的计算与最长前缀匹配法</strong></p><p>可用地址的计算</p><ul><li>根据前缀得到网络地址长度</li><li>32-网络地址长度=主机地址长度n</li><li>共有2^n个地址，其中全0为网络地址，全1为广播地址</li><li>故可用地址数量为<strong>2^n-2</strong>个</li></ul><h4 id=nat>NAT<a hidden class=anchor aria-hidden=true href=#nat>#</a></h4><p>NAT Network Address Translation 网络地址翻译</p><p>为了解决IP地址不够用的问题</p><p>思路：使用两层IP地址，一层私有，一层共有。向外通信时需要把私有地址转换为共有地址（翻译）</p><p>私有地址的范围</p><ul><li>10.0.0.0~10.255.255.255/8</li><li>172.16.0.0~192.31.255.255/12</li><li>192.168.0.0~192.168.255.255/16</li></ul><p>以上私有地址不可能出现在因特网上，只能出现在网络内部</p><p>设备：NAT盒子（可以被集成到路由器或ADSL调制解调器中）</p><p>举例：校园网、手机热点</p><p>新的问题：内部设备对外的IP地址都一样，NAT盒子如何把返回的数据送给指定的主机？</p><p>解决方法：使用传输层的端口。NAT盒子可以记录如下传输表</p><ul><li>私有地址</li><li>私有端口</li><li>共有地址（只有一个）</li><li>共有端口</li><li>传输层协议</li></ul><p>通过端口确定私有地址</p><ul><li></li></ul><h2 id=ipv6>IPv6<a hidden class=anchor aria-hidden=true href=#ipv6>#</a></h2><ul><li><p>更长的地址 128位</p></li><li><p>更简单的协议头 路由器处理更迅速</p><ul><li>只是简单，<strong>因为有扩展头和选项字段的存在，IPv6的协议头比IPv4更长</strong>，只是路由器转发时不需要考虑罢了</li></ul></li><li><p>新的“选项(Options)”字段 提供更多元功能</p></li><li><p>更安全 新的安全措施也已经应用到了IPv4中</p></li><li><p>服务质量更高</p></li></ul><h3 id=ipv6-header>IPv6 Header<a hidden class=anchor aria-hidden=true href=#ipv6-header>#</a></h3><p>相比于IPv4协议头的13个字段，IPv6协议头只有8个最主要的字段。其他内容通过“选项”字段添加</p><p>下图为<strong>IP固定头</strong>，即必须的头（无选项字段） <img loading=lazy src=https://discretetom.github.io/_nuxt/img/f66b2f7.png alt=5-2></p><ul><li>Version 版本 4位<ul><li>IPv4为4 IPv6为6</li></ul></li><li>Traffic class/Diff.services/PRI/Priority of packets 区分服务 8位<ul><li>用来描述数据包的服务质量，对实时传递的要求</li></ul></li><li>Flow label 流标签 20位<ul><li>发送方和接收方之间存在一个“流”，在服务质量需要时路由器会为流预留带宽以保证这个流的延迟要求得到满足</li></ul></li><li>Payload Length 有效载荷长度 16位<ul><li>类似于IPv4中的总长度(Total Length)，但是不完全相同</li><li>记录的是IPv6的40字节<strong>固定头后面</strong>还有多少字节（选项字段+数据）</li></ul></li><li>Next Header 下一个头 8位<ul><li>与IPv4的主要区别</li><li>IPv6使用<strong>扩展头</strong>来实现更多的功能，类似一个属性链表。如果当前头是最后一个IP头，那么下一个头指向传输层协议(TCP/UDP等)</li></ul></li><li>Hop Limit 跳数限制 8位 略</li><li>源地址与目的地址各32位*4=128位 详见<a href=https://discretetom.github.io/academic/ComputerNetwork/5/#IPv6-Address>IPv6 Address</a></li></ul><h3 id=ipv6-address>IPv6 Address<a hidden class=anchor aria-hidden=true href=#ipv6-address>#</a></h3><p>128位，16字节，最后4字节为IPv4地址</p><p>表示方法：<strong>冒分十六进制</strong>，16个字节分为8组书写，每组4个16进制数，组之间使用冒号隔开</p><p>如8000:0000:0000:0000:0123:4567:89AB:CDEF</p><p>由于地址很长，有如下三个缩写规则</p><ol><li>如果存在完全由0构成的一个组或连续多个组，可以使用两个冒号代替<ul><li>上述地址可缩写为8000::0123:4567:89AB:CDEF</li><li>为防止混淆，这种缩写方式只能使用一次</li></ul></li><li>一个组中的前导0可以省略<ul><li>上述地址可以缩写为8000::123:4567:89AB:CDEF</li></ul></li><li>IPv4地址可以表示为两个冒号加原本点分十进制数<ul><li>上述地址可以缩写为::137.171.205.239</li></ul></li></ol><h3 id=ipv4-vs-ipv6>IPv4 vs IPv6<a hidden class=anchor aria-hidden=true href=#ipv4-vs-ipv6>#</a></h3><p>对比IPv4与IPv6，后者为了优化取消了哪些字段</p><ul><li>取消了IHL字段，因为IPv6协议拥有固定头，长度是定值</li><li>取消了Protocol字段，因为IPv6有下一个头字段</li><li>取消了分段相关的字段，根据<a href=https://discretetom.github.io/academic/ComputerNetwork/5/#Path-MTU-Discovery>路径MTU发现</a>策略使防止路由器分段</li><li>取消Checksum校验和字段，当今网络已经比较可靠。相信数据链路层的校验</li></ul><h2 id=arp-dhcp-and-icmp>ARP, DHCP and ICMP<a hidden class=anchor aria-hidden=true href=#arp-dhcp-and-icmp>#</a></h2><h4 id=icmpinternet-control-message-protocol>ICMP(Internet Control Message Protocol)<a hidden class=anchor aria-hidden=true href=#icmpinternet-control-message-protocol>#</a></h4><p>因特网报文控制协议</p><p>用来监视与报告路由器处理数据包时产生的异常。如路径MTU发现时出现的MTU不足以发送数据包的异常。协议定义了一系列事件，这些事件被触发时将被封装在IP数据包中报告给源主机。</p><p>常见消息：</p><ul><li>Destination unreachable 目的地不可达<ul><li>Packet could not be delivered 数据包无法传递</li><li>如果路由器无法定位一个目标或路由器MTU不足以发送数据包时报告</li></ul></li><li>Time exceeded 超时<ul><li>Time to live field hit 0 TTL字段减少到0</li></ul></li><li>Parameter problem 参数问题<ul><li>Invalid header field 协议头出错</li></ul></li><li>Source quench 源抑制<ul><li>Choke packet 使源主机减速（现在很少用）</li></ul></li><li>Redirect 重定向<ul><li>Teach a router about geography</li><li>当一个数据包似乎被错误路由时报告</li></ul></li><li>Echo and echo reply 回显与回显应答<ul><li>Check if a machine is alive 判断某主机是否可达(ping)</li></ul></li><li>Timestamp request/reply 时间戳请求/应答<ul><li>Same as Echo, but with timestamp 和回显类似，应答消息中还包含了请求消息的到达时间和应答消息的发出时间，可以用来测试网络性能</li></ul></li><li>Router advertisement/solicitation 路由器通告/路由器恳求<ul><li>Find a nearby router 寻找附近路由器</li></ul></li></ul><h4 id=arpaddress-resolution-protocol>ARP(Address Resolution Protocol)<a hidden class=anchor aria-hidden=true href=#arpaddress-resolution-protocol>#</a></h4><p>地址解析协议，IP Address -> MAC Address</p><h5 id=example>Example<a hidden class=anchor aria-hidden=true href=#example>#</a></h5><p>考虑如下网络</p><p><img loading=lazy src=https://discretetom.github.io/_nuxt/img/eca75c7.png alt=5-3></p><ol><li>第一种情况-同一局域网传输<ul><li>假设Host1试图给Host2发送数据且Host1已经知道Host2的IP地址。交换机需要处理这个转发过程。交换机通过MAC地址工作，所以Host1需要发送的应该有Host2的MAC地址。但是Host1只通过DNS或其他方式得到了Host2的IP地址。如何使Host1发送的包内含有Host2的MAC地址？可以在Host1内保存一个配置文件（一个表），记录IP和MAC的对应关系。但是这个表会非常大，难以保存或查找。</li><li>解决方案：Host1在以太网发送一个广播包，请拥有Host2的IP地址的主机返回其MAC地址。以太网内所有主机都会接收到但是只有Host2会应答。Host2发送自己的MAC地址时也需要知道Host1的MAC地址（否则就只能像Host1一样广播），所以Host1在一开始发送广播包时应该带上自己的MAC地址。现在Host1和Host2都已经知道了对方的MAC地址，就可以正常通信。</li></ul></li><li>第二种情况-非同一局域网传输<ul><li>假设Host1试图给Host3发送数据且已经知道了Host3的IP地址。Host1发现Host3的IP地址所在网络和自己的网络不同，所以需要把包发给路由器。Host1已经知道了Router的IP地址但是不知道MAC地址。和第一种情况一样。使用同样方法解决。</li><li>Router也需要发送包给Host3，仍然使用同样的方法。所以在不同网络内发送数据包需要多次上述过程。</li></ul></li></ol><p>优化：</p><ul><li>每台主机保存一个规模比较小的IP地址与MAC地址的映射表</li><li>当有主机获得新的IP地址时发起一次广播，请求查找自己的IP地址。如果有别的主机应答说明IP地址分配有问题，网络管理员需要解决这个问题。如果没有应答则IP分配正确，而且其他主机还获得了这个主机的IP与MAC映射表。这被称为“<strong>免费ARP(Gratuitous ARP)</strong>” (Gratuitous 免费的 无偿的 无理由的)</li></ul><p>注意路由器不会转发ARP包，因为这是以太网级别的包</p><h5 id=conclusion>Conclusion<a hidden class=anchor aria-hidden=true href=#conclusion>#</a></h5><p>结论：ARP协议工作流程如下。假设Host1和Host2在同一个局域网，Host1试图主动和Host2建立连接。Host1知道Host2的IP地址</p><ol><li>Host1在局域网内广播自己的IP-MAC映射表，并请求拥有Host2的IP的主机应答</li><li>Host2发现自己的IP地址和ARP请求中的地址相符，于是缓存下Host1的IP-MAC映射，给Host1发送自己的IP-MAC映射（非广播）</li><li>连接建立。开始通信</li></ol><h4 id=dhcpdynamic-host-configuration-protocol>DHCP(Dynamic Host Configuration Protocol)<a hidden class=anchor aria-hidden=true href=#dhcpdynamic-host-configuration-protocol>#</a></h4><p>动态主机配置协议</p><p>解决的问题：给主机分配IP地址</p><p><img loading=lazy src=https://discretetom.github.io/_nuxt/img/60271d5.png alt=5-6></p><p>电脑开机时发送一个DHCP包向DHCP服务器请求自己的IP地址。DHCP会返回一个IP地址和一个<strong>租赁期</strong>，在租赁期满之前主机必须请求<strong>DHCP续订</strong>，否则DHCP服务器将收回IP地址，防止DHCP的地址池被无效主机耗尽</p><p>DHCP服务器可能有多个，返回多个IP地址，主机需要选择一个IP地址并返回租赁信息告诉对应的DHCP服务器：我已经选中了这个IP地址</p><h2 id=routing-protocols-ospf-and-bgp>Routing Protocols: OSPF and BGP<a hidden class=anchor aria-hidden=true href=#routing-protocols-ospf-and-bgp>#</a></h2><h4 id=riprouting-information-protocol>RIP(Routing Information Protocol)<a hidden class=anchor aria-hidden=true href=#riprouting-information-protocol>#</a></h4><p>路由信息协议</p><ul><li>应用在自治系统(AS)内部</li><li>使用距离矢量路由</li><li>距离使用跳数计算，最大跳数限制为16</li><li>使用UDP包</li></ul><p>三个主要思想：</p><ul><li>分享自己知道的路由（距离矢量路由）</li><li>只给自己的直接邻居分享自己的路由表</li><li>没隔一段固定时间分享一次</li></ul><p>主要问题：</p><ul><li>路由表冗余的比对升级过程</li><li>无穷计数响应慢（距离矢量路由）</li><li>路由表很大</li></ul><h4 id=ospfopen-shortest-path-first>OSPF(Open Shortest Path First)<a hidden class=anchor aria-hidden=true href=#ospfopen-shortest-path-first>#</a></h4><p>开放的最短路径优先，内部网关路由协议，域内路由算法</p><ul><li>自治系统内部</li><li>使用链路状态路由</li><li>直接使用IP包</li></ul><h4 id=bgp>BGP<a hidden class=anchor aria-hidden=true href=#bgp>#</a></h4><p>使用路径矢量路由-距离矢量路由的改进版：记录整条路径，避免了无穷计数问题</p><h3 id=routing-protocol-summary>Routing Protocol Summary<a hidden class=anchor aria-hidden=true href=#routing-protocol-summary>#</a></h3><table><thead><tr><th></th><th>RIP</th><th>OSPF</th><th>BGP</th></tr></thead><tbody><tr><td>应用范围</td><td>AS内部</td><td>AS内部</td><td>AS之间</td></tr><tr><td>选路算法</td><td>距离矢量</td><td>链路状态</td><td>路径矢量</td></tr><tr><td>路由器交换的信息</td><td>到各网络的距离</td><td>网络拓扑结构</td><td>到各网络的路径</td></tr><tr><td>无穷计数问题</td><td>有</td><td>无</td><td>无</td></tr><tr><td>路由报文承载协议</td><td>UDP</td><td>IP</td><td>TCP</td></tr></tbody></table></div><footer class=post-footer><ul class=post-tags><li><a href=/tags/computer-network/>Computer Network</a></li></ul><nav class=paginav><a class=prev href=/posts/principles-of-compiler/ch4-%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90/><span class=title>« Prev</span><br><span>ch4-语法分析</span></a>
<a class=next href=/posts/formal-languages-and-automata/ch5-%E5%9B%BE%E7%81%B5%E6%9C%BA/><span class=title>Next »</span><br><span>ch5-图灵机</span></a></nav><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share ch5-NetworkLayer on twitter" href="https://twitter.com/intent/tweet/?text=ch5-NetworkLayer&url=%2fposts%2fcomputer-network%2fch5-networklayer%2f&hashtags=ComputerNetwork"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share ch5-NetworkLayer on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=%2fposts%2fcomputer-network%2fch5-networklayer%2f&title=ch5-NetworkLayer&summary=ch5-NetworkLayer&source=%2fposts%2fcomputer-network%2fch5-networklayer%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share ch5-NetworkLayer on reddit" href="https://reddit.com/submit?url=%2fposts%2fcomputer-network%2fch5-networklayer%2f&title=ch5-NetworkLayer"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share ch5-NetworkLayer on facebook" href="https://facebook.com/sharer/sharer.php?u=%2fposts%2fcomputer-network%2fch5-networklayer%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share ch5-NetworkLayer on whatsapp" href="https://api.whatsapp.com/send?text=ch5-NetworkLayer%20-%20%2fposts%2fcomputer-network%2fch5-networklayer%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share ch5-NetworkLayer on telegram" href="https://telegram.me/share/url?text=ch5-NetworkLayer&url=%2fposts%2fcomputer-network%2fch5-networklayer%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></div></footer></article></main><footer class=footer><span>&copy; 2023 <a href>Home</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>