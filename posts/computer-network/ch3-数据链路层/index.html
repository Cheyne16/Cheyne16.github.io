<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>ch3 数据链路层 | Home</title><meta name=keywords content="Computer Network"><meta name=description content="数据链路层 地位、功能 为网络层传来的packet加头和尾（即协议），再以frame形式的PDU传送给对等层，对等层通过成帧技术得到数据。 尾：检错码
该层功能在网卡上实现（小部分在操作系统驱动实现），所以功能不宜太复杂，而且现在物理传输介质比较好，所以甚至可以不用在链路层考虑差错控制（如 物理层用光纤）。现在的网卡和主机不分离，是一体的。
提供给网络层的三类服务： （丢失 差错 乱序 重复）
无连接服务： 无确认的： eg：UDP 1）应用层需要实时性高（时延、带宽）的服务，不在意传输质量（误码率）&mdash;&mdash; 实时音视频通信；2）底层物理传输介质非常好。 比如：有线局域网（有线、近距离 &ndash;> 干扰少误码少） eg：以太网 有确认的： eg：无线系统，如 wifi &mdash;> 因为网络传输链路质量不好，所以需要确认。 1）传输正确发确认信息（ACK），用的多。 eg: TCP 2）传输错误发确认信息（NAK） 有确认的面向连接服务：1）高层需要可靠传输；2）链路不好，距离长，易误码。 eg：TCP 技术 成帧 字符填充 和 比特填充 一样，只不过适用于不同协议（以字符/比特传输）。
前三个效率都不到100%。
可能多种技术并用，如 以太网 &mdash; 第1+4种。
差错控制 错误种类：单个错误（常见），多个错误，数据包丢失
纠错 （适合易出错的信道） 前向纠错（FEC）：接收方能够检测并纠正错误，如 海明码 自动请求重传（ARQ）：适合误码率小于 10^-5^ 的信道。 检错 + 重传 （适合质量好的信道） 奇偶校验 交错校验 CRC （循环冗余校验）&mdash;- 利用二进制除法 流量控制 和 差错控制 是结合在一起的
基于反馈的流量控制 &mdash;- 6个协议，前三个：单工（一发一收）；后三个：双工 停等：一个帧，等一下。
​	太慢。尤其对带宽时延积大的，浪费信道。"><meta name=author content="Chan"><link rel=canonical href=/posts/computer-network/ch3-%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.6a98292fb8fa8cf0f3ba4042d4b75515c04267550f3ad49ff6271b5af9562443.css integrity="sha256-apgpL7j6jPDzukBC1LdVFcBCZ1UPOtSf9icbWvlWJEM=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-123-45","auto"),ga("send","pageview"))</script><meta property="og:title" content="ch3 数据链路层"><meta property="og:description" content="数据链路层 地位、功能 为网络层传来的packet加头和尾（即协议），再以frame形式的PDU传送给对等层，对等层通过成帧技术得到数据。 尾：检错码
该层功能在网卡上实现（小部分在操作系统驱动实现），所以功能不宜太复杂，而且现在物理传输介质比较好，所以甚至可以不用在链路层考虑差错控制（如 物理层用光纤）。现在的网卡和主机不分离，是一体的。
提供给网络层的三类服务： （丢失 差错 乱序 重复）
无连接服务： 无确认的： eg：UDP 1）应用层需要实时性高（时延、带宽）的服务，不在意传输质量（误码率）&mdash;&mdash; 实时音视频通信；2）底层物理传输介质非常好。 比如：有线局域网（有线、近距离 &ndash;> 干扰少误码少） eg：以太网 有确认的： eg：无线系统，如 wifi &mdash;> 因为网络传输链路质量不好，所以需要确认。 1）传输正确发确认信息（ACK），用的多。 eg: TCP 2）传输错误发确认信息（NAK） 有确认的面向连接服务：1）高层需要可靠传输；2）链路不好，距离长，易误码。 eg：TCP 技术 成帧 字符填充 和 比特填充 一样，只不过适用于不同协议（以字符/比特传输）。
前三个效率都不到100%。
可能多种技术并用，如 以太网 &mdash; 第1+4种。
差错控制 错误种类：单个错误（常见），多个错误，数据包丢失
纠错 （适合易出错的信道） 前向纠错（FEC）：接收方能够检测并纠正错误，如 海明码 自动请求重传（ARQ）：适合误码率小于 10^-5^ 的信道。 检错 + 重传 （适合质量好的信道） 奇偶校验 交错校验 CRC （循环冗余校验）&mdash;- 利用二进制除法 流量控制 和 差错控制 是结合在一起的
基于反馈的流量控制 &mdash;- 6个协议，前三个：单工（一发一收）；后三个：双工 停等：一个帧，等一下。
​	太慢。尤其对带宽时延积大的，浪费信道。"><meta property="og:type" content="article"><meta property="og:url" content="/posts/computer-network/ch3-%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/"><meta property="og:image" content="%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-02-21T16:29:43+00:00"><meta property="article:modified_time" content="2023-02-21T16:29:43+00:00"><meta property="og:site_name" content="Chancellor16's Blog"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="ch3 数据链路层"><meta name=twitter:description content="数据链路层 地位、功能 为网络层传来的packet加头和尾（即协议），再以frame形式的PDU传送给对等层，对等层通过成帧技术得到数据。 尾：检错码
该层功能在网卡上实现（小部分在操作系统驱动实现），所以功能不宜太复杂，而且现在物理传输介质比较好，所以甚至可以不用在链路层考虑差错控制（如 物理层用光纤）。现在的网卡和主机不分离，是一体的。
提供给网络层的三类服务： （丢失 差错 乱序 重复）
无连接服务： 无确认的： eg：UDP 1）应用层需要实时性高（时延、带宽）的服务，不在意传输质量（误码率）&mdash;&mdash; 实时音视频通信；2）底层物理传输介质非常好。 比如：有线局域网（有线、近距离 &ndash;> 干扰少误码少） eg：以太网 有确认的： eg：无线系统，如 wifi &mdash;> 因为网络传输链路质量不好，所以需要确认。 1）传输正确发确认信息（ACK），用的多。 eg: TCP 2）传输错误发确认信息（NAK） 有确认的面向连接服务：1）高层需要可靠传输；2）链路不好，距离长，易误码。 eg：TCP 技术 成帧 字符填充 和 比特填充 一样，只不过适用于不同协议（以字符/比特传输）。
前三个效率都不到100%。
可能多种技术并用，如 以太网 &mdash; 第1+4种。
差错控制 错误种类：单个错误（常见），多个错误，数据包丢失
纠错 （适合易出错的信道） 前向纠错（FEC）：接收方能够检测并纠正错误，如 海明码 自动请求重传（ARQ）：适合误码率小于 10^-5^ 的信道。 检错 + 重传 （适合质量好的信道） 奇偶校验 交错校验 CRC （循环冗余校验）&mdash;- 利用二进制除法 流量控制 和 差错控制 是结合在一起的
基于反馈的流量控制 &mdash;- 6个协议，前三个：单工（一发一收）；后三个：双工 停等：一个帧，等一下。
​	太慢。尤其对带宽时延积大的，浪费信道。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"/posts/"},{"@type":"ListItem","position":3,"name":"ch3 数据链路层","item":"/posts/computer-network/ch3-%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"ch3 数据链路层","name":"ch3 数据链路层","description":"数据链路层 地位、功能 为网络层传来的packet加头和尾（即协议），再以frame形式的PDU传送给对等层，对等层通过成帧技术得到数据。 尾：检错码\n该层功能在网卡上实现（小部分在操作系统驱动实现），所以功能不宜太复杂，而且现在物理传输介质比较好，所以甚至可以不用在链路层考虑差错控制（如 物理层用光纤）。现在的网卡和主机不分离，是一体的。\n提供给网络层的三类服务： （丢失 差错 乱序 重复）\n无连接服务： 无确认的： eg：UDP 1）应用层需要实时性高（时延、带宽）的服务，不在意传输质量（误码率）\u0026mdash;\u0026mdash; 实时音视频通信；2）底层物理传输介质非常好。 比如：有线局域网（有线、近距离 \u0026ndash;\u0026gt; 干扰少误码少） eg：以太网 有确认的： eg：无线系统，如 wifi \u0026mdash;\u0026gt; 因为网络传输链路质量不好，所以需要确认。 1）传输正确发确认信息（ACK），用的多。 eg: TCP 2）传输错误发确认信息（NAK） 有确认的面向连接服务：1）高层需要可靠传输；2）链路不好，距离长，易误码。 eg：TCP 技术 成帧 字符填充 和 比特填充 一样，只不过适用于不同协议（以字符/比特传输）。\n前三个效率都不到100%。\n可能多种技术并用，如 以太网 \u0026mdash; 第1+4种。\n差错控制 错误种类：单个错误（常见），多个错误，数据包丢失\n纠错 （适合易出错的信道） 前向纠错（FEC）：接收方能够检测并纠正错误，如 海明码 自动请求重传（ARQ）：适合误码率小于 10^-5^ 的信道。 检错 + 重传 （适合质量好的信道） 奇偶校验 交错校验 CRC （循环冗余校验）\u0026mdash;- 利用二进制除法 流量控制 和 差错控制 是结合在一起的\n基于反馈的流量控制 \u0026mdash;- 6个协议，前三个：单工（一发一收）；后三个：双工 停等：一个帧，等一下。\n​\t太慢。尤其对带宽时延积大的，浪费信道。","keywords":["Computer Network"],"articleBody":"数据链路层 地位、功能 为网络层传来的packet加头和尾（即协议），再以frame形式的PDU传送给对等层，对等层通过成帧技术得到数据。 尾：检错码\n该层功能在网卡上实现（小部分在操作系统驱动实现），所以功能不宜太复杂，而且现在物理传输介质比较好，所以甚至可以不用在链路层考虑差错控制（如 物理层用光纤）。现在的网卡和主机不分离，是一体的。\n提供给网络层的三类服务： （丢失 差错 乱序 重复）\n无连接服务： 无确认的： eg：UDP 1）应用层需要实时性高（时延、带宽）的服务，不在意传输质量（误码率）—— 实时音视频通信；2）底层物理传输介质非常好。 比如：有线局域网（有线、近距离 –\u003e 干扰少误码少） eg：以太网 有确认的： eg：无线系统，如 wifi —\u003e 因为网络传输链路质量不好，所以需要确认。 1）传输正确发确认信息（ACK），用的多。 eg: TCP 2）传输错误发确认信息（NAK） 有确认的面向连接服务：1）高层需要可靠传输；2）链路不好，距离长，易误码。 eg：TCP 技术 成帧 字符填充 和 比特填充 一样，只不过适用于不同协议（以字符/比特传输）。\n前三个效率都不到100%。\n可能多种技术并用，如 以太网 — 第1+4种。\n差错控制 错误种类：单个错误（常见），多个错误，数据包丢失\n纠错 （适合易出错的信道） 前向纠错（FEC）：接收方能够检测并纠正错误，如 海明码 自动请求重传（ARQ）：适合误码率小于 10^-5^ 的信道。 检错 + 重传 （适合质量好的信道） 奇偶校验 交错校验 CRC （循环冗余校验）—- 利用二进制除法 流量控制 和 差错控制 是结合在一起的\n基于反馈的流量控制 —- 6个协议，前三个：单工（一发一收）；后三个：双工 停等：一个帧，等一下。\n​\t太慢。尤其对带宽时延积大的，浪费信道。\n滑动窗口：连发多个帧，等一下。\n基于速率的流量控制 ch3 数据链路层 数据链路层的主要功能 差错控制 - 能够检错重传或纠错 流量控制 - 使接收方能够接受所有发送方发送的数据 介质访问控制 链路管理 - 数据链路的简历、维持和释放 帧同步 - 接收方能从收到的比特流中区分帧的开始和结束 透明传输 - 把数据和控制信息分开 寻址 - 保证每一帧都能够发送到目的地 区分\n物理层带宽(Hz)\u0026数据链路层带宽(bps) ==封装成帧== 字符计数法 在帧头加一字节表示帧长度\n注意帧长度包括了帧头\n缺点是一旦帧头出错，很难查错。所以不能在有误码的信道上使用\n字符填充法 PPP协议使用\n使用控制字符ESC\n在数据段的所有ESC和FLAG前加ESC\n优点是一个错不会影响其他帧\n缺点是控制信息很多时信道利用率低，而且仅限于以byte为单位传输的数据\n比特填充法 HDLC协议使用\n开头和结尾加01111110（7E）\n在数据中连续出现五个1时在第五个1后面填充一个0\n优点是一个错不会影响其他帧，发生错误可能是 1bit出错导致一帧与两帧的转换\n物理层编码违例法 利用物理层编码的违例标识控制信息，详见物理层 - 曼彻斯特编码部分\n适合具有冗余编码的（比如：Manchester编码不会出现 high-high / low-low的情况）\n效率高，但是需要物理层配合\n==差错控制== 纠错码(ECC Error Correcting Code) 定理：\n长度不小于t+1的码可以检测t个错误 长度不小于2t+1的码可以纠t个错误 海明码 海明距离：两个码不同的位数（两个码做异或操作后1的个数）\n计算海明码：\n​\t检错码 Error Detecting Code(EDC) 奇偶校验 分为奇校验和偶校验\n可检测出奇数个位翻转错误，成功率50%\n交错校验 横着写数据码 竖着算校验码\n可以检验出连续多个错误\n多项式编码(Polynomial Code) 又叫\nCRC循环冗余校验(Cyclic Redundancy Check) FCS帧校验序列(Frame Check Sequence) M(x)是要传输的数据，在末尾加0后做被除数\nG(x)是生成多项式(Generator polynomial)，做除数\n校验位长度为生成多项式位数-1 ，数据对生成多项式进行模二除法得到余数即为校验位R(x)：M(x)*2^r^/G(x) ——\u003e 余数R(x)\n发送方：发送T(x) = M(x)*2^r^/G(x) + R(x)\n接受方：计算T(x)/G(x)，因为T(x) = M(x)*2^r^/G(x) + R(x) = M(x)*2^r^/G(x) - R(x)即被除数-余数，所以如果T(x)/G(x)为0，则正确；否则出错，即T(x)+E(x)/G(x),但当误差E(X)为G(x)的倍数时，检测不出错误。\n由于G(x)最少两位，所以出现1位错误时，E(x)除不尽G(x)，结果不为0，一定能检测出来。\nCRC总是放在数据包的尾部而不是头部，因为：\n发送方的硬件电路可以边发送边计算CRC校验和，最后追加到尾部 接收方可以便接受边计算CRC校验和，最后和尾部CRC比较 ==流量控制协议== 基本协议 乌托邦单工协议 无差错信道单工停等协议 有噪声信道单工停等协议 滑动窗口协议 1bit滑动窗口协议 GBN协议 选择重传协议 滑动窗口协议允许全双工和捎带应答(piggybacking)\n1 乌托邦单工协议(Utopian Simplex Protocol) 信道要求\n单工 无差错 不需要差错控制 数据缓冲区无穷大 不需要流量控制 一直发\n2 无差错信道单工停等协议(Simplex Stop-and-Wait) 与乌托邦协议相比 ==数据缓冲区非无穷大==\n发送帧 等待 接收方接收帧之后发送==ACK== 接收ACK 发送下一帧 3 有差错信道单工停等协议Positive ACK with Retransmission(PAR) 在协议2的基础上 ==信道不可靠==\n使用==ARQ==(Automatic Repeat request)自动重复请求\n添加==ACK序号==和==计时器==，超时未收到ACK则重发。ACK序号是为了防止“==ACK在网络中滞留，发送方超时重发==，接收方再次发送ACK，发送方接收到网络中滞留的ACK后发送下一个包，然后发送方接收到了上一个包的重发ACK后以为新的包已经送达”的问题\n4 1bit滑动窗口协议 捎带确认或单独发送ACK\n低效\n5 GBN协议(Go Back N) 窗口大小如果不特指发送窗口还是接收窗口，就表示帧序号范围0-2^n^。为了避免混淆下面都用帧序号范围来描述\n发送窗口大小大于1，小于帧序号范围最大值 接收窗口大小等于1 为什么发送窗口不能等于帧序号范围最大值？假设帧序号3位，范围0-7，假设发送窗口的窗口大小也为8，一次性把0-7这8个序号都发出去了，接收方一个接一个正确接收并发送ACK，但是ACK全部丢失，发送方超时重发，接收方发现新来的帧又是从0开始的，自己也应该接收0，就会把重发的包当做新的包；而如果发送窗口大小只是7，一次性发出去0-6，接收窗口知道自己该接收7，那么发送窗口重发就可以被接收窗口识别\n==发送方窗口大小+接收方窗口大小\u003c=帧序号范围最大值==，因为BGN协议接受窗口为1，所以发送窗口最大为2^n^-1\n6 选择重传(Selective Repeat) 只重传出错或丢失的帧， 设有重传定时器：frame-timer = 2t~prop~ + ACKTimer 设置ACK定时器，以便捎带确认时上层没有数据包也可以发送ACK 增加NAK帧，发送方只需要重发NAK+1的帧而不需要Go Back N 错误帧或不是expected帧时，发送NAK 需要记录哪个帧发送了NAK 收集齐整个接收窗口的帧后有序上交网络层 接收方buffer大小=接收方窗口数，同时还设有arrived标志数组 窗口大小相关：\n发送窗口+接收窗口不大于序号范围，即2的n次方 发送窗口和接收窗口不大于帧序号范围的一半，即2的n-1次方 发送窗口不小于接收窗口 ==通常两个窗口取值都是2的n-1次方== 协议总结 重传用的都是ARQ，没有前向纠错\n协议 信道条件 n是序号长度 传输模式 确认帧 Timer 序号 buffer window 1 完美 一直发 / / / / / 2 接收方缓冲区有限 停等 + 接收方ACK(NAK) / / / / 3 协议二+信道不可靠 停等+ARQ 接收方有 + frame-timer + ACK序号 / / 4 停等+ARQ 接收方有 frame-timer + frame序号、ACK序号 sender-buffer（1帧大小即可） 1：1 5 + 累积ACK frame-timer ACK序号、frame序号 多：1 6 + NAK +ACK-timer，frame-timer 多：多 效率计算 （U \u003c= 1）==(kybk)== 停等协议：采用ACK确认，忽略ACK的长度（发送时延）；忽略节点处理时延\n无差错： 信道利用率U = nt~tran~/[n(t~tran~+2t~prop~)] = t~tran~/(t~tran~+2t~prop~) = 1/(1+2t~prop~/t~tran~) = 1/(1+2*α) 其中 α = t~prop~/t~tran~\n有差错：错误率p (考试基本没有，但要知道) 成功发送一帧，平均需要发送N~r~ = $\\sum_{i=1}^∞ip^{i-1}(1-p)$ = 1/(1-p)\n信道利用率U = t~tran~/[N~r~(t~tran~+2t~prop~)] = (1-p)/(1+2α)\n​\t其中 α = t~prop~/t~tran~\n滑动窗口协议：\n无差错（一般无差错，不考虑有差错情况）：==Normalize the transmission time to 1, and the propagation time is α==\nTherefore we can express the utilization： ，w是==发送==窗口数\nα 越大，即传输时延越长，效率越低。 α小：有线以太网；α大：卫星，需要的w大。\n捎带确认：\n回来的ack帧也要考虑发送时延，所以 U = W / (==2==+2α) = W / 2(α+1)\n典型协议–HDLC、PPP 两者都是点到点链路的协议\nHDLC(High-Level Data Link Control) 用于 路由器 之间\n串行：一般内部并行传输，外部串行传输。串行链路普遍用于WAN中。\n串行链路中定义了两种数据传输方式： 同步：将多个字节封装成帧传输，以帧（not byte）为单位。面向bit，所以采用 ==零比特填充==\t异步：以字节为单位。\nHDLC站类型：主站 从站 混合站\nPPP PPP帧格式：\n面向字节（符）的协议 字符填充 CRC校验 协议对比 PPP HDLC Point-point link Multiple configurations（一个主站：多个从站 or 多：多） Byte oriented (Byte stuffing) Bit oriented (bit stuffing) Connectionless unacknowledged service Reliable connection-oriented service 路由器间 or 用户到端局（拨号上网） 只有路由器间（PPP 是设计用于调制解调器的） 补充 SLIP SLIP（串行线IP）：Used to connect to a remote server；Framing: ==Byte Stuffing 字节填充==。 Problems： Ø ==No error control== Ø ==Only support IP== Ø Don’t assign IP address dynamically Ø No authentication Ø Different version exist\n现在基本不用，都用PPP\n","wordCount":"469","inLanguage":"en","datePublished":"2023-02-21T16:29:43Z","dateModified":"2023-02-21T16:29:43Z","author":{"@type":"Person","name":"Chan"},"mainEntityOfPage":{"@type":"WebPage","@id":"/posts/computer-network/ch3-%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/"},"publisher":{"@type":"Organization","name":"Home","logo":{"@type":"ImageObject","url":"%3Clink%20/%20abs%20url%3E"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href accesskey=h title="Cheyne16's Blog (Alt + H)"><img src=/apple-touch-icon.png alt aria-label=logo height=35>Cheyne16's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=/categories/ title=categories><span>categories</span></a></li><li><a href=/tags/ title=tags><span>tags</span></a></li><li><a href=https://example.org title=example.org><span>example.org</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href>Home</a>&nbsp;»&nbsp;<a href=/posts/>Posts</a></div><h1 class=post-title>ch3 数据链路层</h1><div class=post-meta><span title='2023-02-21 16:29:43 +0000 UTC'>February 21, 2023</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;469 words&nbsp;·&nbsp;Chan&nbsp;|&nbsp;<a href=https://github.com/%3cpath_to_repo%3e/content/posts/Computer%20Network/ch3%20%e6%95%b0%e6%8d%ae%e9%93%be%e8%b7%af%e5%b1%82.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=post-content><h1 id=数据链路层>数据链路层<a hidden class=anchor aria-hidden=true href=#数据链路层>#</a></h1><h2 id=地位功能>地位、功能<a hidden class=anchor aria-hidden=true href=#地位功能>#</a></h2><ul><li><p>为网络层传来的<strong>packet</strong>加<strong>头和尾（即协议）</strong>，再以<strong>frame</strong>形式的PDU传送给对等层，对等层通过<strong>成帧技术</strong>得到数据。 尾：检错码</p></li><li><p>该层功能在<strong>网卡</strong>上实现（小部分在操作系统驱动实现），所以功能不宜太复杂，而且现在物理传输介质比较好，所以甚至可以不用在链路层考虑差错控制（如 物理层用光纤）。现在的网卡和主机不分离，是一体的。</p></li><li><p>提供给网络层的三类服务： <strong>（丢失 差错 乱序 重复）</strong></p><ul><li>无连接服务：<ul><li>无确认的： eg：<strong>UDP</strong>
1）应用层需要实时性高（<strong>时延</strong>、带宽）的服务，不在意传输质量（<strong>误码率</strong>）&mdash;&mdash; <strong>实时音视频通信</strong>；2）底层物理传输介质非常好。 比如：有线局域网（有线、近距离 &ndash;> 干扰少误码少） eg：<strong>以太网</strong></li><li>有确认的： eg：无线系统，如 <strong>wifi</strong> &mdash;> 因为网络传输链路质量不好，所以需要确认。
1）传输正确发确认信息（ACK），用的多。 eg: TCP
2）传输错误发确认信息（NAK）</li></ul></li><li>有确认的面向连接服务：1）高层需要可靠传输；2）链路不好，距离长，易误码。 eg：<strong>TCP</strong></li></ul></li></ul><h2 id=技术>技术<a hidden class=anchor aria-hidden=true href=#技术>#</a></h2><h3 id=成帧>成帧<a hidden class=anchor aria-hidden=true href=#成帧>#</a></h3><p><img loading=lazy src=https://raw.githubusercontent.com/Cheyne16/ImageHub/main/gitee/img/20210329192418.png alt=image-20210329192418221></p><p>字符填充 和 比特填充 一样，只不过适用于不同协议（以字符/比特传输）。</p><p>前三个效率都不到100%。</p><p>可能多种技术并用，如 以太网 &mdash; 第1+4种。</p><h3 id=差错控制>差错控制<a hidden class=anchor aria-hidden=true href=#差错控制>#</a></h3><p>错误种类：单个错误（常见），多个错误，数据包丢失</p><ul><li><strong>纠错</strong> （适合易出错的信道）<ul><li>前向纠错（FEC）：接收方能够检测并纠正错误，如 <strong>海明码</strong></li><li>自动请求重传（ARQ）：适合误码率小于 10^-5^ 的信道。</li></ul></li><li><strong>检错</strong> + 重传 （适合质量好的信道）<ul><li>奇偶校验</li><li>交错校验</li><li>CRC （循环冗余校验）&mdash;- 利用二进制除法</li></ul></li></ul><h3 id=流量控制>流量控制<a hidden class=anchor aria-hidden=true href=#流量控制>#</a></h3><p>和 <strong>差错控制</strong> 是结合在一起的</p><ul><li><strong>基于反馈的流量控制</strong> &mdash;- 6个协议，前三个：单工（一发一收）；后三个：双工<ul><li><p>停等：一个帧，等一下。</p><p>​ 太慢。尤其对带宽时延积大的，浪费信道。</p></li><li><p>滑动窗口：连发多个帧，等一下。</p></li></ul></li><li><strong>基于速率的流量控制</strong></li></ul><h1 id=ch3-数据链路层>ch3 数据链路层<a hidden class=anchor aria-hidden=true href=#ch3-数据链路层>#</a></h1><p><img loading=lazy src=https://raw.githubusercontent.com/Cheyne16/ImageHub/main/gitee/img/20210408202540.png alt=image-20210408202540283></p><h2 id=数据链路层的主要功能>数据链路层的主要功能<a hidden class=anchor aria-hidden=true href=#数据链路层的主要功能>#</a></h2><ul><li><strong>差错控制</strong> - 能够检错重传或纠错</li><li><strong>流量控制</strong> - 使接收方能够接受所有发送方发送的数据</li><li><strong>介质访问控制</strong></li><li>链路管理 - 数据链路的简历、维持和释放</li><li>帧同步 - 接收方能从收到的比特流中区分帧的开始和结束</li><li>透明传输 - 把数据和控制信息分开</li><li>寻址 - 保证每一帧都能够发送到目的地</li></ul><p><strong>区分</strong></p><ul><li>物理层带宽(Hz)&数据链路层带宽(bps)</li></ul><h2 id=封装成帧>==封装成帧==<a hidden class=anchor aria-hidden=true href=#封装成帧>#</a></h2><h3 id=字符计数法>字符计数法<a hidden class=anchor aria-hidden=true href=#字符计数法>#</a></h3><p>在帧头加一字节表示帧长度</p><p><strong>注意帧长度包括了帧头</strong></p><p><img loading=lazy src=https://discretetom.github.io/_nuxt/img/2cc06c5.png alt=3-1></p><p>缺点是一旦帧头出错，很难查错。所以<strong>不能在有误码的信道上使用</strong></p><h3 id=字符填充法>字符填充法<a hidden class=anchor aria-hidden=true href=#字符填充法>#</a></h3><p>PPP协议使用</p><p>使用控制字符ESC</p><p>在<strong>数据段的</strong>所有ESC和FLAG前加ESC</p><p><img loading=lazy src=https://discretetom.github.io/_nuxt/img/112bf6f.png alt=3-2></p><p>优点是一个错不会影响其他帧</p><p>缺点是控制信息很多时信道利用率低，而且仅限于以byte为单位传输的数据</p><h3 id=比特填充法>比特填充法<a hidden class=anchor aria-hidden=true href=#比特填充法>#</a></h3><p>HDLC协议使用</p><p>开头和结尾加01111110（7E）</p><p>在数据中连续出现五个1时在第五个1后面填充一个0</p><p><img loading=lazy src=https://discretetom.github.io/_nuxt/img/6627cb5.png alt=3-3></p><p>优点是一个错不会影响其他帧，发生错误可能是 1bit出错导致一帧与两帧的转换</p><h3 id=物理层编码违例法>物理层编码违例法<a hidden class=anchor aria-hidden=true href=#物理层编码违例法>#</a></h3><p>利用物理层编码的违例标识控制信息，详见物理层 - 曼彻斯特编码部分</p><p>适合具有冗余编码的（比如：Manchester编码不会出现 high-high / low-low的情况）</p><p>效率高，但是需要物理层配合</p><h2 id=差错控制-1>==差错控制==<a hidden class=anchor aria-hidden=true href=#差错控制-1>#</a></h2><h3 id=纠错码ecc-error-correcting-code>纠错码(ECC Error Correcting Code)<a hidden class=anchor aria-hidden=true href=#纠错码ecc-error-correcting-code>#</a></h3><p>定理：</p><ul><li>长度不小于t+1的码可以检测t个错误</li><li>长度不小于2t+1的码可以纠t个错误</li></ul><h4 id=海明码>海明码<a hidden class=anchor aria-hidden=true href=#海明码>#</a></h4><p>海明距离：两个码不同的位数（两个码做异或操作后1的个数）</p><p>计算海明码：</p><p>​ <img loading=lazy src=https://raw.githubusercontent.com/Cheyne16/ImageHub/main/gitee/img/20210409165554.png alt=image-20210409165554286></p><h3 id=检错码-error-detecting-codeedc>检错码 Error Detecting Code(EDC)<a hidden class=anchor aria-hidden=true href=#检错码-error-detecting-codeedc>#</a></h3><h4 id=奇偶校验>奇偶校验<a hidden class=anchor aria-hidden=true href=#奇偶校验>#</a></h4><p>分为奇校验和偶校验</p><p>可检测出<strong>奇数个</strong>位翻转错误，成功率50%</p><h4 id=交错校验>交错校验<a hidden class=anchor aria-hidden=true href=#交错校验>#</a></h4><p>横着写数据码 竖着算校验码</p><p><img loading=lazy src=https://discretetom.github.io/_nuxt/img/870a68c.png alt=3-5></p><p>可以检验出连续多个错误</p><h4 id=多项式编码polynomial-code>多项式编码(Polynomial Code)<a hidden class=anchor aria-hidden=true href=#多项式编码polynomial-code>#</a></h4><p>又叫</p><ul><li>CRC循环冗余校验(Cyclic Redundancy Check)</li><li>FCS帧校验序列(Frame Check Sequence)</li></ul><p>M(x)是要传输的数据，<strong>在末尾加0后</strong>做被除数</p><p>G(x)是生成多项式(Generator polynomial)，做除数</p><p>校验位长度为生成多项式<strong>位数</strong>-1 ，数据对生成多项式进行<strong>模二除法</strong>得到余数即为校验位R(x)：M(x)*2^r^/G(x) ——> 余数R(x)</p><p><img loading=lazy src=https://raw.githubusercontent.com/Cheyne16/ImageHub/main/gitee/img/20210409171226.png alt=image-20210409171226181></p><p>发送方：发送T(x) = M(x)*2^r^/G(x) + R(x)</p><p>接受方：计算T(x)/G(x)，因为T(x) = M(x)*2^r^/G(x) + R(x) = M(x)*2^r^/G(x) - R(x)即被除数-余数，所以如果T(x)/G(x)为0，则正确；否则出错，即T(x)+E(x)/G(x),但当误差E(X)为G(x)的倍数时，检测不出错误。</p><p>由于G(x)最少两位，所以出现1位错误时，E(x)除不尽G(x)，结果不为0，一定能检测出来。</p><p>CRC总是放在数据包的<strong>尾部</strong>而不是头部，因为：</p><ul><li>发送方的硬件电路可以边发送边计算CRC校验和，最后追加到尾部</li><li>接收方可以便接受边计算CRC校验和，最后和尾部CRC比较</li></ul><h2 id=流量控制协议>==流量控制协议==<a hidden class=anchor aria-hidden=true href=#流量控制协议>#</a></h2><ul><li>基本协议<ul><li>乌托邦单工协议</li><li>无差错信道单工停等协议</li><li>有噪声信道单工停等协议</li></ul></li><li>滑动窗口协议<ul><li>1bit滑动窗口协议</li><li>GBN协议</li><li>选择重传协议</li></ul></li></ul><p>滑动窗口协议允许<strong>全双工</strong>和<strong>捎带应答(piggybacking)</strong></p><h3 id=1-乌托邦单工协议utopian-simplex-protocol>1 乌托邦单工协议(Utopian Simplex Protocol)<a hidden class=anchor aria-hidden=true href=#1-乌托邦单工协议utopian-simplex-protocol>#</a></h3><p>信道要求</p><ul><li>单工</li><li>无差错 不需要差错控制</li><li>数据缓冲区无穷大 不需要流量控制</li></ul><p>一直发</p><h3 id=2-无差错信道单工停等协议simplex-stop-and-wait>2 无差错信道单工停等协议(Simplex Stop-and-Wait)<a hidden class=anchor aria-hidden=true href=#2-无差错信道单工停等协议simplex-stop-and-wait>#</a></h3><p>与乌托邦协议相比 ==数据缓冲区非无穷大==</p><ul><li>发送帧 等待</li><li>接收方接收帧之后发送==ACK==</li><li>接收ACK 发送下一帧</li></ul><h3 id=3-有差错信道单工停等协议positive-ack-with-retransmissionpar>3 有差错信道单工停等协议Positive ACK with Retransmission(PAR)<a hidden class=anchor aria-hidden=true href=#3-有差错信道单工停等协议positive-ack-with-retransmissionpar>#</a></h3><p>在协议2的基础上 ==信道不可靠==</p><p>使用==ARQ==(Automatic Repeat request)自动重复请求</p><p>添加==ACK序号==和==计时器==，超时未收到ACK则重发。ACK序号是为了防止“==ACK在网络中滞留，发送方超时重发==，接收方再次发送ACK，发送方接收到网络中滞留的ACK后发送下一个包，然后发送方接收到了上一个包的重发ACK后以为新的包已经送达”的问题</p><h3 id=4-1bit滑动窗口协议>4 1bit滑动窗口协议<a hidden class=anchor aria-hidden=true href=#4-1bit滑动窗口协议>#</a></h3><p>捎带确认或单独发送ACK</p><p>低效</p><h3 id=5-gbn协议go-back-n>5 GBN协议(Go Back N)<a hidden class=anchor aria-hidden=true href=#5-gbn协议go-back-n>#</a></h3><p><strong>窗口大小</strong>如果不特指发送窗口还是接收窗口，就表示<strong>帧序号范围0-2^n^</strong>。为了避免混淆下面都用帧序号范围来描述</p><ul><li>发送窗口大小<strong>大于</strong>1，<strong>小于</strong>帧序号范围最大值</li><li>接收窗口大小<strong>等于</strong>1</li></ul><p>为什么发送窗口不能等于帧序号范围最大值？假设帧序号3位，范围0-7，假设发送窗口的窗口大小也为8，一次性把0-7这8个序号都发出去了，接收方一个接一个正确接收并发送ACK，但是ACK全部丢失，发送方超时重发，接收方发现新来的帧又是从0开始的，自己也应该接收0，就会把重发的包当做新的包；而如果发送窗口大小只是7，一次性发出去0-6，接收窗口知道自己该接收7，那么发送窗口重发就可以被接收窗口识别</p><p>==发送方窗口大小+接收方窗口大小&lt;=帧序号范围最大值==，因为BGN协议接受窗口为1，所以发送窗口最大为2^n^-1</p><h3 id=6-选择重传selective-repeat>6 选择重传(Selective Repeat)<a hidden class=anchor aria-hidden=true href=#6-选择重传selective-repeat>#</a></h3><ul><li><strong>只重传出错或丢失的帧</strong>，</li><li>设有重传定时器：frame-timer = 2t~prop~ + ACKTimer</li><li>设置ACK定时器，以便捎带确认时上层没有数据包也可以发送ACK</li><li>增加NAK帧，发送方只需要重发NAK+1的帧而不需要Go Back N<ul><li>错误帧或不是expected帧时，发送NAK</li><li>需要记录哪个帧发送了NAK</li></ul></li><li>收集齐整个接收窗口的帧后<strong>有序</strong>上交网络层</li><li>接收方buffer大小=接收方窗口数，同时还设有arrived标志数组</li></ul><p>窗口大小相关：</p><ul><li>发送窗口+接收窗口不大于序号范围，即2的n次方</li><li>发送窗口和接收窗口不大于帧序号范围的一半，即2的n-1次方</li><li>发送窗口不小于接收窗口</li><li>==通常两个窗口取值都是2的n-1次方==</li></ul><h3 id=协议总结>协议总结<a hidden class=anchor aria-hidden=true href=#协议总结>#</a></h3><p>重传用的都是ARQ，没有前向纠错</p><table><thead><tr><th>协议</th><th>信道条件</th><th>n是序号长度</th><th>传输模式</th><th>确认帧</th><th>Timer</th><th>序号</th><th>buffer</th><th>window</th></tr></thead><tbody><tr><td>1</td><td>完美</td><td></td><td>一直发</td><td>/</td><td>/</td><td>/</td><td>/</td><td>/</td></tr><tr><td>2</td><td>接收方缓冲区有限</td><td></td><td>停等</td><td>+ 接收方ACK(NAK)</td><td>/</td><td>/</td><td>/</td><td>/</td></tr><tr><td>3</td><td>协议二+信道不可靠</td><td></td><td>停等+ARQ</td><td>接收方有</td><td>+ frame-timer</td><td>+ ACK序号</td><td>/</td><td>/</td></tr><tr><td>4</td><td></td><td></td><td>停等+ARQ</td><td>接收方有</td><td>frame-timer</td><td>+ frame序号、ACK序号</td><td>sender-buffer（1帧大小即可）</td><td>1：1</td></tr><tr><td>5</td><td></td><td></td><td></td><td>+ 累积ACK</td><td>frame-timer</td><td>ACK序号、frame序号</td><td></td><td>多：1</td></tr><tr><td>6</td><td></td><td></td><td></td><td>+ NAK</td><td>+ACK-timer，frame-timer</td><td></td><td></td><td>多：多</td></tr></tbody></table><h3 id=效率计算-u--1kybk>效率计算 （U &lt;= 1）==(kybk)==<a hidden class=anchor aria-hidden=true href=#效率计算-u--1kybk>#</a></h3><p><strong>停等协议</strong>：采用ACK确认，忽略<strong>ACK的长度（发送时延）；忽略节点处理时延</strong></p><ul><li>无差错：</li></ul><p>信道利用率U = n<em>t~tran~/[n</em>(t~tran~+2t~prop~)] = <em>t~tran~/</em>(t~tran~+2<em>t~prop~) = 1/(1+2</em>t~prop~/t~tran~) = 1/(1+2*α)
其中 α = t~prop~/t~tran~</p><ul><li>有差错：错误率p (考试基本没有，但要知道)</li></ul><p>成功发送一帧，平均需要发送N~r~ = $\sum_{i=1}^∞ip^{i-1}(1-p)$ = 1/(1-p)</p><p>信道利用率U = t~tran~/[N~r~<em>(t~tran~+2t~prop~)] = (1-p)/(1+2</em>α)</p><p>​ 其中 α = t~prop~/t~tran~</p><p><strong>滑动窗口协议</strong>：</p><ul><li><p>无差错（一般无差错，不考虑有差错情况）：==Normalize the transmission time to 1, and the propagation time is α==</p><p>Therefore we can express the utilization：<img loading=lazy src=https://raw.githubusercontent.com/Cheyne16/ImageHub/main/gitee/img/20210410142946.png alt=image-20210410142939596>
，w是==发送==窗口数</p><p>α 越大，即传输时延越长，效率越低。 α小：有线以太网；α大：卫星，需要的w大。</p></li><li><p>捎带确认：</p><p>回来的ack帧也要考虑发送时延，所以 U = W / (==2==+2α) = W / 2(α+1)</p></li></ul><h2 id=典型协议--hdlcppp>典型协议&ndash;HDLC、PPP<a hidden class=anchor aria-hidden=true href=#典型协议--hdlcppp>#</a></h2><p>两者都是<strong>点到点链路</strong>的协议</p><p><img loading=lazy src=https://raw.githubusercontent.com/Cheyne16/ImageHub/main/gitee/img/20210410150733.png alt=image-20210410150733348></p><h3 id=hdlchigh-level-data-link-control>HDLC(High-Level Data Link Control)<a hidden class=anchor aria-hidden=true href=#hdlchigh-level-data-link-control>#</a></h3><p><img loading=lazy src=https://raw.githubusercontent.com/Cheyne16/ImageHub/main/gitee/img/20210410150919.png alt=image-20210410150919525></p><p>用于 路由器 之间</p><p>串行：一般内部并行传输，外部串行传输。串行链路普遍用于WAN中。</p><p>串行链路中定义了两种数据传输方式：
同步：将多个字节封装成帧传输，以帧（not byte）为单位。面向bit，所以采用 ==零比特填充==
异步：以字节为单位。</p><p>HDLC站类型：主站 从站 混合站</p><h3 id=ppp>PPP<a hidden class=anchor aria-hidden=true href=#ppp>#</a></h3><p><img loading=lazy src=https://raw.githubusercontent.com/Cheyne16/ImageHub/main/gitee/img/20210410155729.png alt=image-20210410155729839></p><p><img loading=lazy src=https://raw.githubusercontent.com/Cheyne16/ImageHub/main/gitee/img/20210410155828.png alt=image-20210410155828784></p><p>PPP帧格式：</p><ul><li>面向字节（符）的协议</li><li>字符填充</li><li>CRC校验</li></ul><h3 id=协议对比>协议对比<a hidden class=anchor aria-hidden=true href=#协议对比>#</a></h3><table><thead><tr><th></th><th>PPP</th><th>HDLC</th></tr></thead><tbody><tr><td></td><td>Point-point link</td><td>Multiple configurations（一个主站：多个从站 or 多：多）</td></tr><tr><td></td><td>Byte oriented (Byte stuffing)</td><td>Bit oriented (bit stuffing)</td></tr><tr><td></td><td>Connectionless unacknowledged service</td><td>Reliable connection-oriented service</td></tr><tr><td></td><td>路由器间 or 用户到端局（拨号上网）</td><td>只有路由器间（PPP 是设计用于调制解调器的）</td></tr><tr><td></td><td></td><td></td></tr></tbody></table><h3 id=补充-slip>补充 SLIP<a hidden class=anchor aria-hidden=true href=#补充-slip>#</a></h3><p><img loading=lazy src=https://raw.githubusercontent.com/Cheyne16/ImageHub/main/gitee/img/20210410154925.png alt=image-20210410154925168></p><p>SLIP（串行线IP）：Used to connect to a remote server；Framing: ==Byte Stuffing 字节填充==。
Problems：
Ø ==No error control==
Ø ==Only support IP==
Ø Don’t assign IP address dynamically
Ø No authentication
Ø Different version exist</p><p>现在基本不用，都用PPP</p></div><footer class=post-footer><ul class=post-tags><li><a href=/tags/computer-network/>Computer Network</a></li></ul><nav class=paginav><a class=prev href=/posts/formal-languages-and-automata/ch2-%E8%AF%AD%E8%A8%80%E5%8F%8A%E6%96%87%E6%B3%95/><span class=title>« Prev</span><br><span>ch2-语言及文法</span></a>
<a class=next href=/posts/formal-languages-and-automata/ch3-%E6%9C%89%E9%99%90%E8%87%AA%E5%8A%A8%E6%9C%BA%E5%92%8C%E5%8F%B3%E7%BA%BF%E6%80%A7%E6%96%87%E6%B3%95/><span class=title>Next »</span><br><span>ch3-有限自动机和右线性文法</span></a></nav><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share ch3 数据链路层 on twitter" href="https://twitter.com/intent/tweet/?text=ch3%20%e6%95%b0%e6%8d%ae%e9%93%be%e8%b7%af%e5%b1%82&url=%2fposts%2fcomputer-network%2fch3-%25E6%2595%25B0%25E6%258D%25AE%25E9%2593%25BE%25E8%25B7%25AF%25E5%25B1%2582%2f&hashtags=ComputerNetwork"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share ch3 数据链路层 on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=%2fposts%2fcomputer-network%2fch3-%25E6%2595%25B0%25E6%258D%25AE%25E9%2593%25BE%25E8%25B7%25AF%25E5%25B1%2582%2f&title=ch3%20%e6%95%b0%e6%8d%ae%e9%93%be%e8%b7%af%e5%b1%82&summary=ch3%20%e6%95%b0%e6%8d%ae%e9%93%be%e8%b7%af%e5%b1%82&source=%2fposts%2fcomputer-network%2fch3-%25E6%2595%25B0%25E6%258D%25AE%25E9%2593%25BE%25E8%25B7%25AF%25E5%25B1%2582%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share ch3 数据链路层 on reddit" href="https://reddit.com/submit?url=%2fposts%2fcomputer-network%2fch3-%25E6%2595%25B0%25E6%258D%25AE%25E9%2593%25BE%25E8%25B7%25AF%25E5%25B1%2582%2f&title=ch3%20%e6%95%b0%e6%8d%ae%e9%93%be%e8%b7%af%e5%b1%82"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share ch3 数据链路层 on facebook" href="https://facebook.com/sharer/sharer.php?u=%2fposts%2fcomputer-network%2fch3-%25E6%2595%25B0%25E6%258D%25AE%25E9%2593%25BE%25E8%25B7%25AF%25E5%25B1%2582%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share ch3 数据链路层 on whatsapp" href="https://api.whatsapp.com/send?text=ch3%20%e6%95%b0%e6%8d%ae%e9%93%be%e8%b7%af%e5%b1%82%20-%20%2fposts%2fcomputer-network%2fch3-%25E6%2595%25B0%25E6%258D%25AE%25E9%2593%25BE%25E8%25B7%25AF%25E5%25B1%2582%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share ch3 数据链路层 on telegram" href="https://telegram.me/share/url?text=ch3%20%e6%95%b0%e6%8d%ae%e9%93%be%e8%b7%af%e5%b1%82&url=%2fposts%2fcomputer-network%2fch3-%25E6%2595%25B0%25E6%258D%25AE%25E9%2593%25BE%25E8%25B7%25AF%25E5%25B1%2582%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></div></footer></article></main><footer class=footer><span>&copy; 2023 <a href>Home</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>