<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>ch4-语法分析 | Home</title><meta name=keywords content="Principles of Compiler"><meta name=description content="4.1 语法分析简介 编译程序的核心工作。
语法分析程序的任务：
从源程序记号序列中识别出各类语法成分 进行语法检查 语法分析程序的地位：
由语法分析程序完成：
输入：语义分析出的记号流/序列 工作依据：源语言的语法规则 功能任务：从记号流中识别出各类语法成分、进行语法检查 输出：分析树 错误处理 常用的分析方法：
自顶向下 自底向上 对输入符号串的扫描顺序：自左向右
4.2 自顶向下分析方法 1. 递归下降分析 依次试探、谋求匹配。
试图为输入符号串建立一个==最左推导序列==。
实践中存在的困难和缺点：
左递归的文法，可能导致分析过程陷入死循环 ==回溯== 工作的重复 效率低、代价高：穷尽一切可能的试探法。 2. 递归调用预测分析 一种确定的、==不带回溯==的递归下降分析方法——能够根据所面临的输入符号准确地指派一个候选式去执行任务。
对文法的要求：
不含左递归
非终结符号的所有候选式的FIRST集两两互不相交
2.1 预测分析程序的构造 改写文法：重写文法、消除左递归、提取左公因子
（1）预测分析程序的转换图 为每个非终结符号创建一个转换图，每个候选式对应一条路径：
（2）转换图的工作过程 从文法开始符号所对应的转换图的开始状态开始分析，经过若干动作，向前分析，直到错误或到达结束状态。
（3）转换图的化简 用代入的方法进行化简：合并减去重复的边和状态，将简化后的代入其他里面化简
（4）预测分析程序的实现 要求用来描述预测分析程序的语言允许递归调用。
实现举例：
3. 非递归预测分析 使用一张分析表和一个栈联合控制，实现对输入符号串的自顶向下分析。
3.1 预测分析程序的模型及工作过程 算法4.1 非递归预测分析方法 3.2 预测分析表的构造 （1）改写文法 （2）FIRST集合及其构造 推导出的开头终结符号集
（3）FOLLOW集合及其构造 后面紧跟的终结符号集
（4）算法4.2 预测分析表的构造 3.2 LL(1)文法 如果一个文法的预测分析表M不含多重定义的表项， 则称该文法为LL(1)文法。
LL(1)的含义：
第一个L表示从左至右扫描输入符号串 第二个L表示生成输入串的一个最左推导 1表示在决定分析程序的每步动作时，向前看一个符号 3."><meta name=author content="Chan"><link rel=canonical href=/posts/principles-of-compiler/ch4-%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.6a98292fb8fa8cf0f3ba4042d4b75515c04267550f3ad49ff6271b5af9562443.css integrity="sha256-apgpL7j6jPDzukBC1LdVFcBCZ1UPOtSf9icbWvlWJEM=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-123-45","auto"),ga("send","pageview"))</script><meta property="og:title" content="ch4-语法分析"><meta property="og:description" content="4.1 语法分析简介 编译程序的核心工作。
语法分析程序的任务：
从源程序记号序列中识别出各类语法成分 进行语法检查 语法分析程序的地位：
由语法分析程序完成：
输入：语义分析出的记号流/序列 工作依据：源语言的语法规则 功能任务：从记号流中识别出各类语法成分、进行语法检查 输出：分析树 错误处理 常用的分析方法：
自顶向下 自底向上 对输入符号串的扫描顺序：自左向右
4.2 自顶向下分析方法 1. 递归下降分析 依次试探、谋求匹配。
试图为输入符号串建立一个==最左推导序列==。
实践中存在的困难和缺点：
左递归的文法，可能导致分析过程陷入死循环 ==回溯== 工作的重复 效率低、代价高：穷尽一切可能的试探法。 2. 递归调用预测分析 一种确定的、==不带回溯==的递归下降分析方法——能够根据所面临的输入符号准确地指派一个候选式去执行任务。
对文法的要求：
不含左递归
非终结符号的所有候选式的FIRST集两两互不相交
2.1 预测分析程序的构造 改写文法：重写文法、消除左递归、提取左公因子
（1）预测分析程序的转换图 为每个非终结符号创建一个转换图，每个候选式对应一条路径：
（2）转换图的工作过程 从文法开始符号所对应的转换图的开始状态开始分析，经过若干动作，向前分析，直到错误或到达结束状态。
（3）转换图的化简 用代入的方法进行化简：合并减去重复的边和状态，将简化后的代入其他里面化简
（4）预测分析程序的实现 要求用来描述预测分析程序的语言允许递归调用。
实现举例：
3. 非递归预测分析 使用一张分析表和一个栈联合控制，实现对输入符号串的自顶向下分析。
3.1 预测分析程序的模型及工作过程 算法4.1 非递归预测分析方法 3.2 预测分析表的构造 （1）改写文法 （2）FIRST集合及其构造 推导出的开头终结符号集
（3）FOLLOW集合及其构造 后面紧跟的终结符号集
（4）算法4.2 预测分析表的构造 3.2 LL(1)文法 如果一个文法的预测分析表M不含多重定义的表项， 则称该文法为LL(1)文法。
LL(1)的含义：
第一个L表示从左至右扫描输入符号串 第二个L表示生成输入串的一个最左推导 1表示在决定分析程序的每步动作时，向前看一个符号 3."><meta property="og:type" content="article"><meta property="og:url" content="/posts/principles-of-compiler/ch4-%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90/"><meta property="og:image" content="%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-02-21T16:29:43+00:00"><meta property="article:modified_time" content="2023-02-21T16:29:43+00:00"><meta property="og:site_name" content="Chancellor16's Blog"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="ch4-语法分析"><meta name=twitter:description content="4.1 语法分析简介 编译程序的核心工作。
语法分析程序的任务：
从源程序记号序列中识别出各类语法成分 进行语法检查 语法分析程序的地位：
由语法分析程序完成：
输入：语义分析出的记号流/序列 工作依据：源语言的语法规则 功能任务：从记号流中识别出各类语法成分、进行语法检查 输出：分析树 错误处理 常用的分析方法：
自顶向下 自底向上 对输入符号串的扫描顺序：自左向右
4.2 自顶向下分析方法 1. 递归下降分析 依次试探、谋求匹配。
试图为输入符号串建立一个==最左推导序列==。
实践中存在的困难和缺点：
左递归的文法，可能导致分析过程陷入死循环 ==回溯== 工作的重复 效率低、代价高：穷尽一切可能的试探法。 2. 递归调用预测分析 一种确定的、==不带回溯==的递归下降分析方法——能够根据所面临的输入符号准确地指派一个候选式去执行任务。
对文法的要求：
不含左递归
非终结符号的所有候选式的FIRST集两两互不相交
2.1 预测分析程序的构造 改写文法：重写文法、消除左递归、提取左公因子
（1）预测分析程序的转换图 为每个非终结符号创建一个转换图，每个候选式对应一条路径：
（2）转换图的工作过程 从文法开始符号所对应的转换图的开始状态开始分析，经过若干动作，向前分析，直到错误或到达结束状态。
（3）转换图的化简 用代入的方法进行化简：合并减去重复的边和状态，将简化后的代入其他里面化简
（4）预测分析程序的实现 要求用来描述预测分析程序的语言允许递归调用。
实现举例：
3. 非递归预测分析 使用一张分析表和一个栈联合控制，实现对输入符号串的自顶向下分析。
3.1 预测分析程序的模型及工作过程 算法4.1 非递归预测分析方法 3.2 预测分析表的构造 （1）改写文法 （2）FIRST集合及其构造 推导出的开头终结符号集
（3）FOLLOW集合及其构造 后面紧跟的终结符号集
（4）算法4.2 预测分析表的构造 3.2 LL(1)文法 如果一个文法的预测分析表M不含多重定义的表项， 则称该文法为LL(1)文法。
LL(1)的含义：
第一个L表示从左至右扫描输入符号串 第二个L表示生成输入串的一个最左推导 1表示在决定分析程序的每步动作时，向前看一个符号 3."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"/posts/"},{"@type":"ListItem","position":3,"name":"ch4-语法分析","item":"/posts/principles-of-compiler/ch4-%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"ch4-语法分析","name":"ch4-语法分析","description":"4.1 语法分析简介 编译程序的核心工作。\n语法分析程序的任务：\n从源程序记号序列中识别出各类语法成分 进行语法检查 语法分析程序的地位：\n由语法分析程序完成：\n输入：语义分析出的记号流/序列 工作依据：源语言的语法规则 功能任务：从记号流中识别出各类语法成分、进行语法检查 输出：分析树 错误处理 常用的分析方法：\n自顶向下 自底向上 对输入符号串的扫描顺序：自左向右\n4.2 自顶向下分析方法 1. 递归下降分析 依次试探、谋求匹配。\n试图为输入符号串建立一个==最左推导序列==。\n实践中存在的困难和缺点：\n左递归的文法，可能导致分析过程陷入死循环 ==回溯== 工作的重复 效率低、代价高：穷尽一切可能的试探法。 2. 递归调用预测分析 一种确定的、==不带回溯==的递归下降分析方法——能够根据所面临的输入符号准确地指派一个候选式去执行任务。\n对文法的要求：\n不含左递归\n非终结符号的所有候选式的FIRST集两两互不相交\n2.1 预测分析程序的构造 改写文法：重写文法、消除左递归、提取左公因子\n（1）预测分析程序的转换图 为每个非终结符号创建一个转换图，每个候选式对应一条路径：\n（2）转换图的工作过程 从文法开始符号所对应的转换图的开始状态开始分析，经过若干动作，向前分析，直到错误或到达结束状态。\n（3）转换图的化简 用代入的方法进行化简：合并减去重复的边和状态，将简化后的代入其他里面化简\n（4）预测分析程序的实现 要求用来描述预测分析程序的语言允许递归调用。\n实现举例：\n3. 非递归预测分析 使用一张分析表和一个栈联合控制，实现对输入符号串的自顶向下分析。\n3.1 预测分析程序的模型及工作过程 算法4.1 非递归预测分析方法 3.2 预测分析表的构造 （1）改写文法 （2）FIRST集合及其构造 推导出的开头终结符号集\n（3）FOLLOW集合及其构造 后面紧跟的终结符号集\n（4）算法4.2 预测分析表的构造 3.2 LL(1)文法 如果一个文法的预测分析表M不含多重定义的表项， 则称该文法为LL(1)文法。\nLL(1)的含义：\n第一个L表示从左至右扫描输入符号串 第二个L表示生成输入串的一个最左推导 1表示在决定分析程序的每步动作时，向前看一个符号 3.","keywords":["Principles of Compiler"],"articleBody":"4.1 语法分析简介 编译程序的核心工作。\n语法分析程序的任务：\n从源程序记号序列中识别出各类语法成分 进行语法检查 语法分析程序的地位：\n由语法分析程序完成：\n输入：语义分析出的记号流/序列 工作依据：源语言的语法规则 功能任务：从记号流中识别出各类语法成分、进行语法检查 输出：分析树 错误处理 常用的分析方法：\n自顶向下 自底向上 对输入符号串的扫描顺序：自左向右\n4.2 自顶向下分析方法 1. 递归下降分析 依次试探、谋求匹配。\n试图为输入符号串建立一个==最左推导序列==。\n实践中存在的困难和缺点：\n左递归的文法，可能导致分析过程陷入死循环 ==回溯== 工作的重复 效率低、代价高：穷尽一切可能的试探法。 2. 递归调用预测分析 一种确定的、==不带回溯==的递归下降分析方法——能够根据所面临的输入符号准确地指派一个候选式去执行任务。\n对文法的要求：\n不含左递归\n非终结符号的所有候选式的FIRST集两两互不相交\n2.1 预测分析程序的构造 改写文法：重写文法、消除左递归、提取左公因子\n（1）预测分析程序的转换图 为每个非终结符号创建一个转换图，每个候选式对应一条路径：\n（2）转换图的工作过程 从文法开始符号所对应的转换图的开始状态开始分析，经过若干动作，向前分析，直到错误或到达结束状态。\n（3）转换图的化简 用代入的方法进行化简：合并减去重复的边和状态，将简化后的代入其他里面化简\n（4）预测分析程序的实现 要求用来描述预测分析程序的语言允许递归调用。\n实现举例：\n3. 非递归预测分析 使用一张分析表和一个栈联合控制，实现对输入符号串的自顶向下分析。\n3.1 预测分析程序的模型及工作过程 算法4.1 非递归预测分析方法 3.2 预测分析表的构造 （1）改写文法 （2）FIRST集合及其构造 推导出的开头终结符号集\n（3）FOLLOW集合及其构造 后面紧跟的终结符号集\n（4）算法4.2 预测分析表的构造 3.2 LL(1)文法 如果一个文法的预测分析表M不含多重定义的表项， 则称该文法为LL(1)文法。\nLL(1)的含义：\n第一个L表示从左至右扫描输入符号串 第二个L表示生成输入串的一个最左推导 1表示在决定分析程序的每步动作时，向前看一个符号 3.3 预测分析方法中的错误处理示例 4.3 自底向上分析 概述 因为自底向上，所以不需要消除左递归，消除左公因子\n常用方法 优先分析方法 LR分析方法 —— “移进-归约”分析方法 最右推导的逆过程 分析动作： 移进：输入符号进栈 归约：替换栈顶 规范归约：右句型序列，是最右推导的逆过程 接受：成功 错误处理：调用错误处理程序诊断和恢复 分析过程中的动作冲突 移进-归约 冲突 归约-归约 冲突 4.4 LR分析方法（移进-归约） 适用于所有能用上下文无关文法书写的程序设计语言的结构\n基本思想：历史信息+预测信息\n1. 模型及分析过程 知道了分析表，即可按照上面模型分析。那么分析表如何创建？\n分析表-文法 分类 自底向上方法，适用于任何文法\n自顶向下方法，需要满足条件（无左递归、左公因子，FOOLOW。。。ε。。。）\n每一种文法对应一种分析表 判断是否是LL(1)文法 判断是否是LR(0)文法 LR(0)文法：不需要向前看，即==没有任何冲突==\n如何判断：文法的每个活前缀的有效项目集中\n要么都是移进-待约项目 要么只有一个归约项目 判断是否是SLR(1)文法 若用算法4.5构造出来的分析表不含有冲突（==冲突可解决==），则该分析表称为该文法的SLR(1)分析表\n具有SLR(1)分析表的文法称为SLR(1)文法\n每个SLR(1)文法都是无二义性文法，但并非无二义性文法都是SLR(1)文法\n对于SLR(1)解决不了的文法，说明预测信息太少，需要向前看更多信息，所以接下来引入LR(1)分析方法\n判断是否是LR(1)文法 有不同类型项目时，看==符号是否相同==，不同则不冲突，就是LR(1)项目\n判断是否是LALR(1)文法 用==LR(1)文法合并后没有冲突==，就是了\n2. SLR(1)分析表的构造 为给定的文法构造一个识别它所有活前缀的DFA，根据该DFA构造文法的分析表\n活前缀：不含句柄之后任何符号的前缀，最多到包括整个句柄\nLR(0)项目 标有圆点的产生式\n归约项目：圆点在最右边 接受项目：对文法开始符号的归约项目（S-\u003exxx•） 待约项目：圆点后第一个符号是N 移进项目：圆点后第一个符号是T ==（ε不是T，不要写成A-\u003e•ε或A-\u003eε•。对于产生式A-\u003eε，只有一个归约项目A-\u003e•。）==\n拓广文法 引入起始符号S’，产生式S’-\u003eS\n扩广后的文法只有一个接受项目即：S’-\u003eS• （构造每种分析表前都要先拓广文法的原因）\n定义4.10：LR(0)有效项目 推广：——–\n==LR(0)项目S’-\u003e•S是活前缀ε的有效项目==—–构造DFA的起点\nγ的LR(0)有效项目集：文法G的某个活前缀γ的所有LR(0)有效项目组成的集合\nG的LR(0)项目集规范族：文法G的所有LR(0)有效项目集组成的集合\n定义4.11：闭包(closure) 求LR(0)项目集合I的闭包：\nI中的每个项目加进去 若加完后有待约项目，则把该N对应的产生式项目加进去 定义4.12：转移函数go go(I, X)=closure(J) 即LR(0)项目集经过X一步到达J，再对J求闭包\n直观含义：有效项目的推导\n算法4.5 构造文法G的LR(0)项目集规范族 拓广文法G' 活前缀 ε 的有效项目集（求closure({S’-\u003e•S})） 依次求其他转移函数 得到LR(0)项目集规范族 得到LR(0)项目集规范族，就可以画出DFA，接下来如何根据DFA构建分析表？\n算法4.6 构造SLR(1)分析表 SLR(1)分析方法冲突的解决 3. LR(1)分析表的构造 LR(k)项目 向前看k个符号\n定义4.13：LR(1)有效项目 推广：——–\n==LR(1)项目[S’-\u003e•S, $]是活前缀ε的有效项目==—–构造DFA的起点\nγ的LR(1)有效项目集：文法G的某个活前缀γ的所有LR(1)有效项目组成的集合\nG的LR(1)项目集规范族：文法G的所有LR(1)有效项目集组成的集合\n定义4.14：闭包（closure） 定义4.15：转移函数go 算法4.8 构造文法G的LR(1)项目集规范族 算法4.9 构造LR(1)分析表 4. LALR(1)分析表的构造 合并LR(1)分析表得到LALR(1)\n描述LR(1)项目集特征的两个定义 构造LALR(1)分析表的思想 合并LR(1)项目集规范族中的同心集——以减少分析表 的状态数\n用核代替项目集——以减少项目集所需的存储空间\n转移函数可以通过go(I, X)自身的合并得到\n同心集的合并，可能导致归约-归约的冲突，但不会产生新的移进-归约冲突（因为如果产生，说明原来就存在此冲突）\n构造LALR(1)分析表的过程 构造LR(1)项目集规范族 检查是否冲突 如果冲突，就不是LR(1)文法 不冲突，就看是否存在同心集 不存在，则直接就是LALR(1)了 存在，就合并同心集 检查合并后是否存在冲突 有冲突，不是LALR(1) 无冲突，是LALR(1) 根据LALR(1)项目集规范族构造分析表 算法4.10 构造LALR(1)分析表 LALR(1)分析程序和LR(1)分析程序的比较 对于正确的输入符号串：分析动作完全一样。 对于错误的输入符号串：LR(1)可以及时发现错误， LALR(1)可以在同样的位置发现错误，但要多做一些归约分析。 5 LR分析方法对二义文法的应用(*) 定理：任何二义性文法决不是LR文法，因而也不是 SLR或LALR文法\n但是可以使用优先级实现二义性文法\n6 LR分析的错误处理与恢复 ","wordCount":"212","inLanguage":"en","datePublished":"2023-02-21T16:29:43Z","dateModified":"2023-02-21T16:29:43Z","author":{"@type":"Person","name":"Chan"},"mainEntityOfPage":{"@type":"WebPage","@id":"/posts/principles-of-compiler/ch4-%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90/"},"publisher":{"@type":"Organization","name":"Home","logo":{"@type":"ImageObject","url":"%3Clink%20/%20abs%20url%3E"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href accesskey=h title="Cheyne16's Blog (Alt + H)"><img src=/apple-touch-icon.png alt aria-label=logo height=35>Cheyne16's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=/categories/ title=categories><span>categories</span></a></li><li><a href=/tags/ title=tags><span>tags</span></a></li><li><a href=https://example.org title=example.org><span>example.org</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href>Home</a>&nbsp;»&nbsp;<a href=/posts/>Posts</a></div><h1 class=post-title>ch4-语法分析</h1><div class=post-meta><span title='2023-02-21 16:29:43 +0000 UTC'>February 21, 2023</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;212 words&nbsp;·&nbsp;Chan&nbsp;|&nbsp;<a href=https://github.com/%3cpath_to_repo%3e/content/posts/Principles%20of%20Compiler/ch4-%e8%af%ad%e6%b3%95%e5%88%86%e6%9e%90.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=post-content><h1 id=41-语法分析简介>4.1 语法分析简介<a hidden class=anchor aria-hidden=true href=#41-语法分析简介>#</a></h1><p>编译程序的核心工作。</p><p>语法分析程序的任务：</p><ul><li>从源程序记号序列中识别出各类语法成分</li><li>进行语法检查</li></ul><p>语法分析程序的地位：</p><p><img loading=lazy src=https://raw.githubusercontent.com/Cheyne16/ImageHub/main/gitee/img/image-20211105224719167.png alt=image-20211105224719167></p><p>由语法分析程序完成：</p><ul><li>输入：语义分析出的记号流/序列</li><li>工作依据：源语言的语法规则</li><li>功能任务：从记号流中识别出各类语法成分、进行语法检查</li><li>输出：分析树</li><li>错误处理</li></ul><p>常用的分析方法：</p><ul><li>自顶向下</li><li>自底向上</li></ul><p>对输入符号串的扫描顺序：自左向右</p><h1 id=42-自顶向下分析方法>4.2 自顶向下分析方法<a hidden class=anchor aria-hidden=true href=#42-自顶向下分析方法>#</a></h1><h2 id=1-递归下降分析>1. 递归下降分析<a hidden class=anchor aria-hidden=true href=#1-递归下降分析>#</a></h2><p>依次试探、谋求匹配。</p><p>试图为输入符号串建立一个==最左推导序列==。</p><p>实践中存在的困难和缺点：</p><ul><li>左递归的文法，可能导致分析过程陷入死循环</li><li>==回溯==</li><li>工作的重复</li><li>效率低、代价高：穷尽一切可能的试探法。</li></ul><h2 id=2-递归调用预测分析>2. 递归调用预测分析<a hidden class=anchor aria-hidden=true href=#2-递归调用预测分析>#</a></h2><p>一种确定的、==不带回溯==的递归下降分析方法——能够根据所面临的输入符号准确地指派一个候选式去执行任务。</p><p>对文法的要求：</p><ul><li><p>不含左递归</p></li><li><p>非终结符号的所有候选式的FIRST集两两互不相交</p></li></ul><h3 id=21-预测分析程序的构造>2.1 预测分析程序的构造<a hidden class=anchor aria-hidden=true href=#21-预测分析程序的构造>#</a></h3><p>改写文法：重写文法、消除左递归、提取左公因子</p><h4 id=1预测分析程序的转换图>（1）预测分析程序的转换图<a hidden class=anchor aria-hidden=true href=#1预测分析程序的转换图>#</a></h4><p>为每个非终结符号创建一个转换图，每个候选式对应一条路径：</p><p><img loading=lazy src=https://raw.githubusercontent.com/Cheyne16/ImageHub/main/gitee/img/image-20211105230350104.png alt=image-20211105230350104></p><h4 id=2转换图的工作过程>（2）转换图的工作过程<a hidden class=anchor aria-hidden=true href=#2转换图的工作过程>#</a></h4><p>从文法开始符号所对应的转换图的开始状态开始分析，经过若干动作，向前分析，直到错误或到达结束状态。</p><h4 id=3转换图的化简>（3）转换图的化简<a hidden class=anchor aria-hidden=true href=#3转换图的化简>#</a></h4><p>用代入的方法进行化简：合并减去重复的边和状态，将简化后的代入其他里面化简</p><h4 id=4预测分析程序的实现>（4）预测分析程序的实现<a hidden class=anchor aria-hidden=true href=#4预测分析程序的实现>#</a></h4><p>要求用来描述预测分析程序的语言允许递归调用。</p><p>实现举例：</p><p><img loading=lazy src=https://raw.githubusercontent.com/Cheyne16/ImageHub/main/gitee/img/image-20211105230800250.png alt=image-20211105230800250></p><h2 id=3-非递归预测分析>3. 非递归预测分析<a hidden class=anchor aria-hidden=true href=#3-非递归预测分析>#</a></h2><p>使用一张分析表和一个栈联合控制，实现对输入符号串的自顶向下分析。</p><h4 id=31-预测分析程序的模型及工作过程>3.1 预测分析程序的模型及工作过程<a hidden class=anchor aria-hidden=true href=#31-预测分析程序的模型及工作过程>#</a></h4><p><img loading=lazy src=https://raw.githubusercontent.com/Cheyne16/ImageHub/main/gitee/img/image-20211105231343869.png alt=image-20211105231343869></p><h5 id=算法41-非递归预测分析方法>算法4.1 非递归预测分析方法<a hidden class=anchor aria-hidden=true href=#算法41-非递归预测分析方法>#</a></h5><p><img loading=lazy src=https://raw.githubusercontent.com/Cheyne16/ImageHub/main/gitee/img/image-20211105232022743.png alt=image-20211105232022743></p><h4 id=32-预测分析表的构造>3.2 预测分析表的构造<a hidden class=anchor aria-hidden=true href=#32-预测分析表的构造>#</a></h4><h5 id=1改写文法>（1）改写文法<a hidden class=anchor aria-hidden=true href=#1改写文法>#</a></h5><h5 id=2first集合及其构造>（2）FIRST集合及其构造<a hidden class=anchor aria-hidden=true href=#2first集合及其构造>#</a></h5><p>推导出的开头终结符号集</p><p><img loading=lazy src=https://raw.githubusercontent.com/Cheyne16/ImageHub/main/gitee/img/image-20211105232453053.png alt=image-20211105232453053></p><p><img loading=lazy src=https://raw.githubusercontent.com/Cheyne16/ImageHub/main/gitee/img/image-20211104225655823.png alt=image-20211104225655823></p><h5 id=3follow集合及其构造>（3）FOLLOW集合及其构造<a hidden class=anchor aria-hidden=true href=#3follow集合及其构造>#</a></h5><p>后面紧跟的终结符号集</p><p><img loading=lazy src=https://raw.githubusercontent.com/Cheyne16/ImageHub/main/gitee/img/image-20211105232502467.png alt=image-20211105232502467></p><h5 id=4算法42-预测分析表的构造>（4）算法4.2 预测分析表的构造<a hidden class=anchor aria-hidden=true href=#4算法42-预测分析表的构造>#</a></h5><p><img loading=lazy src=https://raw.githubusercontent.com/Cheyne16/ImageHub/main/gitee/img/image-20211105232606744.png alt=image-20211105232606744></p><h4 id=32-ll1文法>3.2 LL(1)文法<a hidden class=anchor aria-hidden=true href=#32-ll1文法>#</a></h4><p>如果一个文法的预测分析表M不含多重定义的表项， 则称该文法为LL(1)文法。</p><p>LL(1)的含义：</p><ul><li>第一个L表示从左至右扫描输入符号串</li><li>第二个L表示生成输入串的一个最左推导</li><li>1表示在决定分析程序的每步动作时，向前看一个符号</li></ul><h4 id=33-预测分析方法中的错误处理示例>3.3 预测分析方法中的错误处理示例<a hidden class=anchor aria-hidden=true href=#33-预测分析方法中的错误处理示例>#</a></h4><p><img loading=lazy src=https://raw.githubusercontent.com/Cheyne16/ImageHub/main/gitee/img/image-20211105232751656.png alt=image-20211105232751656></p><h1 id=43-自底向上分析-概述>4.3 自底向上分析 概述<a hidden class=anchor aria-hidden=true href=#43-自底向上分析-概述>#</a></h1><p>因为自底向上，所以不需要消除左递归，消除左公因子</p><h2 id=常用方法>常用方法<a hidden class=anchor aria-hidden=true href=#常用方法>#</a></h2><ul><li>优先分析方法</li><li><strong>LR分析方法 —— “移进-归约”分析方法</strong><ul><li>最右推导的逆过程</li><li>分析动作：<ul><li>移进：输入符号进栈</li><li>归约：替换栈顶<ul><li>规范归约：右句型序列，是最右推导的逆过程</li></ul></li><li>接受：成功</li><li>错误处理：调用错误处理程序诊断和恢复</li></ul></li><li>分析过程中的动作冲突<ul><li>移进-归约 冲突</li><li>归约-归约 冲突</li></ul></li></ul></li></ul><h1 id=44-lr分析方法移进-归约>4.4 LR分析方法（移进-归约）<a hidden class=anchor aria-hidden=true href=#44-lr分析方法移进-归约>#</a></h1><p>适用于所有能用上下文无关文法书写的程序设计语言的结构</p><p>基本思想：历史信息+预测信息</p><h2 id=1-模型及分析过程>1. 模型及分析过程<a hidden class=anchor aria-hidden=true href=#1-模型及分析过程>#</a></h2><p>知道了分析表，即可按照上面模型分析。那么分析表如何创建？</p><h4 id=分析表-文法-分类>分析表-文法 分类<a hidden class=anchor aria-hidden=true href=#分析表-文法-分类>#</a></h4><ul><li><p>自底向上方法，适用于任何文法</p></li><li><p>自顶向下方法，需要满足条件（无左递归、左公因子，FOOLOW。。。ε。。。）</p><ul><li>每一种文法对应一种分析表</li></ul></li></ul><p><img loading=lazy src=https://raw.githubusercontent.com/Cheyne16/ImageHub/main/gitee/img/image-20211104111948124.png alt=image-20211104111948124></p><h5 id=判断是否是ll1文法>判断是否是LL(1)文法<a hidden class=anchor aria-hidden=true href=#判断是否是ll1文法>#</a></h5><p><img loading=lazy src=https://raw.githubusercontent.com/Cheyne16/ImageHub/main/gitee/img/image-20211104231557763.png alt=image-20211104231557763></p><h5 id=判断是否是lr0文法>判断是否是LR(0)文法<a hidden class=anchor aria-hidden=true href=#判断是否是lr0文法>#</a></h5><p>LR(0)文法：不需要向前看，即==没有任何冲突==</p><p>如何判断：文法的每个活前缀的有效项目集中</p><ul><li>要么都是移进-待约项目</li><li>要么只有一个归约项目</li></ul><h5 id=判断是否是slr1文法>判断是否是SLR(1)文法<a hidden class=anchor aria-hidden=true href=#判断是否是slr1文法>#</a></h5><p>若用算法4.5构造出来的分析表不含有冲突（==冲突可解决==），则该分析表称为该文法的SLR(1)分析表</p><p>具有SLR(1)分析表的文法称为SLR(1)文法</p><ul><li><p>每个SLR(1)文法都是无二义性文法，但并非无二义性文法都是SLR(1)文法</p></li><li><p>对于SLR(1)解决不了的文法，说明预测信息太少，需要向前看更多信息，所以接下来引入LR(1)分析方法</p></li></ul><h5 id=判断是否是lr1文法>判断是否是LR(1)文法<a hidden class=anchor aria-hidden=true href=#判断是否是lr1文法>#</a></h5><p>有不同类型项目时，看==符号是否相同==，不同则不冲突，就是LR(1)项目</p><h5 id=判断是否是lalr1文法>判断是否是LALR(1)文法<a hidden class=anchor aria-hidden=true href=#判断是否是lalr1文法>#</a></h5><p>用==LR(1)文法合并后没有冲突==，就是了</p><h2 id=2-slr1分析表的构造>2. SLR(1)分析表的构造<a hidden class=anchor aria-hidden=true href=#2-slr1分析表的构造>#</a></h2><p>为给定的文法构造一个识别它所有活前缀的DFA，根据该DFA构造文法的分析表</p><blockquote><p>活前缀：不含句柄之后任何符号的前缀，最多到包括整个句柄</p></blockquote><h4 id=lr0项目>LR(0)项目<a hidden class=anchor aria-hidden=true href=#lr0项目>#</a></h4><p>标有圆点的产生式</p><ul><li>归约项目：圆点在最右边</li><li>接受项目：对文法开始符号的归约项目（S->xxx•）</li><li>待约项目：圆点后第一个符号是N</li><li>移进项目：圆点后第一个符号是T</li></ul><p>==（ε不是T，不要写成A->•ε或A->ε•。对于产生式A->ε，只有一个归约项目A->•。）==</p><h4 id=拓广文法>拓广文法<a hidden class=anchor aria-hidden=true href=#拓广文法>#</a></h4><p>引入起始符号S&rsquo;，产生式S&rsquo;->S</p><p>扩广后的文法只有一个接受项目即：S&rsquo;->S• （构造每种分析表前都要先拓广文法的原因）</p><h4 id=定义410lr0有效项目>定义4.10：LR(0)有效项目<a hidden class=anchor aria-hidden=true href=#定义410lr0有效项目>#</a></h4><p>推广：&mdash;&mdash;&ndash;</p><p>==LR(0)项目S&rsquo;->•S是活前缀ε的有效项目==&mdash;&ndash;构造DFA的起点</p><p>γ的LR(0)有效项目集：文法G的某个活前缀γ的所有LR(0)有效项目组成的集合</p><p>G的LR(0)项目集规范族：文法G的所有LR(0)有效项目集组成的集合</p><h4 id=定义411闭包closure>定义4.11：闭包(closure)<a hidden class=anchor aria-hidden=true href=#定义411闭包closure>#</a></h4><p>求LR(0)项目集合I的闭包：</p><ul><li>I中的每个项目加进去</li><li>若加完后有待约项目，则把该N对应的产生式项目加进去</li></ul><h4 id=定义412转移函数go>定义4.12：转移函数go<a hidden class=anchor aria-hidden=true href=#定义412转移函数go>#</a></h4><p>go(I, X)=closure(J) 即LR(0)项目集经过X一步到达J，再对J求闭包</p><p>直观含义：有效项目的推导</p><h4 id=算法45-构造文法g的lr0项目集规范族>算法4.5 构造文法G的LR(0)项目集规范族<a hidden class=anchor aria-hidden=true href=#算法45-构造文法g的lr0项目集规范族>#</a></h4><ol><li>拓广文法G'</li><li>活前缀 ε 的有效项目集（求closure({S&rsquo;->•S})）</li><li>依次求其他转移函数</li><li>得到LR(0)项目集规范族</li></ol><p>得到LR(0)项目集规范族，就可以画出DFA，接下来如何根据DFA构建分析表？</p><h4 id=算法46-构造slr1分析表>算法4.6 构造SLR(1)分析表<a hidden class=anchor aria-hidden=true href=#算法46-构造slr1分析表>#</a></h4><p><img loading=lazy src=https://raw.githubusercontent.com/Cheyne16/ImageHub/main/gitee/img/image-20211030161838365.png alt=image-20211030161838365></p><h4 id=slr1分析方法冲突的解决>SLR(1)分析方法冲突的解决<a hidden class=anchor aria-hidden=true href=#slr1分析方法冲突的解决>#</a></h4><h2 id=3-lr1分析表的构造>3. LR(1)分析表的构造<a hidden class=anchor aria-hidden=true href=#3-lr1分析表的构造>#</a></h2><h4 id=lrk项目>LR(k)项目<a hidden class=anchor aria-hidden=true href=#lrk项目>#</a></h4><p>向前看k个符号</p><h4 id=定义413lr1有效项目>定义4.13：LR(1)有效项目<a hidden class=anchor aria-hidden=true href=#定义413lr1有效项目>#</a></h4><p><img loading=lazy src=https://raw.githubusercontent.com/Cheyne16/ImageHub/main/gitee/img/image-20211031185157195.png alt=image-20211031185157195></p><p>推广：&mdash;&mdash;&ndash;</p><p>==LR(1)项目[S&rsquo;->•S, $]是活前缀ε的有效项目==&mdash;&ndash;构造DFA的起点</p><p>γ的LR(1)有效项目集：文法G的某个活前缀γ的所有LR(1)有效项目组成的集合</p><p>G的LR(1)项目集规范族：文法G的所有LR(1)有效项目集组成的集合</p><h4 id=定义414闭包closure>定义4.14：闭包（closure）<a hidden class=anchor aria-hidden=true href=#定义414闭包closure>#</a></h4><p><img loading=lazy src=https://raw.githubusercontent.com/Cheyne16/ImageHub/main/gitee/img/image-20211031185902182.png alt=image-20211031185902182></p><h4 id=定义415转移函数go>定义4.15：转移函数go<a hidden class=anchor aria-hidden=true href=#定义415转移函数go>#</a></h4><p><img loading=lazy src=https://raw.githubusercontent.com/Cheyne16/ImageHub/main/gitee/img/image-20211031190007436.png alt=image-20211031190007436></p><h4 id=算法48-构造文法g的lr1项目集规范族>算法4.8 构造文法G的LR(1)项目集规范族<a hidden class=anchor aria-hidden=true href=#算法48-构造文法g的lr1项目集规范族>#</a></h4><p><img loading=lazy src=https://raw.githubusercontent.com/Cheyne16/ImageHub/main/gitee/img/image-20211031190142996.png alt=image-20211031190142996></p><h4 id=算法49-构造lr1分析表>算法4.9 构造LR(1)分析表<a hidden class=anchor aria-hidden=true href=#算法49-构造lr1分析表>#</a></h4><p><img loading=lazy src=https://raw.githubusercontent.com/Cheyne16/ImageHub/main/gitee/img/image-20211031190225944.png alt=image-20211031190225944></p><h2 id=4-lalr1分析表的构造>4. LALR(1)分析表的构造<a hidden class=anchor aria-hidden=true href=#4-lalr1分析表的构造>#</a></h2><p>合并LR(1)分析表得到LALR(1)</p><h4 id=描述lr1项目集特征的两个定义>描述LR(1)项目集特征的两个定义<a hidden class=anchor aria-hidden=true href=#描述lr1项目集特征的两个定义>#</a></h4><p><img loading=lazy src=https://raw.githubusercontent.com/Cheyne16/ImageHub/main/gitee/img/image-20211104111050485.png alt=image-20211104111050485></p><h4 id=构造lalr1分析表的思想>构造LALR(1)分析表的思想<a hidden class=anchor aria-hidden=true href=#构造lalr1分析表的思想>#</a></h4><ul><li><p>合并LR(1)项目集规范族中的同心集——以减少分析表 的状态数</p></li><li><p>用核代替项目集——以减少项目集所需的存储空间</p></li><li><p>转移函数可以通过go(I, X)自身的合并得到</p></li><li><p>同心集的合并，可能导致归约-归约的冲突，但不会产生新的移进-归约冲突（因为如果产生，说明原来就存在此冲突）</p></li></ul><h4 id=构造lalr1分析表的过程>构造LALR(1)分析表的过程<a hidden class=anchor aria-hidden=true href=#构造lalr1分析表的过程>#</a></h4><ol><li>构造LR(1)项目集规范族</li><li>检查是否冲突<ol><li>如果冲突，就不是LR(1)文法</li><li>不冲突，就看是否存在同心集<ol><li>不存在，则直接就是LALR(1)了</li><li>存在，就合并同心集</li><li>检查合并后是否存在冲突<ol><li>有冲突，不是LALR(1)</li><li>无冲突，是LALR(1)</li></ol></li></ol></li></ol></li><li>根据LALR(1)项目集规范族构造分析表</li></ol><h4 id=算法410-构造lalr1分析表>算法4.10 构造LALR(1)分析表<a hidden class=anchor aria-hidden=true href=#算法410-构造lalr1分析表>#</a></h4><p><img loading=lazy src=https://raw.githubusercontent.com/Cheyne16/ImageHub/main/gitee/img/image-20211104111632716.png alt=image-20211104111632716></p><h4 id=lalr1分析程序和lr1分析程序的比较>LALR(1)分析程序和LR(1)分析程序的比较<a hidden class=anchor aria-hidden=true href=#lalr1分析程序和lr1分析程序的比较>#</a></h4><ul><li>对于正确的输入符号串：分析动作完全一样。</li><li>对于错误的输入符号串：LR(1)可以及时发现错误， LALR(1)可以在同样的位置发现错误，但要多做一些归约分析。</li></ul><h2 id=5-lr分析方法对二义文法的应用>5 LR分析方法对二义文法的应用(*)<a hidden class=anchor aria-hidden=true href=#5-lr分析方法对二义文法的应用>#</a></h2><p>定理：任何二义性文法决不是LR文法，因而也不是 SLR或LALR文法</p><p>但是可以使用<strong>优先级</strong>实现二义性文法</p><h2 id=6-lr分析的错误处理与恢复>6 LR分析的错误处理与恢复<a hidden class=anchor aria-hidden=true href=#6-lr分析的错误处理与恢复>#</a></h2><p><img loading=lazy src=https://raw.githubusercontent.com/Cheyne16/ImageHub/main/gitee/img/image-20211105233040388.png alt=image-20211105233040388></p></div><footer class=post-footer><ul class=post-tags><li><a href=/tags/principles-of-compiler/>Principles of Compiler</a></li></ul><nav class=paginav><a class=prev href=/posts/formal-languages-and-automata/ch4-%E4%B8%8A%E4%B8%8B%E6%96%87%E6%97%A0%E5%85%B3%E6%96%87%E6%B3%95%E4%B8%8E%E4%B8%8B%E6%8E%A8%E8%87%AA%E5%8A%A8%E6%9C%BA/><span class=title>« Prev</span><br><span>ch4-上下文无关文法与下推自动机</span></a>
<a class=next href=/posts/computer-network/ch5-networklayer/><span class=title>Next »</span><br><span>ch5-NetworkLayer</span></a></nav><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share ch4-语法分析 on twitter" href="https://twitter.com/intent/tweet/?text=ch4-%e8%af%ad%e6%b3%95%e5%88%86%e6%9e%90&url=%2fposts%2fprinciples-of-compiler%2fch4-%25E8%25AF%25AD%25E6%25B3%2595%25E5%2588%2586%25E6%259E%2590%2f&hashtags=PrinciplesofCompiler"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share ch4-语法分析 on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=%2fposts%2fprinciples-of-compiler%2fch4-%25E8%25AF%25AD%25E6%25B3%2595%25E5%2588%2586%25E6%259E%2590%2f&title=ch4-%e8%af%ad%e6%b3%95%e5%88%86%e6%9e%90&summary=ch4-%e8%af%ad%e6%b3%95%e5%88%86%e6%9e%90&source=%2fposts%2fprinciples-of-compiler%2fch4-%25E8%25AF%25AD%25E6%25B3%2595%25E5%2588%2586%25E6%259E%2590%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share ch4-语法分析 on reddit" href="https://reddit.com/submit?url=%2fposts%2fprinciples-of-compiler%2fch4-%25E8%25AF%25AD%25E6%25B3%2595%25E5%2588%2586%25E6%259E%2590%2f&title=ch4-%e8%af%ad%e6%b3%95%e5%88%86%e6%9e%90"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share ch4-语法分析 on facebook" href="https://facebook.com/sharer/sharer.php?u=%2fposts%2fprinciples-of-compiler%2fch4-%25E8%25AF%25AD%25E6%25B3%2595%25E5%2588%2586%25E6%259E%2590%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share ch4-语法分析 on whatsapp" href="https://api.whatsapp.com/send?text=ch4-%e8%af%ad%e6%b3%95%e5%88%86%e6%9e%90%20-%20%2fposts%2fprinciples-of-compiler%2fch4-%25E8%25AF%25AD%25E6%25B3%2595%25E5%2588%2586%25E6%259E%2590%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share ch4-语法分析 on telegram" href="https://telegram.me/share/url?text=ch4-%e8%af%ad%e6%b3%95%e5%88%86%e6%9e%90&url=%2fposts%2fprinciples-of-compiler%2fch4-%25E8%25AF%25AD%25E6%25B3%2595%25E5%2588%2586%25E6%259E%2590%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></div></footer></article></main><footer class=footer><span>&copy; 2023 <a href>Home</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>