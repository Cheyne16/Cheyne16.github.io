<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>ch7-运行时环境 | Home</title><meta name=keywords content="Principles of Compiler"><meta name=description content="运行时环境的内容，主要是分配数据位置，确定访问变量时的机制，过程的链接和参数传递等。
本章主题包括存储管理、变量和数据的访问。
存储分配的方式
代码区和静态区位于底部，堆区向上生长，栈区向下生长
静态分配：编译时
动态分配：生成目标程序时
栈式存储：与过程的调用/返回同步进行分配和回收 堆存储：手工进行回收，需要垃圾回收机制 栈式分配
活动树
过程调用在时间上是嵌套的，因此可以用栈来分配空间 程序所有过程活动可以用树表示 活动记录
每个活跃的活动对应栈中的活动记录
实参 返回值 控制链 访问链 保存的机器状态 局部数据 临时变量 调用代码序列
调用代码序列分配空间，返回代码序列恢复机器状态
尽量把代码放在被调用者中
调用代码序列
计算实参值 把返回值和原top sp放到被调者的活动记录，并增加top sp的值 被调者的保存寄存器值等状态 被调者初始化局部数据 返回代码序列
被调用者把返回值放到与参数相邻的位置 恢复top sp和寄存器，跳转到返回地址 从实参到控制链，虽然是被调用者的活动记录，但是其是由调用者负责的 栈中的变长数据
如果数据的生命周期局限于过程活动，那么就可以分配在栈中，变长数组也是可以的 使用两个指针，top指向实际栈顶，top sp寻找顶层记录的定长字段（有点base的感觉） 非局部数据的访问
C语言中，全局变量在静态区，地址在编译时刻可知
Pascal语言中，因为有嵌套过程，所以需要访问链
访问链用于访问非局部的数据 如果过程p的声明嵌套在过程q，那么p的访问链指向上层最近的活动记录 嵌套深度：声明时的嵌套深度，最外层为1 显示表 堆管理
存放生命周期不确定或明确被删除为止的数据对象
例如：new -> delete, malloc -> free
存储管理器
C/C++需要手动回收，Java可以自动回收
基本功能：分配一段连续，大小适当的堆空间；把被回收的空间返回空闲空间缓冲池
评价指标：
空间效率：使程序所需要的对空间最小 程序效率：运用内存系统的层次，使程序运行更快 低开销：使分配/收回内存的操作高效 程序的局部性：空间局部性和时间局部性
堆空间分配方法：
best-fit：选择满足请求的最小窗口 first-fit：放在第一个可容纳的窗口。但是总体性能会较差，但是拥有较好的数据局部性 垃圾回收
什么是垃圾
广义：不需要再被引用的数据 狭义：不能被引用的数据 垃圾回收：自动回收不可达数据的机制"><meta name=author content="Chan"><link rel=canonical href=/posts/principles-of-compiler/ch7-%E8%BF%90%E8%A1%8C%E6%97%B6%E7%8E%AF%E5%A2%83/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.6a98292fb8fa8cf0f3ba4042d4b75515c04267550f3ad49ff6271b5af9562443.css integrity="sha256-apgpL7j6jPDzukBC1LdVFcBCZ1UPOtSf9icbWvlWJEM=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-123-45","auto"),ga("send","pageview"))</script><meta property="og:title" content="ch7-运行时环境"><meta property="og:description" content="运行时环境的内容，主要是分配数据位置，确定访问变量时的机制，过程的链接和参数传递等。
本章主题包括存储管理、变量和数据的访问。
存储分配的方式
代码区和静态区位于底部，堆区向上生长，栈区向下生长
静态分配：编译时
动态分配：生成目标程序时
栈式存储：与过程的调用/返回同步进行分配和回收 堆存储：手工进行回收，需要垃圾回收机制 栈式分配
活动树
过程调用在时间上是嵌套的，因此可以用栈来分配空间 程序所有过程活动可以用树表示 活动记录
每个活跃的活动对应栈中的活动记录
实参 返回值 控制链 访问链 保存的机器状态 局部数据 临时变量 调用代码序列
调用代码序列分配空间，返回代码序列恢复机器状态
尽量把代码放在被调用者中
调用代码序列
计算实参值 把返回值和原top sp放到被调者的活动记录，并增加top sp的值 被调者的保存寄存器值等状态 被调者初始化局部数据 返回代码序列
被调用者把返回值放到与参数相邻的位置 恢复top sp和寄存器，跳转到返回地址 从实参到控制链，虽然是被调用者的活动记录，但是其是由调用者负责的 栈中的变长数据
如果数据的生命周期局限于过程活动，那么就可以分配在栈中，变长数组也是可以的 使用两个指针，top指向实际栈顶，top sp寻找顶层记录的定长字段（有点base的感觉） 非局部数据的访问
C语言中，全局变量在静态区，地址在编译时刻可知
Pascal语言中，因为有嵌套过程，所以需要访问链
访问链用于访问非局部的数据 如果过程p的声明嵌套在过程q，那么p的访问链指向上层最近的活动记录 嵌套深度：声明时的嵌套深度，最外层为1 显示表 堆管理
存放生命周期不确定或明确被删除为止的数据对象
例如：new -> delete, malloc -> free
存储管理器
C/C++需要手动回收，Java可以自动回收
基本功能：分配一段连续，大小适当的堆空间；把被回收的空间返回空闲空间缓冲池
评价指标：
空间效率：使程序所需要的对空间最小 程序效率：运用内存系统的层次，使程序运行更快 低开销：使分配/收回内存的操作高效 程序的局部性：空间局部性和时间局部性
堆空间分配方法：
best-fit：选择满足请求的最小窗口 first-fit：放在第一个可容纳的窗口。但是总体性能会较差，但是拥有较好的数据局部性 垃圾回收
什么是垃圾
广义：不需要再被引用的数据 狭义：不能被引用的数据 垃圾回收：自动回收不可达数据的机制"><meta property="og:type" content="article"><meta property="og:url" content="/posts/principles-of-compiler/ch7-%E8%BF%90%E8%A1%8C%E6%97%B6%E7%8E%AF%E5%A2%83/"><meta property="og:image" content="%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-02-21T16:29:43+00:00"><meta property="article:modified_time" content="2023-02-21T16:29:43+00:00"><meta property="og:site_name" content="Chancellor16's Blog"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="ch7-运行时环境"><meta name=twitter:description content="运行时环境的内容，主要是分配数据位置，确定访问变量时的机制，过程的链接和参数传递等。
本章主题包括存储管理、变量和数据的访问。
存储分配的方式
代码区和静态区位于底部，堆区向上生长，栈区向下生长
静态分配：编译时
动态分配：生成目标程序时
栈式存储：与过程的调用/返回同步进行分配和回收 堆存储：手工进行回收，需要垃圾回收机制 栈式分配
活动树
过程调用在时间上是嵌套的，因此可以用栈来分配空间 程序所有过程活动可以用树表示 活动记录
每个活跃的活动对应栈中的活动记录
实参 返回值 控制链 访问链 保存的机器状态 局部数据 临时变量 调用代码序列
调用代码序列分配空间，返回代码序列恢复机器状态
尽量把代码放在被调用者中
调用代码序列
计算实参值 把返回值和原top sp放到被调者的活动记录，并增加top sp的值 被调者的保存寄存器值等状态 被调者初始化局部数据 返回代码序列
被调用者把返回值放到与参数相邻的位置 恢复top sp和寄存器，跳转到返回地址 从实参到控制链，虽然是被调用者的活动记录，但是其是由调用者负责的 栈中的变长数据
如果数据的生命周期局限于过程活动，那么就可以分配在栈中，变长数组也是可以的 使用两个指针，top指向实际栈顶，top sp寻找顶层记录的定长字段（有点base的感觉） 非局部数据的访问
C语言中，全局变量在静态区，地址在编译时刻可知
Pascal语言中，因为有嵌套过程，所以需要访问链
访问链用于访问非局部的数据 如果过程p的声明嵌套在过程q，那么p的访问链指向上层最近的活动记录 嵌套深度：声明时的嵌套深度，最外层为1 显示表 堆管理
存放生命周期不确定或明确被删除为止的数据对象
例如：new -> delete, malloc -> free
存储管理器
C/C++需要手动回收，Java可以自动回收
基本功能：分配一段连续，大小适当的堆空间；把被回收的空间返回空闲空间缓冲池
评价指标：
空间效率：使程序所需要的对空间最小 程序效率：运用内存系统的层次，使程序运行更快 低开销：使分配/收回内存的操作高效 程序的局部性：空间局部性和时间局部性
堆空间分配方法：
best-fit：选择满足请求的最小窗口 first-fit：放在第一个可容纳的窗口。但是总体性能会较差，但是拥有较好的数据局部性 垃圾回收
什么是垃圾
广义：不需要再被引用的数据 狭义：不能被引用的数据 垃圾回收：自动回收不可达数据的机制"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"/posts/"},{"@type":"ListItem","position":3,"name":"ch7-运行时环境","item":"/posts/principles-of-compiler/ch7-%E8%BF%90%E8%A1%8C%E6%97%B6%E7%8E%AF%E5%A2%83/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"ch7-运行时环境","name":"ch7-运行时环境","description":"运行时环境的内容，主要是分配数据位置，确定访问变量时的机制，过程的链接和参数传递等。\n本章主题包括存储管理、变量和数据的访问。\n存储分配的方式\n代码区和静态区位于底部，堆区向上生长，栈区向下生长\n静态分配：编译时\n动态分配：生成目标程序时\n栈式存储：与过程的调用/返回同步进行分配和回收 堆存储：手工进行回收，需要垃圾回收机制 栈式分配\n活动树\n过程调用在时间上是嵌套的，因此可以用栈来分配空间 程序所有过程活动可以用树表示 活动记录\n每个活跃的活动对应栈中的活动记录\n实参 返回值 控制链 访问链 保存的机器状态 局部数据 临时变量 调用代码序列\n调用代码序列分配空间，返回代码序列恢复机器状态\n尽量把代码放在被调用者中\n调用代码序列\n计算实参值 把返回值和原top sp放到被调者的活动记录，并增加top sp的值 被调者的保存寄存器值等状态 被调者初始化局部数据 返回代码序列\n被调用者把返回值放到与参数相邻的位置 恢复top sp和寄存器，跳转到返回地址 从实参到控制链，虽然是被调用者的活动记录，但是其是由调用者负责的 栈中的变长数据\n如果数据的生命周期局限于过程活动，那么就可以分配在栈中，变长数组也是可以的 使用两个指针，top指向实际栈顶，top sp寻找顶层记录的定长字段（有点base的感觉） 非局部数据的访问\nC语言中，全局变量在静态区，地址在编译时刻可知\nPascal语言中，因为有嵌套过程，所以需要访问链\n访问链用于访问非局部的数据 如果过程p的声明嵌套在过程q，那么p的访问链指向上层最近的活动记录 嵌套深度：声明时的嵌套深度，最外层为1 显示表 堆管理\n存放生命周期不确定或明确被删除为止的数据对象\n例如：new -\u0026gt; delete, malloc -\u0026gt; free\n存储管理器\nC/C++需要手动回收，Java可以自动回收\n基本功能：分配一段连续，大小适当的堆空间；把被回收的空间返回空闲空间缓冲池\n评价指标：\n空间效率：使程序所需要的对空间最小 程序效率：运用内存系统的层次，使程序运行更快 低开销：使分配/收回内存的操作高效 程序的局部性：空间局部性和时间局部性\n堆空间分配方法：\nbest-fit：选择满足请求的最小窗口 first-fit：放在第一个可容纳的窗口。但是总体性能会较差，但是拥有较好的数据局部性 垃圾回收\n什么是垃圾\n广义：不需要再被引用的数据 狭义：不能被引用的数据 垃圾回收：自动回收不可达数据的机制","keywords":["Principles of Compiler"],"articleBody":"运行时环境的内容，主要是分配数据位置，确定访问变量时的机制，过程的链接和参数传递等。\n本章主题包括存储管理、变量和数据的访问。\n存储分配的方式\n代码区和静态区位于底部，堆区向上生长，栈区向下生长\n静态分配：编译时\n动态分配：生成目标程序时\n栈式存储：与过程的调用/返回同步进行分配和回收 堆存储：手工进行回收，需要垃圾回收机制 栈式分配\n活动树\n过程调用在时间上是嵌套的，因此可以用栈来分配空间 程序所有过程活动可以用树表示 活动记录\n每个活跃的活动对应栈中的活动记录\n实参 返回值 控制链 访问链 保存的机器状态 局部数据 临时变量 调用代码序列\n调用代码序列分配空间，返回代码序列恢复机器状态\n尽量把代码放在被调用者中\n调用代码序列\n计算实参值 把返回值和原top sp放到被调者的活动记录，并增加top sp的值 被调者的保存寄存器值等状态 被调者初始化局部数据 返回代码序列\n被调用者把返回值放到与参数相邻的位置 恢复top sp和寄存器，跳转到返回地址 从实参到控制链，虽然是被调用者的活动记录，但是其是由调用者负责的 栈中的变长数据\n如果数据的生命周期局限于过程活动，那么就可以分配在栈中，变长数组也是可以的 使用两个指针，top指向实际栈顶，top sp寻找顶层记录的定长字段（有点base的感觉） 非局部数据的访问\nC语言中，全局变量在静态区，地址在编译时刻可知\nPascal语言中，因为有嵌套过程，所以需要访问链\n访问链用于访问非局部的数据 如果过程p的声明嵌套在过程q，那么p的访问链指向上层最近的活动记录 嵌套深度：声明时的嵌套深度，最外层为1 显示表 堆管理\n存放生命周期不确定或明确被删除为止的数据对象\n例如：new -\u003e delete, malloc -\u003e free\n存储管理器\nC/C++需要手动回收，Java可以自动回收\n基本功能：分配一段连续，大小适当的堆空间；把被回收的空间返回空闲空间缓冲池\n评价指标：\n空间效率：使程序所需要的对空间最小 程序效率：运用内存系统的层次，使程序运行更快 低开销：使分配/收回内存的操作高效 程序的局部性：空间局部性和时间局部性\n堆空间分配方法：\nbest-fit：选择满足请求的最小窗口 first-fit：放在第一个可容纳的窗口。但是总体性能会较差，但是拥有较好的数据局部性 垃圾回收\n什么是垃圾\n广义：不需要再被引用的数据 狭义：不能被引用的数据 垃圾回收：自动回收不可达数据的机制\n垃圾回收器的设计目标\n基本要求：语言是类型安全的，知道数据元素是否为指向某内存块的指针。C/C++就是类型不安全的 性能目标：不增加总体运行时间；回收引起的停顿时间较短；最大限度利用内存；改善空间和时间局部性 可达性\n可达性就是一个存储块可被程序访问到 根集：不需要指针解引用就能直接访问的数据（Java的静态成员，栈中变量） 根集的成员都是可达的，如果对象被可达对象指向，那么这个对象也是可达的 如果对象变得不可达，那么就不会再变成可达的 改变可达对象集合的操作\n对象分配 函数传参和返回值 引用赋值 过程返回 垃圾回收方法\n关注不可达：捕获对象变得不可达的时刻 关注可达：标记可达对象，回收其它对象 基于引用计数的垃圾回收器\n每个对象维护引用计数的字段 如果对象计数为0，在删除对象之前，对此对象各个指针所指向对象引用计数减1 开销大，但是不会停顿 循环引用会使得垃圾的引用计数大于0 基于跟踪的回收\nmark sweep\n从根集开始跟踪并标记所有可达对象 遍历堆区，释放不可达对象 算法见讲义 mark and compress\n将可达对象移动到堆区的一段，另一端就是空闲空间 空闲空间合并有助于提高分配效率 copy\n把堆空间分为两份 一份半空间满时，开始垃圾回收，可达对象拷贝到另一端 不涉及任何不可达对象 嵌套过程的静态作用域规则 嵌套过程：过程定义允许嵌套，如Pascal语言\n嵌套过程的静态作用域规则：如果在嵌套语言程序中的某个过程proc引用了非局部名字a，那么a的声明应该在过程proc的外围过程中，并且是离过程proc最近的声明a的那个外围过程。\n参数传递 传值调用：把实参的值赋给形参，对形参的操作均在其活动记录的参数域上，不影响过程体之外的值 引用调用/传地址调用：要求实参必须已经分配存储空间，把实参的地址传给形参，对形参的引用都是对相应实参的引用 复制恢复：调用时copy-in，将实参的右值传给形参，记录与形参相应的实参的左值；执行时对形参操作；调用结束时copy-out，按从左到右的顺序把形参的右值复制给相应实参。只有具有左值的实参的值才会复制出来 传名调用：把过程当作宏处理，即宏扩展，用被调用的过程体替换调用语句，用实参的名字替换形参 画活动记录——参数、控制链、访问链 控制链：当前调用序列（左边3条）\n访问链\n所有相邻的嵌套关系（右边三条） 调用过程关系——当一个函数f被当作参数传递时，它必须携带自己的访问链。由调用函数c为f确定访问链（指向调用函数c，红色那条），并将其f和访问链一起传递给参数 display表 ","wordCount":"121","inLanguage":"en","datePublished":"2023-02-21T16:29:43Z","dateModified":"2023-02-21T16:29:43Z","author":{"@type":"Person","name":"Chan"},"mainEntityOfPage":{"@type":"WebPage","@id":"/posts/principles-of-compiler/ch7-%E8%BF%90%E8%A1%8C%E6%97%B6%E7%8E%AF%E5%A2%83/"},"publisher":{"@type":"Organization","name":"Home","logo":{"@type":"ImageObject","url":"%3Clink%20/%20abs%20url%3E"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href accesskey=h title="Cheyne16's Blog (Alt + H)"><img src=/apple-touch-icon.png alt aria-label=logo height=35>Cheyne16's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=/categories/ title=categories><span>categories</span></a></li><li><a href=/tags/ title=tags><span>tags</span></a></li><li><a href=https://example.org title=example.org><span>example.org</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href>Home</a>&nbsp;»&nbsp;<a href=/posts/>Posts</a></div><h1 class=post-title>ch7-运行时环境</h1><div class=post-meta><span title='2023-02-21 16:29:43 +0000 UTC'>February 21, 2023</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;121 words&nbsp;·&nbsp;Chan&nbsp;|&nbsp;<a href=https://github.com/%3cpath_to_repo%3e/content/posts/Principles%20of%20Compiler/ch7-%e8%bf%90%e8%a1%8c%e6%97%b6%e7%8e%af%e5%a2%83.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=post-content><p>运行时环境的内容，主要是分配数据位置，确定访问变量时的机制，过程的链接和参数传递等。</p><p>本章主题包括存储管理、变量和数据的访问。</p><ul><li><p>存储分配的方式</p></li><li><ul><li><p>代码区和静态区位于底部，堆区向上生长，栈区向下生长</p></li><li><p>静态分配：编译时</p></li><li><p>动态分配：生成目标程序时</p></li><li><ul><li>栈式存储：与过程的调用/返回同步进行分配和回收</li><li>堆存储：手工进行回收，需要垃圾回收机制</li></ul></li></ul></li><li><p>栈式分配</p></li><li><ul><li><p>活动树</p></li><li><ul><li>过程调用在时间上是嵌套的，因此可以用栈来分配空间</li><li>程序所有过程活动可以用树表示</li></ul></li><li><p>活动记录</p></li><li><ul><li><p>每个活跃的活动对应栈中的活动记录</p></li><li><ul><li>实参</li><li>返回值</li><li>控制链</li><li>访问链</li><li>保存的机器状态</li><li>局部数据</li><li>临时变量</li></ul></li></ul></li><li><p>调用代码序列</p></li><li><ul><li><p>调用代码序列分配空间，返回代码序列恢复机器状态</p></li><li><p>尽量把代码放在被调用者中</p></li><li><p>调用代码序列</p></li><li><ul><li>计算实参值</li><li>把返回值和原top sp放到被调者的活动记录，并增加top sp的值</li><li>被调者的保存寄存器值等状态</li><li>被调者初始化局部数据</li></ul></li><li><p>返回代码序列</p></li><li><ul><li>被调用者把返回值放到与参数相邻的位置</li><li>恢复top sp和寄存器，跳转到返回地址</li><li>从实参到控制链，虽然是被调用者的活动记录，但是其是由调用者负责的</li></ul></li></ul></li><li><p>栈中的变长数据</p></li><li><ul><li>如果数据的生命周期局限于过程活动，那么就可以分配在栈中，变长数组也是可以的</li><li>使用两个指针，top指向实际栈顶，top sp寻找顶层记录的定长字段（有点base的感觉）</li></ul></li><li><p>非局部数据的访问</p></li><li><ul><li><p>C语言中，全局变量在静态区，地址在编译时刻可知</p></li><li><p>Pascal语言中，因为有嵌套过程，所以需要访问链</p></li><li><ul><li>访问链用于访问非局部的数据</li><li>如果过程p的声明嵌套在过程q，那么p的访问链指向上层最近的活动记录</li><li>嵌套深度：声明时的嵌套深度，最外层为1</li><li>显示表</li></ul></li></ul></li></ul></li><li><p>堆管理</p></li><li><ul><li><p>存放生命周期不确定或明确被删除为止的数据对象</p></li><li><p>例如：new -> delete, malloc -> free</p></li><li><p>存储管理器</p></li><li><ul><li><p>C/C++需要手动回收，Java可以自动回收</p></li><li><p>基本功能：分配一段连续，大小适当的堆空间；把被回收的空间返回空闲空间缓冲池</p></li><li><p>评价指标：</p></li><li><ul><li>空间效率：使程序所需要的对空间最小</li><li>程序效率：运用内存系统的层次，使程序运行更快</li><li>低开销：使分配/收回内存的操作高效</li></ul></li></ul></li><li><p>程序的局部性：空间局部性和时间局部性</p></li><li><p>堆空间分配方法：</p></li><li><ul><li>best-fit：选择满足请求的最小窗口</li><li>first-fit：放在第一个可容纳的窗口。但是总体性能会较差，但是拥有较好的数据局部性</li></ul></li></ul></li><li><p>垃圾回收</p></li><li><ul><li><p>什么是垃圾</p></li><li><ul><li>广义：不需要再被引用的数据</li><li>狭义：不能被引用的数据</li></ul></li><li><p>垃圾回收：自动回收不可达数据的机制</p></li><li><p>垃圾回收器的设计目标</p></li><li><ul><li>基本要求：语言是类型安全的，知道数据元素是否为指向某内存块的指针。C/C++就是类型不安全的</li><li>性能目标：不增加总体运行时间；回收引起的停顿时间较短；最大限度利用内存；改善空间和时间局部性</li></ul></li><li><p>可达性</p></li><li><ul><li>可达性就是一个存储块可被程序访问到</li><li>根集：不需要指针解引用就能直接访问的数据（Java的静态成员，栈中变量）</li><li>根集的成员都是可达的，如果对象被可达对象指向，那么这个对象也是可达的</li><li>如果对象变得不可达，那么就不会再变成可达的</li></ul></li><li><p>改变可达对象集合的操作</p></li><li><ul><li>对象分配</li><li>函数传参和返回值</li><li>引用赋值</li><li>过程返回</li></ul></li><li><p>垃圾回收方法</p></li><li><ul><li>关注不可达：捕获对象变得不可达的时刻</li><li>关注可达：标记可达对象，回收其它对象</li></ul></li><li><p>基于引用计数的垃圾回收器</p></li><li><ul><li>每个对象维护引用计数的字段</li><li>如果对象计数为0，在删除对象之前，对此对象各个指针所指向对象引用计数减1</li><li>开销大，但是不会停顿</li><li>循环引用会使得垃圾的引用计数大于0</li></ul></li><li><p>基于跟踪的回收</p></li><li><ul><li><p>mark sweep</p></li><li><ul><li>从根集开始跟踪并标记所有可达对象</li><li>遍历堆区，释放不可达对象</li><li>算法见讲义</li></ul></li><li><p>mark and compress</p></li><li><ul><li>将可达对象移动到堆区的一段，另一端就是空闲空间</li><li>空闲空间合并有助于提高分配效率</li></ul></li><li><p>copy</p></li><li><ul><li>把堆空间分为两份</li><li>一份半空间满时，开始垃圾回收，可达对象拷贝到另一端</li><li>不涉及任何不可达对象</li></ul></li></ul></li></ul></li></ul><h1 id=嵌套过程的静态作用域规则>嵌套过程的静态作用域规则<a hidden class=anchor aria-hidden=true href=#嵌套过程的静态作用域规则>#</a></h1><p>嵌套过程：过程定义允许嵌套，如Pascal语言</p><p>嵌套过程的静态作用域规则：如果在嵌套语言程序中的某个过程proc引用了<strong>非局部名字</strong>a，那么a的声明应该在过程proc的外围过程中，并且是<strong>离过程proc最近</strong>的声明a的那个外围过程。</p><h1 id=参数传递>参数传递<a hidden class=anchor aria-hidden=true href=#参数传递>#</a></h1><ul><li>传值调用：把实参的值赋给形参，对形参的操作均在其活动记录的参数域上，不影响过程体之外的值</li><li>引用调用/传地址调用：要求实参必须已经分配存储空间，把实参的地址传给形参，对形参的引用都是对相应实参的引用</li><li>复制恢复：调用时copy-in，将实参的右值传给形参，记录与形参相应的实参的左值；执行时对形参操作；调用结束时copy-out，按从左到右的顺序把形参的右值复制给相应实参。只有具有左值的实参的值才会复制出来</li><li>传名调用：把过程当作宏处理，即宏扩展，用被调用的过程体替换调用语句，用实参的名字替换形参</li></ul><h1 id=画活动记录参数控制链访问链>画活动记录——参数、控制链、访问链<a hidden class=anchor aria-hidden=true href=#画活动记录参数控制链访问链>#</a></h1><ul><li><p>控制链：当前调用序列（左边3条）</p></li><li><p>访问链</p><ul><li>所有相邻的嵌套关系（右边三条）</li><li>调用过程关系——当一个函数f被当作参数传递时，它必须携带自己的访问链。由调用函数c为f确定访问链（指向调用函数c，红色那条），并将其f和访问链一起传递给参数</li></ul></li></ul><h1 id=display表>display表<a hidden class=anchor aria-hidden=true href=#display表>#</a></h1></div><footer class=post-footer><ul class=post-tags><li><a href=/tags/principles-of-compiler/>Principles of Compiler</a></li></ul><nav class=paginav><a class=prev href=/posts/computer-network/ch7-%E5%BA%94%E7%94%A8%E5%B1%82/><span class=title>« Prev</span><br><span>ch7-应用层</span></a>
<a class=next href=/posts/db/ch7nf%E5%90%8E%E5%8D%8A%E9%83%A8%E5%88%86%E7%AC%94%E8%AE%B0/><span class=title>Next »</span><br><span>ch7NF后半部分笔记</span></a></nav><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share ch7-运行时环境 on twitter" href="https://twitter.com/intent/tweet/?text=ch7-%e8%bf%90%e8%a1%8c%e6%97%b6%e7%8e%af%e5%a2%83&url=%2fposts%2fprinciples-of-compiler%2fch7-%25E8%25BF%2590%25E8%25A1%258C%25E6%2597%25B6%25E7%258E%25AF%25E5%25A2%2583%2f&hashtags=PrinciplesofCompiler"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share ch7-运行时环境 on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=%2fposts%2fprinciples-of-compiler%2fch7-%25E8%25BF%2590%25E8%25A1%258C%25E6%2597%25B6%25E7%258E%25AF%25E5%25A2%2583%2f&title=ch7-%e8%bf%90%e8%a1%8c%e6%97%b6%e7%8e%af%e5%a2%83&summary=ch7-%e8%bf%90%e8%a1%8c%e6%97%b6%e7%8e%af%e5%a2%83&source=%2fposts%2fprinciples-of-compiler%2fch7-%25E8%25BF%2590%25E8%25A1%258C%25E6%2597%25B6%25E7%258E%25AF%25E5%25A2%2583%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share ch7-运行时环境 on reddit" href="https://reddit.com/submit?url=%2fposts%2fprinciples-of-compiler%2fch7-%25E8%25BF%2590%25E8%25A1%258C%25E6%2597%25B6%25E7%258E%25AF%25E5%25A2%2583%2f&title=ch7-%e8%bf%90%e8%a1%8c%e6%97%b6%e7%8e%af%e5%a2%83"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share ch7-运行时环境 on facebook" href="https://facebook.com/sharer/sharer.php?u=%2fposts%2fprinciples-of-compiler%2fch7-%25E8%25BF%2590%25E8%25A1%258C%25E6%2597%25B6%25E7%258E%25AF%25E5%25A2%2583%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share ch7-运行时环境 on whatsapp" href="https://api.whatsapp.com/send?text=ch7-%e8%bf%90%e8%a1%8c%e6%97%b6%e7%8e%af%e5%a2%83%20-%20%2fposts%2fprinciples-of-compiler%2fch7-%25E8%25BF%2590%25E8%25A1%258C%25E6%2597%25B6%25E7%258E%25AF%25E5%25A2%2583%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share ch7-运行时环境 on telegram" href="https://telegram.me/share/url?text=ch7-%e8%bf%90%e8%a1%8c%e6%97%b6%e7%8e%af%e5%a2%83&url=%2fposts%2fprinciples-of-compiler%2fch7-%25E8%25BF%2590%25E8%25A1%258C%25E6%2597%25B6%25E7%258E%25AF%25E5%25A2%2583%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></div></footer></article></main><footer class=footer><span>&copy; 2023 <a href>Home</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>