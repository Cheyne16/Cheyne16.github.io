<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>第5章 中央处理器 | Home</title><meta name=keywords content="Principles of Computer Organization"><meta name=description content="中央处理器 中央处理器
CPU的功能 指令控制 控制程序按照顺序执行 操作控制 传送不同的信号 时间控制 各种操作的同步 数据加工 算数逻辑运算 中断处理 对异常情况和特殊请求的处理 CPU的基本组成 控制器与运算器 控制器 由程序计数器PC、指令寄存器IR、指令译码器、操作控制器和时序产生器组成（不包括地址译码器） 运算器 由算数逻辑单元ALU、累加寄存器AC、数据缓冲寄存器DR和状态条件寄存器PSW组成 重要的寄存器 数据缓冲寄存器
DR
存放从cache读出的字或来自外部接口的字或ALU运算结果 写数据cache时也先用DR暂存 用来作为ALU运算结果和通用寄存器之间信息传送时时间上的缓冲 补偿CPU和内存、外设之间速度的差别 指令寄存器
IR
用来保存当前正在执行的一条指令 指令的操作码会流向指令译码器，译码后即可向控制器发出信号 程序计数器
PC
也叫指令计数器。用来保存下一条指令的地址 程序开始执行前先把程序的第一条指令所在地址置入PC CPU会自行修改PC的值 地址寄存器
AR
用来保存当前处理器访问的数据cache中的单元地址 通用寄存器R0-R3
不同的计算机的通用寄存器数量不同。可以几十上百个。教学举例通常使用四个 为ALU提供暂存数据的工作区 其中的累加寄存器AC暂存ALU的运算结果 状态条件寄存器
PSW
根据算数结果、逻辑指令等信息得到了状态条件 包括运算结果进位标志C，运算结果溢出标志V，运算结果为0表示Z，最算结果为负标志N 每个标志位由一个触发器保存 保存中断和系统工作状态等信息 CPU的寄存器中 对用户透明的（不可见的）：存储器地址寄存器、存储器数据寄存器、指令寄存器 可见的：通用寄存器、程序状态寄存器、程序计数器 数据通路 各寄存器之间、寄存器与ALU之间传送数据的通路称为数据通路。信息从哪里出发，中间经过哪个寄存器或多路开关，最后传送到哪个寄存器，都要加以控制。
在各寄存器之间建立数据通路的任务由操作控制器完成
操作控制器 根据指令操作码和时序信号，产生各种操作控制信号，以便正确地建立数据通路
根据设计方法不同，操作控制器可以分为
时序逻辑型 - 使用时序逻辑技术实现，称为硬布线控制器 存储逻辑型 - 使用存储逻辑实现，称为微程序控制器 时序产生器 对各种操作信号进行时间上先后顺序的控制
指令周期 基本概念 冯诺依曼机，即存储程序式计算机，在程序运行前需要把程序和数据放入内存
执行程序流程：
把程序首地址送入PC 从内存cache中取指，执行，并形成下一条指令的地址 自动执行直到程序的最后一条指令 也就是“取指-执行”的循环"><meta name=author content="Chan"><link rel=canonical href=/posts/principles-of-computer-organization/%E7%AC%AC5%E7%AB%A0-%E4%B8%AD%E5%A4%AE%E5%A4%84%E7%90%86%E5%99%A8/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.6a98292fb8fa8cf0f3ba4042d4b75515c04267550f3ad49ff6271b5af9562443.css integrity="sha256-apgpL7j6jPDzukBC1LdVFcBCZ1UPOtSf9icbWvlWJEM=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-123-45","auto"),ga("send","pageview"))</script><meta property="og:title" content="第5章 中央处理器"><meta property="og:description" content="中央处理器 中央处理器
CPU的功能 指令控制 控制程序按照顺序执行 操作控制 传送不同的信号 时间控制 各种操作的同步 数据加工 算数逻辑运算 中断处理 对异常情况和特殊请求的处理 CPU的基本组成 控制器与运算器 控制器 由程序计数器PC、指令寄存器IR、指令译码器、操作控制器和时序产生器组成（不包括地址译码器） 运算器 由算数逻辑单元ALU、累加寄存器AC、数据缓冲寄存器DR和状态条件寄存器PSW组成 重要的寄存器 数据缓冲寄存器
DR
存放从cache读出的字或来自外部接口的字或ALU运算结果 写数据cache时也先用DR暂存 用来作为ALU运算结果和通用寄存器之间信息传送时时间上的缓冲 补偿CPU和内存、外设之间速度的差别 指令寄存器
IR
用来保存当前正在执行的一条指令 指令的操作码会流向指令译码器，译码后即可向控制器发出信号 程序计数器
PC
也叫指令计数器。用来保存下一条指令的地址 程序开始执行前先把程序的第一条指令所在地址置入PC CPU会自行修改PC的值 地址寄存器
AR
用来保存当前处理器访问的数据cache中的单元地址 通用寄存器R0-R3
不同的计算机的通用寄存器数量不同。可以几十上百个。教学举例通常使用四个 为ALU提供暂存数据的工作区 其中的累加寄存器AC暂存ALU的运算结果 状态条件寄存器
PSW
根据算数结果、逻辑指令等信息得到了状态条件 包括运算结果进位标志C，运算结果溢出标志V，运算结果为0表示Z，最算结果为负标志N 每个标志位由一个触发器保存 保存中断和系统工作状态等信息 CPU的寄存器中 对用户透明的（不可见的）：存储器地址寄存器、存储器数据寄存器、指令寄存器 可见的：通用寄存器、程序状态寄存器、程序计数器 数据通路 各寄存器之间、寄存器与ALU之间传送数据的通路称为数据通路。信息从哪里出发，中间经过哪个寄存器或多路开关，最后传送到哪个寄存器，都要加以控制。
在各寄存器之间建立数据通路的任务由操作控制器完成
操作控制器 根据指令操作码和时序信号，产生各种操作控制信号，以便正确地建立数据通路
根据设计方法不同，操作控制器可以分为
时序逻辑型 - 使用时序逻辑技术实现，称为硬布线控制器 存储逻辑型 - 使用存储逻辑实现，称为微程序控制器 时序产生器 对各种操作信号进行时间上先后顺序的控制
指令周期 基本概念 冯诺依曼机，即存储程序式计算机，在程序运行前需要把程序和数据放入内存
执行程序流程：
把程序首地址送入PC 从内存cache中取指，执行，并形成下一条指令的地址 自动执行直到程序的最后一条指令 也就是“取指-执行”的循环"><meta property="og:type" content="article"><meta property="og:url" content="/posts/principles-of-computer-organization/%E7%AC%AC5%E7%AB%A0-%E4%B8%AD%E5%A4%AE%E5%A4%84%E7%90%86%E5%99%A8/"><meta property="og:image" content="%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-02-21T16:29:43+00:00"><meta property="article:modified_time" content="2023-02-21T16:29:43+00:00"><meta property="og:site_name" content="Chancellor16's Blog"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="第5章 中央处理器"><meta name=twitter:description content="中央处理器 中央处理器
CPU的功能 指令控制 控制程序按照顺序执行 操作控制 传送不同的信号 时间控制 各种操作的同步 数据加工 算数逻辑运算 中断处理 对异常情况和特殊请求的处理 CPU的基本组成 控制器与运算器 控制器 由程序计数器PC、指令寄存器IR、指令译码器、操作控制器和时序产生器组成（不包括地址译码器） 运算器 由算数逻辑单元ALU、累加寄存器AC、数据缓冲寄存器DR和状态条件寄存器PSW组成 重要的寄存器 数据缓冲寄存器
DR
存放从cache读出的字或来自外部接口的字或ALU运算结果 写数据cache时也先用DR暂存 用来作为ALU运算结果和通用寄存器之间信息传送时时间上的缓冲 补偿CPU和内存、外设之间速度的差别 指令寄存器
IR
用来保存当前正在执行的一条指令 指令的操作码会流向指令译码器，译码后即可向控制器发出信号 程序计数器
PC
也叫指令计数器。用来保存下一条指令的地址 程序开始执行前先把程序的第一条指令所在地址置入PC CPU会自行修改PC的值 地址寄存器
AR
用来保存当前处理器访问的数据cache中的单元地址 通用寄存器R0-R3
不同的计算机的通用寄存器数量不同。可以几十上百个。教学举例通常使用四个 为ALU提供暂存数据的工作区 其中的累加寄存器AC暂存ALU的运算结果 状态条件寄存器
PSW
根据算数结果、逻辑指令等信息得到了状态条件 包括运算结果进位标志C，运算结果溢出标志V，运算结果为0表示Z，最算结果为负标志N 每个标志位由一个触发器保存 保存中断和系统工作状态等信息 CPU的寄存器中 对用户透明的（不可见的）：存储器地址寄存器、存储器数据寄存器、指令寄存器 可见的：通用寄存器、程序状态寄存器、程序计数器 数据通路 各寄存器之间、寄存器与ALU之间传送数据的通路称为数据通路。信息从哪里出发，中间经过哪个寄存器或多路开关，最后传送到哪个寄存器，都要加以控制。
在各寄存器之间建立数据通路的任务由操作控制器完成
操作控制器 根据指令操作码和时序信号，产生各种操作控制信号，以便正确地建立数据通路
根据设计方法不同，操作控制器可以分为
时序逻辑型 - 使用时序逻辑技术实现，称为硬布线控制器 存储逻辑型 - 使用存储逻辑实现，称为微程序控制器 时序产生器 对各种操作信号进行时间上先后顺序的控制
指令周期 基本概念 冯诺依曼机，即存储程序式计算机，在程序运行前需要把程序和数据放入内存
执行程序流程：
把程序首地址送入PC 从内存cache中取指，执行，并形成下一条指令的地址 自动执行直到程序的最后一条指令 也就是“取指-执行”的循环"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"/posts/"},{"@type":"ListItem","position":3,"name":"第5章 中央处理器","item":"/posts/principles-of-computer-organization/%E7%AC%AC5%E7%AB%A0-%E4%B8%AD%E5%A4%AE%E5%A4%84%E7%90%86%E5%99%A8/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"第5章 中央处理器","name":"第5章 中央处理器","description":"中央处理器 中央处理器\nCPU的功能 指令控制 控制程序按照顺序执行 操作控制 传送不同的信号 时间控制 各种操作的同步 数据加工 算数逻辑运算 中断处理 对异常情况和特殊请求的处理 CPU的基本组成 控制器与运算器 控制器 由程序计数器PC、指令寄存器IR、指令译码器、操作控制器和时序产生器组成（不包括地址译码器） 运算器 由算数逻辑单元ALU、累加寄存器AC、数据缓冲寄存器DR和状态条件寄存器PSW组成 重要的寄存器 数据缓冲寄存器\nDR\n存放从cache读出的字或来自外部接口的字或ALU运算结果 写数据cache时也先用DR暂存 用来作为ALU运算结果和通用寄存器之间信息传送时时间上的缓冲 补偿CPU和内存、外设之间速度的差别 指令寄存器\nIR\n用来保存当前正在执行的一条指令 指令的操作码会流向指令译码器，译码后即可向控制器发出信号 程序计数器\nPC\n也叫指令计数器。用来保存下一条指令的地址 程序开始执行前先把程序的第一条指令所在地址置入PC CPU会自行修改PC的值 地址寄存器\nAR\n用来保存当前处理器访问的数据cache中的单元地址 通用寄存器R0-R3\n不同的计算机的通用寄存器数量不同。可以几十上百个。教学举例通常使用四个 为ALU提供暂存数据的工作区 其中的累加寄存器AC暂存ALU的运算结果 状态条件寄存器\nPSW\n根据算数结果、逻辑指令等信息得到了状态条件 包括运算结果进位标志C，运算结果溢出标志V，运算结果为0表示Z，最算结果为负标志N 每个标志位由一个触发器保存 保存中断和系统工作状态等信息 CPU的寄存器中 对用户透明的（不可见的）：存储器地址寄存器、存储器数据寄存器、指令寄存器 可见的：通用寄存器、程序状态寄存器、程序计数器 数据通路 各寄存器之间、寄存器与ALU之间传送数据的通路称为数据通路。信息从哪里出发，中间经过哪个寄存器或多路开关，最后传送到哪个寄存器，都要加以控制。\n在各寄存器之间建立数据通路的任务由操作控制器完成\n操作控制器 根据指令操作码和时序信号，产生各种操作控制信号，以便正确地建立数据通路\n根据设计方法不同，操作控制器可以分为\n时序逻辑型 - 使用时序逻辑技术实现，称为硬布线控制器 存储逻辑型 - 使用存储逻辑实现，称为微程序控制器 时序产生器 对各种操作信号进行时间上先后顺序的控制\n指令周期 基本概念 冯诺依曼机，即存储程序式计算机，在程序运行前需要把程序和数据放入内存\n执行程序流程：\n把程序首地址送入PC 从内存cache中取指，执行，并形成下一条指令的地址 自动执行直到程序的最后一条指令 也就是“取指-执行”的循环","keywords":["Principles of Computer Organization"],"articleBody":"中央处理器 中央处理器\nCPU的功能 指令控制 控制程序按照顺序执行 操作控制 传送不同的信号 时间控制 各种操作的同步 数据加工 算数逻辑运算 中断处理 对异常情况和特殊请求的处理 CPU的基本组成 控制器与运算器 控制器 由程序计数器PC、指令寄存器IR、指令译码器、操作控制器和时序产生器组成（不包括地址译码器） 运算器 由算数逻辑单元ALU、累加寄存器AC、数据缓冲寄存器DR和状态条件寄存器PSW组成 重要的寄存器 数据缓冲寄存器\nDR\n存放从cache读出的字或来自外部接口的字或ALU运算结果 写数据cache时也先用DR暂存 用来作为ALU运算结果和通用寄存器之间信息传送时时间上的缓冲 补偿CPU和内存、外设之间速度的差别 指令寄存器\nIR\n用来保存当前正在执行的一条指令 指令的操作码会流向指令译码器，译码后即可向控制器发出信号 程序计数器\nPC\n也叫指令计数器。用来保存下一条指令的地址 程序开始执行前先把程序的第一条指令所在地址置入PC CPU会自行修改PC的值 地址寄存器\nAR\n用来保存当前处理器访问的数据cache中的单元地址 通用寄存器R0-R3\n不同的计算机的通用寄存器数量不同。可以几十上百个。教学举例通常使用四个 为ALU提供暂存数据的工作区 其中的累加寄存器AC暂存ALU的运算结果 状态条件寄存器\nPSW\n根据算数结果、逻辑指令等信息得到了状态条件 包括运算结果进位标志C，运算结果溢出标志V，运算结果为0表示Z，最算结果为负标志N 每个标志位由一个触发器保存 保存中断和系统工作状态等信息 CPU的寄存器中 对用户透明的（不可见的）：存储器地址寄存器、存储器数据寄存器、指令寄存器 可见的：通用寄存器、程序状态寄存器、程序计数器 数据通路 各寄存器之间、寄存器与ALU之间传送数据的通路称为数据通路。信息从哪里出发，中间经过哪个寄存器或多路开关，最后传送到哪个寄存器，都要加以控制。\n在各寄存器之间建立数据通路的任务由操作控制器完成\n操作控制器 根据指令操作码和时序信号，产生各种操作控制信号，以便正确地建立数据通路\n根据设计方法不同，操作控制器可以分为\n时序逻辑型 - 使用时序逻辑技术实现，称为硬布线控制器 存储逻辑型 - 使用存储逻辑实现，称为微程序控制器 时序产生器 对各种操作信号进行时间上先后顺序的控制\n指令周期 基本概念 冯诺依曼机，即存储程序式计算机，在程序运行前需要把程序和数据放入内存\n执行程序流程：\n把程序首地址送入PC 从内存cache中取指，执行，并形成下一条指令的地址 自动执行直到程序的最后一条指令 也就是“取指-执行”的循环\n指令周期是指“取指令、分析指令并执行指令所需的总时间”\n由于各种指令功能不同，所以各种指令的周期长度可能不同\n三个周期：\n时钟周期，处理操作的基本单位，也称为节拍脉冲或T周期 CPU周期，也称机器周期，指从内存中读取一个指令字（即指令）的最短时间，通常包含若干个时钟周期 指令周期通常包含若干个CPU周期、取出并执行需要的时间 RR型指令举例 - MOV指令的指令周期 不同的CPU结构会影响指令周期\n本例中使用的CPU模型如下\nMOV的指令周期如下：\nMOV指令是RR型指令，只有取指需要访存，所以只要两个CPU周期即可。一个CPU周期取指（回忆-CPU周期是从内存取出一个指令字的最短时间），另一个周期执行。执行不需要访存，寄存器之间的操作非常迅速，所以会在一个CPU周期内完成。而指令周期的最小单位是CPU周期，所以MOV需要两个完整的CPU周期\n取指周期图示：\n取指阶段：\n根据PC从内存中取出指令 指令译码或测试（逻辑电路而非时序电路，不花费时间） PC+1 对应的操作:\nPC -\u003e ABUS(I) IBUS -\u003eIR PC + 1 RS型指令举例 - LAD指令的指令周期 LAD指令为RS型指令，需要三个CPU周期\n所有指令的取指阶段都是一样的，取指花费一个CPU周期 把指令中的地址字段交给地址寄存器AR。此过程不访存，花费不到一个CPU周期，但是数据通过DBUS到达AR，占用了总线，所以按照一个CPU周期计算 从内存中取出数据到DR（回忆-DR为数据缓冲寄存器，几乎一切数据都要经过DR再到目的地），通过DBUS，需要一个完整的CPU周期 DR把数据交给通用寄存器R0，不访存，不使用总线，花费不到一个CPU周期，可以和上面的操作一起完成 各指令的指令周期小结 判断一个过程是否占用一整个CPU周期，判断依据1：有没有访存，因为每次访存会消耗一个CPU周期；判断依据2：有没有多个操作占用同一条总线。如果有则把两个操作放置到两个CPU周期中。无总线冲突且不访存的操作可以和前面的访存操作合并在一个CPU周期中\n取指操作中在把指令放入指令寄存器/指令译码器之后要等待下一个CPU周期来执行指令\n方框图语言 方框图语言基础 进行中央处理器设计时可以使用方框图语言描述一条指令的指令周期\n方框 - 代表一个CPU周期，方框中的内容表示此CPU周期内数据通路的操作或某些控制操作。 菱形 - 用来表示某种判别或测试，在时间上依附于前面方框的CPU周期。菱形自身不占用CPU周期 本CPU结构下的五条经典指令的指令周期：\n指令执行结束之后的曲线为公操作符号，表示指令已经执行完毕，转入公操作，公操作为CPU在指令执行结束后执行的一系列操作，如中断处理等\n例题 在这样的一个双总线结构的CPU中，画出\"ADD R2, R0\"指令完成(R0)+(R2)-\u003eR0操作的指令周期图\n因为此CPU中的双总线结构，几乎每两个相邻的操作都有总线冲突，所以每个操作都需要一个CPU周期\n指令周期流程图如下（下图种的一个方框不代表一个cpu周期，它只是将一个CPU周期内的指令放在了一起，不是方框图，取指令和执行指令分别占用一个CPU周期；方框内为操作，方框右侧为此CPU周期内为了实现操作而发出的控制信号）：\n时序产生器 如何识别二进制码是指令还是数据？如果是取指阶段读出的那就是指令，如果是执行阶段读出的那就是数据。被送往指令寄存器的是指令，被送往运算器的是数据\n时序信号产生器的组成 时钟源 环形脉冲发生器 节拍脉冲和读写时序的译码 启停控制逻辑 结构框图：\n输出信号：\n启停控制逻辑的控制方式 同步控制方式 任何情况下各指令执行时所需的机器周期数和时钟周期数固定不变\n异步控制方式 每条指令或操作按需占用时间。需要使用应答机制。没有时间上的浪费，但是控制复杂\n联合控制方式 结合以上两种控制方式。大部分操作序列安排在固定的机器周期中。个别的难以确定的操作则以执行部件的“应答”信号作为操作的结束\n微程序控制器 基本概念 使用软件的思想设计硬件\n与硬布线控制器相比较，具有规整性、灵活性、可维护性等一系列优点\n基本思想：把每条指令视为一个微程序，每个微程序由一系列微指令组成，每个微指令由一系列微命令。所有微程序存储在**控制存储器（只读）**中\n每条微命令对应一个微操作，即一个信号的变化\n微操作分类 相容性操作 - 可以在同一个CPU周期内并行执行的微操作 相斥性操作 - 不能同时或在同一个CPU周期内并行执行的微操作 微指令 在一个CPU中期内一组实现一定操作的微命令的组合，构成一条微指令\n微指令需要具备的功能：\n提供一条机器指令的一个步骤所需要的控制信号，以实现执行该步骤的操作功能 提供下一条微指令的地址，以便自动有序地执行微指令 微指令基本格式：由操作控制字段和顺序控制字段组成\n操作控制字段用来发出控制信号，每一位为一个微命令（即单个信号）。控制信号都是节拍点位信号，持续时间为一个CPU周期。只有与节拍脉冲相结合才能得到实际控制信号，即不同的信号在CPU周期内的不同时段发挥作用\n顺序控制字段用来执行下一条微指令的地址。本例中的微指令后四位直接给出了下一条微指令的地址，另外两位为测试方式位。如果测试方式有效，则根据直接地址和测试方式与地址转移逻辑共同决定下一条微指令的地址。详见地址转移逻辑部分\n微程序控制器原理框图 微指令寄存器 用来存放当前微指令 微地址寄存器 用来存放下一条微指令的地址。类似于PC 地址转移逻辑 管理位地址寄存器 默认情况会把当前微指令的顺序控制字段的直接地址交给微地址寄存器 程序出现分支时根据当前微指令的测试方式位和当前状态调整微地址寄存器的内容 控制存储器 存放全部指令系统微程序的只读存储器 读出一条微指令并执行的总时间被称为一个微指令周期 在串行方式工作的微程序控制器中，微指令周期就是只读存储器的工作周期 控制存储器示意图：\n微指令周期与CPU周期的关系 为了保证整个机器控制信号的同步，可以将一个微指令周期时间设计得恰好和CPU周期时间相等\n假设一个CPU周期为0.8μs，包含四个等间隔的节拍脉冲T1-T4，每个脉冲宽度200ns，可以用T4作为读取微指令的时间，用T1-T3时间作为执行微指令的时间。这样前面600ns中ALU计算出结果后可以在最后T4的200ns中把结果打入某个寄存器，同时微程序控制器读取下一个指令\n使用节拍电位-\u003e节拍脉冲二级体制\n微程序设计技术 微命令编码 直接表示法 每一位代表一个微命令（即一个实际的控制信号） 优点 - 简单直观 输出直接用于控制 缺点 - 微指令字较长 控制存储器容量较大 直接表示法图示：\n编码表示法 把一组相斥的微命令信号组成一个小组，通过译码器移码 与直接控制法相比编码表示法可以减少微指令字的长度，但是增加了译码电路，执行速度稍慢 此法使用较为普遍 编码表示法图示：\n混合表示法 混合以上两种表示法 混合表示法图示：\n微地址的形成方式 地址转移逻辑如何产生后继微地址\n计数器方式 类似于PC 顺序执行微指令时，后继微地址由当前微地址加上一个增量来产生 非顺序执行微指令时，必须通过一些转移策略改变下址 微地址寄存器可视为计数器，顺序执行的微指令序列必须安排在控制存储器的连续单元中 特点：顺序控制字段较短，微地址产生机构简单，但是多路并行转移功能较弱，速度慢，灵活性差 多路转移方式 一条微指令具有多个转移分支的能力称为多路转移 微程序出现分支时，如果有若干“候选”微地址，则根据顺序控制字段中的判别测试P和状态条件标志选择其中一个微地址 状态条件有n位标志，可以实现微程序2n路转移，涉及微地址寄存器的n位 特点：能以较短的顺序控制字段配合，实现多路并行转移，灵活性好，速度快，但是地址转移逻辑需要组合逻辑方法设计 由指令的操作码转换得到 典型方式为查表 在ROM中存放微地址映射表，用指令的操作码作为地址进行查表，以此得到微程序的入口地址 使用多路转移方式，设计地址转移逻辑例题：微地址寄存器6位(μA5-μA0)，当需要修改其内容时，可通过某一位触发器的强制端S将其置1。有如下三种情况\n执行“取指”微指令后微程序按IR的OP字段(IR3-IR0)进行16路分支 执行条件转移指令微程序时，按照进位标志C的状态进行2路分支 执行某控制台指令微程序时，按IR4与IR5的状态进行4路分支 请设计微地址转移逻辑\n解：题中所述微程序有三种判别测试，令这三种判别测试分别为P1、P2、P3\n当P1生效时根据IR3-IR0修改μA3-μA0（其实可以任选4位进行修改） 当P2生效时根据进位标志C修改μA0（任选1位即可） 当P3生效时根据IR5和IR4修改μA5和μA4（任选两位即可） 还要考虑时钟因素，假设CPU周期的最后一个节拍脉冲为T4，此时各运算已结束，得到了各个状态。则地址转移逻辑如下\nμA5 = P3 IR5 T4 μA4 = P3 IR4 T4 μA3 = P1 IR3 T4 μA2 = P1 IR2 T4 μA1 = P1 IR1 T4 μA0 = P1 IR0 T4 + P2 C T4 微指令格式 水平型微指令 一次能定义并执行多个并行操作微命令的微指令 按空客管制制度按·控制字段的编码方式不同可以分为 全水平型（不译码法）微指令 字段译码法水平型微指令 直接和译码相混合的水平型微指令 水平型微指令示意图：\n垂直型微指令 微指令中设置微操作码字段，由微操作码规定微指令的功能 结构类似于机器指令的结构，有操作码，在一条微指令中只有1-2个微命令，每条微指令的功能简单 实现一条机器指令的微程序比水平型微指令编写的微程序长得多 特点：微程序长而微指令短 垂直型微指令举例：\n寄存器-寄存器传送型微指令 运算控制型微指令 主存访问型微指令 条件转移型微指令 水平型微指令与垂直型微指令的比较：\n水平型微指令并行操作能力强，效率高，灵活性强 水平型微指令执行一条指令的时间更短 水平型微指令难以掌握。垂直型微指令与机器指令类似，相对易于掌握 硬布线控制器 基础 也叫组合逻辑控制器，被当前RISC计算机和高性能计算机普遍采用\n控制部件为产生固定时序控制信号的逻辑电路\n特点：\n形成控制信号的传输延迟少，系统运行速度快 设计控制CPU的时序控制信号的逻辑较复杂 与微程序控制相比，硬布线控制速度快 结构 树型逻辑网络拥有三个输入：指令译码器的译码输出、结果反馈信息和节拍电位/节拍脉冲发生器。树型逻辑网络内部为组合逻辑电路，根据输入调整输出，输出即为微操作控制信号\n与微程序控制器不同的是，时序产生器除了产生节拍脉冲，还需要产生节拍电位信号用来控制流程\n所以硬布线控制器的时序信号有三级：主状态周期-\u003e节拍电位-\u003e节拍脉冲\n硬布线控制器的指令周期流程 以下图为例。此图使用的CPU模型还是前面的那个模型\n时序产生器产生节拍电位信号M1、M2和M3用来控制当前处于流程中的哪一个阶段，也就是各个微操作的先后顺序\n比如某控制信号C0在以下情况下被激活：\n节拍电位为M1时被激活 节拍电位为M3且指令译码器发出的指令信号为ADD/LAD/AND 那么在树型逻辑网络里面C0的表达式就是C0 = M1 + M3(ADD + LAD + AND)\n如果使用同步控制方式，则所有指令都要有M1-M3三个阶段，但是像MOV这种指令在M3阶段没有任何操作，会导致时间的浪费。为了改进，可以使一些指令跳过一些节拍，如MOV指令进行M2节拍之后就结束。相应的节拍信号发生器的电路会更复杂\n与硬布线控制器相比，微程序控制器的控制信号可以复用（这也导致了速度比较慢），而硬布线完全使用布尔表达式实现，每个输出都有自己的表达式控制，几乎不能复用。可以使用布尔表达式化简\n硬布线控制器的设计 分析指令，列出所有执行的方框图 对流程进行划分，分隔到不同的时钟周期和节拍电位 总结表达式 举例：设计如图所示模型机的控制器，假设该模型机的系统只有如下5条指令，使用硬布线控制\n指令助记符 指令 功能 CLA 清零指令 0 -\u003e AC ADD AC, M 加法指令 (AC) + (M) -\u003e AC STA M 存数指令 (AC) -\u003e M JMP m 跳转指令 m -\u003e PC NOP 空指令 延时 分析指令，画出框图 因为总线数量受限，取指阶段的三个操作需要使用同一个总线，所以被拆分在了三个节拍脉冲中\n对流程进行划分，划分到不同的时钟周期和节拍电位 给操作分配时钟周期T和节拍电位M\n访存操作需要两个时钟周期，其他操作1个时钟周期。每个节拍电位中可以有数量不等的时钟周期。读指令自身一个节拍电位\n总结表达式 从图中找出所有的微操作，并命名如下表\n按照流程图给出表达式。注意表达式中同时含有时钟周期和节拍电位\nC0: PC -\u003e AR -\u003e ABUS = M1 T1 C1: PC + 1 -\u003e PC = M1 T4 C2: IR -\u003e PC = M2 T1 JMP C3: IR -\u003e AR -\u003e ABUS = M2 T1(ADD + STA) C4: DR -\u003e IR = M1 T4 C5: DR -\u003e ALU = M3 T3 ADD C6: DR -\u003e DBUS = M3(T2 + T3)STA C7: DBUS -\u003e DR = M1(T2 + T3) + M3(T1 + T2)ADD C8: AC -\u003e DR = M3 T1 STA C9: AC -\u003e ALU = M3 T3 ADD C10: ALU -\u003e AC = M3 T3 ADD C11: 0 -\u003e AC = M2 T1 CLA 流水CPU 流水CPU结构 指令部件 指令队列FIFO 执行部件 原理 在流水线(Pipeline)中必须是连续的任务，只有不断提供任务才能充分发挥流水线的效率 把一个任务分解为几个有联系的子任务，每个子任务由一个专门的功能部件实现 流水线中各段时间应尽量相等，否则会引起堵塞、断流现象 流水线需要装入时间和排空时间。流水线完全充满时才能充分发挥效率 指令处理的分解 IF(Instruction Fetch)取指 ID(Instruction Decode)译码 EX(Execution)执行 WB(Write Back)写回 四级指令流水线\n时空图 非流水线时空图：\n一条指令执行完毕后下一条指令才能开始执行，每隔四个时钟周期才会有一个输出结果\n标量流水线时空图：\n上一条指令与下一条指令存在时间上的重叠，每一个时钟周期就能输出一个结果\n超标量流水线时空图：\n在标量流水线基础上增加空间并行技术，一次执行多条指令\n线性流水线有三个阶段：\n性能指标 加速比(Speedup Ratio) 衡量不使用流水线和使用流水线完成同样任务所用的时间比 k级流水线时钟周期t，则不使用流水线完成n各任务所需时间T0=nkt，使用k级流水线完成n个连续任务所需时间为Tk=(k+n-1)t 显然当n远大于k时最大加速比为k 吞吐率 单位时间完成的任务数 n为任务数，Tk为完成n各任务的时间，则吞吐率TP = n / Tk 显然n趋近无穷时最大吞吐率为1/t 流水线冲突 资源相关 如流水线的不同部分在同一时钟周期同时访问内存。假设某流水线分为五部分：取指、译码、执行、取存、写回，那么在流水线执行时取指和取存都会访问存储器，这就导致了冲突\n解决方案\n某条指令在冲突时停顿一拍 分离数据与指令的存储 数据相关 流水线的不同节拍同时需要读写一个地址的数据。如运算结果在第3拍需要写入内存，而后面的操作需要用到这个内存。可能会发生“先读后写”冲突。注意同时读是不冲突的\n为了解决冲突，流水CPU设置了许多结果缓存寄存器，保存结果给后面的指令直接使用\n控制相关 由转移指令引起。因为流水线不知道判定结果，不知道应该顺序执行还是转移执行。常用处理技术：\n延迟转移 - “先执行再转移”。在条件转移之前已经有若干个指令进入流水线了，把这些指令执行完毕，如果正好是目标指令则没有浪费时间 分支预测 - 猜测分支的方向 静态分支预测。硬件固定的预测方式，如总是转移或总是不转移 动态分支预测。内部保存一个表，记录最近的以此转移的情况，然后根据此情况转移 ","wordCount":"524","inLanguage":"en","datePublished":"2023-02-21T16:29:43Z","dateModified":"2023-02-21T16:29:43Z","author":{"@type":"Person","name":"Chan"},"mainEntityOfPage":{"@type":"WebPage","@id":"/posts/principles-of-computer-organization/%E7%AC%AC5%E7%AB%A0-%E4%B8%AD%E5%A4%AE%E5%A4%84%E7%90%86%E5%99%A8/"},"publisher":{"@type":"Organization","name":"Home","logo":{"@type":"ImageObject","url":"%3Clink%20/%20abs%20url%3E"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href accesskey=h title="Cheyne16's Blog (Alt + H)"><img src=/apple-touch-icon.png alt aria-label=logo height=35>Cheyne16's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=/categories/ title=categories><span>categories</span></a></li><li><a href=/tags/ title=tags><span>tags</span></a></li><li><a href=https://example.org title=example.org><span>example.org</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href>Home</a>&nbsp;»&nbsp;<a href=/posts/>Posts</a></div><h1 class=post-title>第5章 中央处理器</h1><div class=post-meta><span title='2023-02-21 16:29:43 +0000 UTC'>February 21, 2023</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;524 words&nbsp;·&nbsp;Chan&nbsp;|&nbsp;<a href=https://github.com/%3cpath_to_repo%3e/content/posts/Principles%20of%20Computer%20Organization/%e7%ac%ac5%e7%ab%a0%20%e4%b8%ad%e5%a4%ae%e5%a4%84%e7%90%86%e5%99%a8.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=post-content><h1 id=中央处理器>中央处理器<a hidden class=anchor aria-hidden=true href=#中央处理器>#</a></h1><p>中央处理器</p><h2 id=cpu的功能>CPU的功能<a hidden class=anchor aria-hidden=true href=#cpu的功能>#</a></h2><ul><li>指令控制<ul><li>控制程序按照顺序执行</li></ul></li><li>操作控制<ul><li>传送不同的信号</li></ul></li><li>时间控制<ul><li>各种操作的同步</li></ul></li><li>数据加工<ul><li>算数逻辑运算</li></ul></li><li>中断处理<ul><li>对异常情况和特殊请求的处理</li></ul></li></ul><h2 id=cpu的基本组成>CPU的基本组成<a hidden class=anchor aria-hidden=true href=#cpu的基本组成>#</a></h2><h3 id=控制器与运算器>控制器与运算器<a hidden class=anchor aria-hidden=true href=#控制器与运算器>#</a></h3><ul><li>控制器<ul><li>由<strong>程序计数器PC</strong>、<strong>指令寄存器IR</strong>、<strong>指令译码器</strong>、<strong>操作控制器和时序产生器</strong>组成（不包括地址译码器）</li></ul></li><li>运算器<ul><li>由<strong>算数逻辑单元ALU</strong>、<strong>累加寄存器AC</strong>、<strong>数据缓冲寄存器DR</strong>和<strong>状态条件寄存器PSW</strong>组成</li></ul></li></ul><h3 id=重要的寄存器>重要的寄存器<a hidden class=anchor aria-hidden=true href=#重要的寄存器>#</a></h3><ul><li><p>数据缓冲寄存器</p><p>DR</p><ul><li>存放从cache读出的字或来自外部接口的字或ALU运算结果</li><li>写数据cache时也先用DR暂存</li><li>用来作为ALU运算结果和通用寄存器之间信息传送时时间上的缓冲</li><li>补偿CPU和内存、外设之间速度的差别</li></ul></li><li><p>指令寄存器</p><p>IR</p><ul><li>用来保存当前正在执行的一条指令</li><li>指令的操作码会流向指令译码器，译码后即可向控制器发出信号</li></ul></li><li><p>程序计数器</p><p>PC</p><ul><li>也叫指令计数器。用来保存<strong>下一条指令</strong>的地址</li><li>程序开始执行前先把程序的第一条指令所在地址置入PC</li><li>CPU会自行修改PC的值</li></ul></li><li><p>地址寄存器</p><p>AR</p><ul><li>用来保存当前处理器访问的数据cache中的单元地址</li></ul></li><li><p>通用寄存器R0-R3</p><ul><li>不同的计算机的通用寄存器数量不同。可以几十上百个。教学举例通常使用四个</li><li>为ALU提供暂存数据的工作区</li><li>其中的累加寄存器<strong>AC</strong>暂存ALU的运算结果</li></ul></li><li><p>状态条件寄存器</p><p>PSW</p><ul><li>根据算数结果、逻辑指令等信息得到了状态条件</li><li>包括运算结果进位标志C，运算结果溢出标志V，运算结果为0表示Z，最算结果为负标志N</li><li>每个标志位由一个触发器保存</li><li>保存中断和系统工作状态等信息</li></ul></li></ul><h4 id=cpu的寄存器中>CPU的寄存器中<a hidden class=anchor aria-hidden=true href=#cpu的寄存器中>#</a></h4><ul><li>对用户透明的（不可见的）：存储器地址寄存器、存储器数据寄存器、指令寄存器</li><li>可见的：通用寄存器、程序状态寄存器、程序计数器</li></ul><h3 id=数据通路>数据通路<a hidden class=anchor aria-hidden=true href=#数据通路>#</a></h3><p>各寄存器之间、寄存器与ALU之间传送数据的通路称为数据通路。信息从哪里出发，中间经过哪个寄存器或多路开关，最后传送到哪个寄存器，都要加以控制。</p><p>在各寄存器之间建立数据通路的任务由<strong>操作控制器</strong>完成</p><h3 id=操作控制器>操作控制器<a hidden class=anchor aria-hidden=true href=#操作控制器>#</a></h3><p>根据指令操作码和时序信号，产生各种操作控制信号，以便正确地建立数据通路</p><p>根据设计方法不同，操作控制器可以分为</p><ul><li>时序逻辑型 - 使用时序逻辑技术实现，称为<strong>硬布线控制器</strong></li><li>存储逻辑型 - 使用存储逻辑实现，称为<strong>微程序控制器</strong></li></ul><h3 id=时序产生器>时序产生器<a hidden class=anchor aria-hidden=true href=#时序产生器>#</a></h3><p>对各种操作信号进行时间上先后顺序的控制</p><h2 id=指令周期>指令周期<a hidden class=anchor aria-hidden=true href=#指令周期>#</a></h2><h3 id=基本概念>基本概念<a hidden class=anchor aria-hidden=true href=#基本概念>#</a></h3><p>冯诺依曼机，即存储程序式计算机，在程序运行前需要把程序和数据放入内存</p><p>执行程序流程：</p><ol><li>把程序首地址送入PC</li><li>从内存cache中取指，执行，并形成下一条指令的地址</li><li>自动执行直到程序的最后一条指令</li></ol><p>也就是“取指-执行”的循环</p><p><strong>指令周期</strong>是指“<strong>取指令、分析指令并执行指令所需的总时间</strong>”</p><p>由于各种指令功能不同，所以各种指令的周期长度可能不同</p><p>三个周期：</p><ul><li><strong>时钟周期</strong>，处理操作的基本单位，也称为节拍脉冲或T周期</li><li><strong>CPU周期</strong>，也称<strong>机器周期</strong>，指<strong>从内存中读取一个指令字（即指令）的最短时间</strong>，通常包含若干个时钟周期</li><li><strong>指令周期通常包含若干个CPU周期</strong>、取出并执行需要的时间</li></ul><p><img loading=lazy src=https://discretetom.github.io/_nuxt/img/1134c81.png alt=5-1></p><h3 id=rr型指令举例---mov指令的指令周期>RR型指令举例 - MOV指令的指令周期<a hidden class=anchor aria-hidden=true href=#rr型指令举例---mov指令的指令周期>#</a></h3><p><strong>不同的CPU结构会影响指令周期</strong></p><p>本例中使用的CPU模型如下</p><p><img loading=lazy src=https://discretetom.github.io/_nuxt/img/61460c3.png alt=5-4></p><p>MOV的指令周期如下：</p><p><img loading=lazy src=https://discretetom.github.io/_nuxt/img/08b431f.png alt=5-2></p><p>MOV指令是RR型指令，只有取指需要访存，所以只要两个CPU周期即可。一个CPU周期取指（回忆-CPU周期是从内存取出一个指令字的最短时间），另一个周期执行。执行不需要访存，寄存器之间的操作非常迅速，所以会在一个CPU周期内完成。而指令周期的最小单位是CPU周期，所以MOV需要两个完整的CPU周期</p><p>取指周期图示：</p><p><img loading=lazy src=https://discretetom.github.io/_nuxt/img/61460c3.png alt=5-4></p><p>取指阶段：</p><ol><li>根据PC从内存中取出指令</li><li>指令译码或测试（逻辑电路而非时序电路，不花费时间）</li><li>PC+1</li></ol><p>对应的操作:</p><ul><li>PC -> ABUS(I)</li><li>IBUS ->IR</li><li>PC + 1</li></ul><h3 id=rs型指令举例---lad指令的指令周期>RS型指令举例 - LAD指令的指令周期<a hidden class=anchor aria-hidden=true href=#rs型指令举例---lad指令的指令周期>#</a></h3><p>LAD指令为RS型指令，需要三个CPU周期</p><p><img loading=lazy src=https://discretetom.github.io/_nuxt/img/df782a0.png alt=5-3></p><ol><li><strong>所有指令的取指阶段都是一样的</strong>，取指花费一个CPU周期</li><li>把指令中的地址字段交给地址寄存器AR。此过程不访存，花费不到一个CPU周期，但是数据通过DBUS到达AR，占用了总线，所以按照一个CPU周期计算</li><li><strong>从内存中</strong>取出数据到DR（回忆-DR为数据缓冲寄存器，几乎一切数据都要经过DR再到目的地），通过DBUS，需要一个完整的CPU周期</li><li>DR把数据交给通用寄存器R0，不访存，不使用总线，花费不到一个CPU周期，可以和上面的操作一起完成</li></ol><h3 id=各指令的指令周期小结>各指令的指令周期小结<a hidden class=anchor aria-hidden=true href=#各指令的指令周期小结>#</a></h3><p>判断一个过程是否占用一整个CPU周期，判断依据1：有没有访存，因为每次访存会消耗一个CPU周期；判断依据2：有没有多个操作占用同一条总线。如果有则把两个操作放置到两个CPU周期中。无总线冲突且不访存的操作可以和前面的访存操作合并在一个CPU周期中</p><p>取指操作中在把指令放入指令寄存器/指令译码器之后要等待下一个CPU周期来执行指令</p><h3 id=方框图语言>方框图语言<a hidden class=anchor aria-hidden=true href=#方框图语言>#</a></h3><h4 id=方框图语言基础>方框图语言基础<a hidden class=anchor aria-hidden=true href=#方框图语言基础>#</a></h4><p>进行中央处理器设计时可以使用方框图语言描述一条指令的指令周期</p><ul><li>方框 - <strong>代表一个CPU周期</strong>，方框中的内容表示此CPU周期内数据通路的操作或某些控制操作。</li><li>菱形 - 用来表示某种判别或测试，在时间上依附于前面方框的CPU周期。菱形自身不占用CPU周期</li></ul><p>本CPU结构下的五条经典指令的指令周期：</p><p><img loading=lazy src=https://discretetom.github.io/_nuxt/img/736612e.png alt=5-5></p><p>指令执行结束之后的曲线为<strong>公操作符号</strong>，表示指令已经执行完毕，转入<strong>公操作</strong>，公操作为CPU在指令执行结束后执行的一系列操作，如中断处理等</p><h3 id=例题>例题<a hidden class=anchor aria-hidden=true href=#例题>#</a></h3><p><img loading=lazy src=https://discretetom.github.io/_nuxt/img/1a9b10f.png alt=5-6></p><p>在这样的一个双总线结构的CPU中，画出"ADD R2, R0"指令完成<code>(R0)+(R2)->R0</code>操作的指令周期图</p><p>因为此CPU中的双总线结构，几乎每两个相邻的操作都有总线冲突，所以每个操作都需要一个CPU周期</p><p>指令周期流程图如下（下图种的一个方框不代表一个cpu周期，它只是将一个CPU周期内的指令放在了一起，不是方框图，取指令和执行指令分别占用一个CPU周期；方框内为操作，方框右侧为此CPU周期内为了实现操作而发出的控制信号）：</p><p><img loading=lazy src=https://discretetom.github.io/_nuxt/img/6c8dcc4.png alt=5-7></p><h2 id=时序产生器-1>时序产生器<a hidden class=anchor aria-hidden=true href=#时序产生器-1>#</a></h2><p>如何识别二进制码是指令还是数据？如果是取指阶段读出的那就是指令，如果是执行阶段读出的那就是数据。被送往指令寄存器的是指令，被送往运算器的是数据</p><h3 id=时序信号产生器的组成>时序信号产生器的组成<a hidden class=anchor aria-hidden=true href=#时序信号产生器的组成>#</a></h3><ul><li>时钟源</li><li>环形脉冲发生器</li><li>节拍脉冲和读写时序的译码</li><li>启停控制逻辑</li></ul><p>结构框图：</p><p><img loading=lazy src=https://discretetom.github.io/_nuxt/img/f195ecd.png alt=5-8></p><p>输出信号：</p><p><img loading=lazy src=https://discretetom.github.io/_nuxt/img/271bb5f.png alt=5-9></p><h3 id=启停控制逻辑的控制方式>启停控制逻辑的控制方式<a hidden class=anchor aria-hidden=true href=#启停控制逻辑的控制方式>#</a></h3><ul><li><strong>同步控制方式</strong></li></ul><p>任何情况下各指令执行时所需的机器周期数和时钟周期数固定不变</p><ul><li><strong>异步控制方式</strong></li></ul><p>每条指令或操作按需占用时间。需要使用<strong>应答机制</strong>。没有时间上的浪费，但是控制复杂</p><ul><li><strong>联合控制方式</strong></li></ul><p>结合以上两种控制方式。大部分操作序列安排在固定的机器周期中。个别的难以确定的操作则以执行部件的“应答”信号作为操作的结束</p><h2 id=微程序控制器>微程序控制器<a hidden class=anchor aria-hidden=true href=#微程序控制器>#</a></h2><h3 id=基本概念-1>基本概念<a hidden class=anchor aria-hidden=true href=#基本概念-1>#</a></h3><p>使用软件的思想设计硬件</p><p>与硬布线控制器相比较，具有规整性、灵活性、可维护性等一系列优点</p><p>基本思想：把每条<strong>指令</strong>视为一个<strong>微程序</strong>，每个微程序由一系列<strong>微指令</strong>组成，每个微指令由一系列<strong>微命令</strong>。所有微程序存储在**控制存储器（只读）**中</p><p>每条微命令对应一个<strong>微操作</strong>，即一个信号的变化</p><h3 id=微操作分类>微操作分类<a hidden class=anchor aria-hidden=true href=#微操作分类>#</a></h3><ul><li>相容性操作 - 可以在同一个CPU周期内并行执行的微操作</li><li>相斥性操作 - 不能同时或在同一个CPU周期内并行执行的微操作</li></ul><h3 id=微指令>微指令<a hidden class=anchor aria-hidden=true href=#微指令>#</a></h3><p>在一个CPU中期内一组实现一定操作的微命令的组合，构成一条微指令</p><p>微指令需要具备的功能：</p><ul><li>提供一条机器指令的一个步骤所需要的控制信号，以实现执行该步骤的操作功能</li><li>提供下一条微指令的地址，以便自动有序地执行微指令</li></ul><p><strong>微指令基本格式</strong>：由<strong>操作控制字段</strong>和<strong>顺序控制字段</strong>组成</p><p><img loading=lazy src=https://discretetom.github.io/_nuxt/img/9783c59.png alt=5-10></p><p>操作控制字段用来发出控制信号，每一位为一个微命令（即单个信号）。控制信号都是节拍点位信号，持续时间为一个CPU周期。<strong>只有与节拍脉冲相结合才能得到实际控制信号</strong>，即不同的信号在CPU周期内的不同时段发挥作用</p><p>顺序控制字段用来执行下一条微指令的地址。本例中的微指令后四位直接给出了下一条微指令的地址，另外两位为<strong>测试方式位</strong>。如果测试方式有效，则根据直接地址和测试方式与<strong>地址转移逻辑</strong>共同决定下一条微指令的地址。详见地址转移逻辑部分</p><h3 id=微程序控制器原理框图>微程序控制器原理框图<a hidden class=anchor aria-hidden=true href=#微程序控制器原理框图>#</a></h3><p><img loading=lazy src=https://discretetom.github.io/_nuxt/img/0fb9efc.png alt=5-11></p><ul><li>微指令寄存器<ul><li>用来存放当前微指令</li></ul></li><li>微地址寄存器<ul><li>用来存放下一条微指令的地址。类似于PC</li></ul></li><li>地址转移逻辑<ul><li>管理位地址寄存器</li><li>默认情况会把当前微指令的顺序控制字段的直接地址交给微地址寄存器</li><li>程序出现分支时根据当前微指令的测试方式位和当前状态调整微地址寄存器的内容</li></ul></li><li>控制存储器<ul><li>存放全部指令系统微程序的只读存储器</li><li>读出一条微指令并执行的总时间被称为一个<strong>微指令周期</strong></li><li>在串行方式工作的微程序控制器中，微指令周期就是只读存储器的工作周期</li></ul></li></ul><p>控制存储器示意图：</p><p><img loading=lazy src=https://discretetom.github.io/_nuxt/img/a29189b.png alt=5-12></p><h3 id=微指令周期与cpu周期的关系>微指令周期与CPU周期的关系<a hidden class=anchor aria-hidden=true href=#微指令周期与cpu周期的关系>#</a></h3><p>为了保证整个机器控制信号的同步，可以将一个微指令周期时间设计得恰好和CPU周期时间相等</p><p><img loading=lazy src=https://discretetom.github.io/_nuxt/img/1b9c1a3.png alt=5-13></p><p>假设一个CPU周期为0.8μs，包含四个等间隔的节拍脉冲T1-T4，每个脉冲宽度200ns，可以用T4作为读取微指令的时间，用T1-T3时间作为执行微指令的时间。这样前面600ns中ALU计算出结果后可以在最后T4的200ns中把结果打入某个寄存器，同时微程序控制器读取下一个指令</p><p><strong>使用节拍电位->节拍脉冲二级体制</strong></p><h3 id=微程序设计技术>微程序设计技术<a hidden class=anchor aria-hidden=true href=#微程序设计技术>#</a></h3><h4 id=微命令编码>微命令编码<a hidden class=anchor aria-hidden=true href=#微命令编码>#</a></h4><ul><li>直接表示法<ul><li>每一位代表一个微命令（即一个实际的控制信号）</li><li>优点 - 简单直观 输出直接用于控制</li><li>缺点 - 微指令字较长 控制存储器容量较大</li></ul></li></ul><p>直接表示法图示：</p><p><img loading=lazy src=https://discretetom.github.io/_nuxt/img/9783c59.png alt=5-10></p><ul><li>编码表示法<ul><li>把一组<strong>相斥</strong>的微命令信号组成一个小组，通过译码器移码</li><li>与直接控制法相比编码表示法可以减少微指令字的长度，但是增加了译码电路，执行速度稍慢</li><li>此法使用较为普遍</li></ul></li></ul><p>编码表示法图示：</p><p><img loading=lazy src=https://discretetom.github.io/_nuxt/img/ddc6050.png alt=5-14></p><ul><li>混合表示法<ul><li>混合以上两种表示法</li></ul></li></ul><p>混合表示法图示：</p><p><img loading=lazy src=https://discretetom.github.io/_nuxt/img/5fff0dd.png alt=5-15></p><h4 id=微地址的形成方式>微地址的形成方式<a hidden class=anchor aria-hidden=true href=#微地址的形成方式>#</a></h4><p>地址转移逻辑如何产生后继微地址</p><ul><li>计数器方式<ul><li>类似于PC</li><li>顺序执行微指令时，后继微地址由当前微地址加上一个增量来产生</li><li>非顺序执行微指令时，必须通过一些转移策略改变下址</li><li>微地址寄存器可视为计数器，顺序执行的微指令序列必须安排在控制存储器的连续单元中</li><li>特点：顺序控制字段较短，微地址产生机构简单，但是多路并行转移功能较弱，速度慢，灵活性差</li></ul></li><li>多路转移方式<ul><li>一条微指令具有多个转移分支的能力称为多路转移</li><li>微程序出现分支时，如果有若干“候选”微地址，则根据顺序控制字段中的<strong>判别测试P</strong>和<strong>状态条件标志</strong>选择其中一个微地址</li><li>状态条件有n位标志，可以实现微程序2n路转移，涉及微地址寄存器的n位</li><li>特点：能以较短的顺序控制字段配合，实现多路并行转移，灵活性好，速度快，但是地址转移逻辑需要组合逻辑方法设计</li></ul></li><li>由指令的操作码转换得到<ul><li>典型方式为查表</li><li>在ROM中存放微地址映射表，用指令的操作码作为地址进行查表，以此得到微程序的入口地址</li></ul></li></ul><p>使用多路转移方式，设计地址转移逻辑例题：微地址寄存器6位(μA5-μA0)，当需要修改其内容时，可通过某一位触发器的强制端S将其置1。有如下三种情况</p><ul><li>执行“取指”微指令后微程序按IR的OP字段(IR3-IR0)进行16路分支</li><li>执行条件转移指令微程序时，按照进位标志C的状态进行2路分支</li><li>执行某控制台指令微程序时，按IR4与IR5的状态进行4路分支</li></ul><p>请设计微地址转移逻辑</p><p>解：题中所述微程序有三种判别测试，令这三种判别测试分别为P1、P2、P3</p><ul><li>当P1生效时根据IR3-IR0修改μA3-μA0（其实可以任选4位进行修改）</li><li>当P2生效时根据进位标志C修改μA0（任选1位即可）</li><li>当P3生效时根据IR5和IR4修改μA5和μA4（任选两位即可）</li></ul><p>还要考虑时钟因素，假设CPU周期的最后一个节拍脉冲为T4，此时各运算已结束，得到了各个状态。则地址转移逻辑如下</p><ul><li>μA5 = P3 IR5 T4</li><li>μA4 = P3 IR4 T4</li><li>μA3 = P1 IR3 T4</li><li>μA2 = P1 IR2 T4</li><li>μA1 = P1 IR1 T4</li><li>μA0 = P1 IR0 T4 + P2 C T4</li></ul><h4 id=微指令格式>微指令格式<a hidden class=anchor aria-hidden=true href=#微指令格式>#</a></h4><ul><li>水平型微指令<ul><li>一次能定义并执行多个并行操作微命令的微指令</li><li>按空客管制制度按·控制字段的编码方式不同可以分为<ul><li>全水平型（不译码法）微指令</li><li>字段译码法水平型微指令</li><li>直接和译码相混合的水平型微指令</li></ul></li></ul></li></ul><p>水平型微指令示意图：</p><p><img loading=lazy src=https://discretetom.github.io/_nuxt/img/832c35f.png alt=5-16></p><ul><li>垂直型微指令<ul><li>微指令中设置<strong>微操作码</strong>字段，由微操作码规定微指令的功能</li><li>结构类似于机器指令的结构，有操作码，在一条微指令中只有1-2个微命令，每条微指令的功能简单</li><li>实现一条机器指令的微程序比水平型微指令编写的微程序长得多</li><li>特点：微程序长而微指令短</li></ul></li></ul><p>垂直型微指令举例：</p><ul><li>寄存器-寄存器传送型微指令</li></ul><p><img loading=lazy src=https://discretetom.github.io/_nuxt/img/126db1c.png alt=5-17></p><ul><li>运算控制型微指令</li></ul><p><img loading=lazy src=https://discretetom.github.io/_nuxt/img/6d32240.png alt=5-18></p><ul><li>主存访问型微指令</li></ul><p><img loading=lazy src=https://discretetom.github.io/_nuxt/img/a23604c.png alt=5-19></p><ul><li>条件转移型微指令</li></ul><p><img loading=lazy src=https://discretetom.github.io/_nuxt/img/d231305.png alt=5-20></p><p>水平型微指令与垂直型微指令的比较：</p><ul><li>水平型微指令并行操作能力强，效率高，灵活性强</li><li>水平型微指令执行一条指令的时间更短</li><li>水平型微指令难以掌握。垂直型微指令与机器指令类似，相对易于掌握</li></ul><h2 id=硬布线控制器>硬布线控制器<a hidden class=anchor aria-hidden=true href=#硬布线控制器>#</a></h2><h3 id=基础>基础<a hidden class=anchor aria-hidden=true href=#基础>#</a></h3><p>也叫<strong>组合逻辑控制器</strong>，被当前RISC计算机和高性能计算机普遍采用</p><p>控制部件为产生固定时序控制信号的逻辑电路</p><p>特点：</p><ul><li>形成控制信号的传输延迟少，系统运行速度快</li><li>设计控制CPU的时序控制信号的逻辑较复杂</li><li>与微程序控制相比，硬布线控制速度快</li></ul><h3 id=结构>结构<a hidden class=anchor aria-hidden=true href=#结构>#</a></h3><p><img loading=lazy src=https://discretetom.github.io/_nuxt/img/102fe21.png alt=5-21></p><p>树型逻辑网络拥有三个输入：指令译码器的译码输出、结果反馈信息和节拍电位/节拍脉冲发生器。树型逻辑网络内部为组合逻辑电路，根据输入调整输出，<strong>输出即为微操作控制信号</strong></p><p>与微程序控制器不同的是，时序产生器除了产生节拍脉冲，还需要产生<strong>节拍电位信号</strong>用来控制流程</p><p>所以硬布线控制器的<strong>时序信号有三级</strong>：<strong>主状态周期->节拍电位->节拍脉冲</strong></p><h3 id=硬布线控制器的指令周期流程>硬布线控制器的指令周期流程<a hidden class=anchor aria-hidden=true href=#硬布线控制器的指令周期流程>#</a></h3><p>以下图为例。此图使用的CPU模型还是前面的那个模型</p><p><img loading=lazy src=https://discretetom.github.io/_nuxt/img/b2bca57.png alt=5-22></p><p>时序产生器产生<strong>节拍电位信号</strong>M1、M2和M3用来控制当前处于流程中的哪一个阶段，也就是各个微操作的先后顺序</p><p>比如某控制信号C0在以下情况下被激活：</p><ul><li>节拍电位为M1时被激活</li><li>节拍电位为M3且指令译码器发出的指令信号为ADD/LAD/AND</li></ul><p>那么在树型逻辑网络里面C0的表达式就是<code>C0 = M1 + M3(ADD + LAD + AND)</code></p><p>如果使用同步控制方式，则所有指令都要有M1-M3三个阶段，但是像MOV这种指令在M3阶段没有任何操作，会导致时间的浪费。为了改进，可以使一些指令跳过一些节拍，如MOV指令进行M2节拍之后就结束。相应的节拍信号发生器的电路会更复杂</p><p>与硬布线控制器相比，微程序控制器的控制信号可以复用（这也导致了速度比较慢），而硬布线完全使用布尔表达式实现，每个输出都有自己的表达式控制，几乎不能复用。可以使用布尔表达式化简</p><h3 id=硬布线控制器的设计>硬布线控制器的设计<a hidden class=anchor aria-hidden=true href=#硬布线控制器的设计>#</a></h3><ol><li>分析指令，列出所有执行的方框图</li><li>对流程进行划分，分隔到不同的时钟周期和节拍电位</li><li>总结表达式</li></ol><p>举例：设计如图所示模型机的控制器，假设该模型机的系统只有如下5条指令，使用硬布线控制</p><p><img loading=lazy src=https://discretetom.github.io/_nuxt/img/ecdfd84.png alt=5-23></p><table><thead><tr><th>指令助记符</th><th>指令</th><th>功能</th></tr></thead><tbody><tr><td>CLA</td><td>清零指令</td><td>0 -> AC</td></tr><tr><td>ADD AC, M</td><td>加法指令</td><td>(AC) + (M) -> AC</td></tr><tr><td>STA M</td><td>存数指令</td><td>(AC) -> M</td></tr><tr><td>JMP m</td><td>跳转指令</td><td>m -> PC</td></tr><tr><td>NOP</td><td>空指令</td><td>延时</td></tr></tbody></table><ul><li>分析指令，画出框图</li></ul><p><img loading=lazy src=https://discretetom.github.io/_nuxt/img/5f59434.png alt=5-24></p><p>因为总线数量受限，取指阶段的三个操作需要使用同一个总线，所以被拆分在了三个节拍脉冲中</p><ul><li>对流程进行划分，划分到不同的时钟周期和节拍电位</li></ul><p><img loading=lazy src=https://discretetom.github.io/_nuxt/img/539506f.png alt=5-25></p><p>给操作分配时钟周期T和节拍电位M</p><p><strong>访存操作需要两个时钟周期</strong>，其他操作1个时钟周期。<strong>每个节拍电位中可以有数量不等的时钟周期</strong>。读指令自身一个节拍电位</p><ul><li>总结表达式</li></ul><p>从图中找出所有的微操作，并命名如下表</p><p><img loading=lazy src=https://discretetom.github.io/_nuxt/img/795c694.png alt=5-26></p><p>按照流程图给出表达式。<strong>注意表达式中同时含有时钟周期和节拍电位</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>C0: PC -&gt; AR -&gt; <span class=nv>ABUS</span> <span class=o>=</span> M1 T1
</span></span><span class=line><span class=cl>C1: PC + <span class=m>1</span> -&gt; <span class=nv>PC</span> <span class=o>=</span> M1 T4
</span></span><span class=line><span class=cl>C2: IR -&gt; <span class=nv>PC</span> <span class=o>=</span> M2 T1 JMP
</span></span><span class=line><span class=cl>C3: IR -&gt; AR -&gt; <span class=nv>ABUS</span> <span class=o>=</span> M2 T1<span class=o>(</span>ADD + STA<span class=o>)</span>
</span></span><span class=line><span class=cl>C4: DR -&gt; <span class=nv>IR</span> <span class=o>=</span> M1 T4
</span></span><span class=line><span class=cl>C5: DR -&gt; <span class=nv>ALU</span> <span class=o>=</span> M3 T3 ADD
</span></span><span class=line><span class=cl>C6: DR -&gt; <span class=nv>DBUS</span> <span class=o>=</span> M3<span class=o>(</span>T2 + T3<span class=o>)</span>STA
</span></span><span class=line><span class=cl>C7: DBUS -&gt; <span class=nv>DR</span> <span class=o>=</span> M1<span class=o>(</span>T2 + T3<span class=o>)</span> + M3<span class=o>(</span>T1 + T2<span class=o>)</span>ADD
</span></span><span class=line><span class=cl>C8: AC -&gt; <span class=nv>DR</span> <span class=o>=</span> M3 T1 STA
</span></span><span class=line><span class=cl>C9: AC -&gt; <span class=nv>ALU</span> <span class=o>=</span> M3 T3 ADD
</span></span><span class=line><span class=cl>C10: ALU -&gt; <span class=nv>AC</span> <span class=o>=</span> M3 T3 ADD
</span></span><span class=line><span class=cl>C11: <span class=m>0</span> -&gt; <span class=nv>AC</span> <span class=o>=</span> M2 T1 CLA
</span></span></code></pre></div><h2 id=流水cpu>流水CPU<a hidden class=anchor aria-hidden=true href=#流水cpu>#</a></h2><h3 id=流水cpu结构>流水CPU结构<a hidden class=anchor aria-hidden=true href=#流水cpu结构>#</a></h3><ul><li>指令部件</li><li>指令队列FIFO</li><li>执行部件</li></ul><p><img loading=lazy src=https://discretetom.github.io/_nuxt/img/444543d.png alt=5-27></p><h3 id=原理>原理<a hidden class=anchor aria-hidden=true href=#原理>#</a></h3><ul><li>在流水线(Pipeline)中必须是<strong>连续</strong>的任务，只有不断提供任务才能充分发挥流水线的效率</li><li>把一个任务分解为几个有联系的子任务，每个子任务由一个专门的功能部件实现</li><li><strong>流水线中各段时间应尽量相等</strong>，否则会引起堵塞、断流现象</li><li>流水线需要装入时间和排空时间。流水线完全充满时才能充分发挥效率</li></ul><h3 id=指令处理的分解>指令处理的分解<a hidden class=anchor aria-hidden=true href=#指令处理的分解>#</a></h3><ul><li>IF(Instruction Fetch)取指</li><li>ID(Instruction Decode)译码</li><li>EX(Execution)执行</li><li>WB(Write Back)写回</li></ul><p>四级指令流水线</p><p><img loading=lazy src=https://discretetom.github.io/_nuxt/img/0d781df.png alt=5-28></p><h3 id=时空图>时空图<a hidden class=anchor aria-hidden=true href=#时空图>#</a></h3><p>非流水线时空图：</p><p><img loading=lazy src=https://discretetom.github.io/_nuxt/img/f6a848e.png alt=5-29></p><p>一条指令执行完毕后下一条指令才能开始执行，每隔四个时钟周期才会有一个输出结果</p><p>标量流水线时空图：</p><p><img loading=lazy src=https://discretetom.github.io/_nuxt/img/ed6509d.png alt=5-30></p><p>上一条指令与下一条指令存在<strong>时间</strong>上的重叠，每一个时钟周期就能输出一个结果</p><p>超标量流水线时空图：</p><p><img loading=lazy src=https://discretetom.github.io/_nuxt/img/81baa42.png alt=5-31></p><p>在标量流水线基础上增加<strong>空间</strong>并行技术，一次执行多条指令</p><p>线性流水线有三个阶段：</p><p><img loading=lazy src=https://discretetom.github.io/_nuxt/img/292e768.png alt=5-32></p><h3 id=性能指标>性能指标<a hidden class=anchor aria-hidden=true href=#性能指标>#</a></h3><ul><li>加速比(Speedup Ratio)<ul><li>衡量<strong>不使用流水线</strong>和<strong>使用流水线</strong>完成同样任务所用的<strong>时间比</strong></li><li>k级流水线时钟周期t，则不使用流水线完成n各任务所需时间T0=nkt，使用k级流水线完成n个<strong>连续任务</strong>所需时间为Tk=(k+n-1)t</li><li>显然当n远大于k时最大加速比为k</li></ul></li><li>吞吐率<ul><li><strong>单位时间完成的任务数</strong></li><li>n为任务数，Tk为完成n各任务的时间，则吞吐率TP = n / Tk</li><li>显然n趋近无穷时最大吞吐率为1/t</li></ul></li></ul><h3 id=流水线冲突>流水线冲突<a hidden class=anchor aria-hidden=true href=#流水线冲突>#</a></h3><ul><li><strong>资源相关</strong></li></ul><p>如流水线的不同部分在同一时钟周期同时访问内存。假设某流水线分为五部分：取指、译码、执行、取存、写回，那么在流水线执行时取指和取存都会访问存储器，这就导致了冲突</p><p>解决方案</p><ol><li>某条指令在冲突时停顿一拍</li><li>分离数据与指令的存储</li></ol><ul><li><strong>数据相关</strong></li></ul><p>流水线的不同节拍同时需要读写一个地址的数据。如运算结果在第3拍需要写入内存，而后面的操作需要用到这个内存。可能会发生“先读后写”冲突。注意<strong>同时读是不冲突的</strong></p><p>为了解决冲突，流水CPU设置了许多<strong>结果缓存寄存器</strong>，保存结果给后面的指令<strong>直接使用</strong></p><ul><li><strong>控制相关</strong></li></ul><p>由转移指令引起。因为流水线不知道判定结果，不知道应该顺序执行还是转移执行。常用处理技术：</p><ol><li>延迟转移 - “先执行再转移”。在条件转移之前已经有若干个指令进入流水线了，把这些指令执行完毕，如果正好是目标指令则没有浪费时间</li><li>分支预测 - 猜测分支的方向<ol><li>静态分支预测。硬件固定的预测方式，如总是转移或总是不转移</li><li>动态分支预测。内部保存一个表，记录最近的以此转移的情况，然后根据此情况转移</li></ol></li></ol></div><footer class=post-footer><ul class=post-tags><li><a href=/tags/principles-of-computer-organization/>Principles of Computer Organization</a></li></ul><nav class=paginav><a class=prev href=/posts/principles-of-computer-organization/%E7%AC%AC4%E7%AB%A0-%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/><span class=title>« Prev</span><br><span>第4章 指令系统</span></a>
<a class=next href=/posts/principles-of-computer-organization/%E7%AC%AC6%E7%AB%A0-%E6%80%BB%E7%BA%BF%E7%B3%BB%E7%BB%9F/><span class=title>Next »</span><br><span>第6章 总线系统</span></a></nav><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share 第5章 中央处理器 on twitter" href="https://twitter.com/intent/tweet/?text=%e7%ac%ac5%e7%ab%a0%20%e4%b8%ad%e5%a4%ae%e5%a4%84%e7%90%86%e5%99%a8&url=%2fposts%2fprinciples-of-computer-organization%2f%25E7%25AC%25AC5%25E7%25AB%25A0-%25E4%25B8%25AD%25E5%25A4%25AE%25E5%25A4%2584%25E7%2590%2586%25E5%2599%25A8%2f&hashtags=PrinciplesofComputerOrganization"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share 第5章 中央处理器 on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=%2fposts%2fprinciples-of-computer-organization%2f%25E7%25AC%25AC5%25E7%25AB%25A0-%25E4%25B8%25AD%25E5%25A4%25AE%25E5%25A4%2584%25E7%2590%2586%25E5%2599%25A8%2f&title=%e7%ac%ac5%e7%ab%a0%20%e4%b8%ad%e5%a4%ae%e5%a4%84%e7%90%86%e5%99%a8&summary=%e7%ac%ac5%e7%ab%a0%20%e4%b8%ad%e5%a4%ae%e5%a4%84%e7%90%86%e5%99%a8&source=%2fposts%2fprinciples-of-computer-organization%2f%25E7%25AC%25AC5%25E7%25AB%25A0-%25E4%25B8%25AD%25E5%25A4%25AE%25E5%25A4%2584%25E7%2590%2586%25E5%2599%25A8%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share 第5章 中央处理器 on reddit" href="https://reddit.com/submit?url=%2fposts%2fprinciples-of-computer-organization%2f%25E7%25AC%25AC5%25E7%25AB%25A0-%25E4%25B8%25AD%25E5%25A4%25AE%25E5%25A4%2584%25E7%2590%2586%25E5%2599%25A8%2f&title=%e7%ac%ac5%e7%ab%a0%20%e4%b8%ad%e5%a4%ae%e5%a4%84%e7%90%86%e5%99%a8"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share 第5章 中央处理器 on facebook" href="https://facebook.com/sharer/sharer.php?u=%2fposts%2fprinciples-of-computer-organization%2f%25E7%25AC%25AC5%25E7%25AB%25A0-%25E4%25B8%25AD%25E5%25A4%25AE%25E5%25A4%2584%25E7%2590%2586%25E5%2599%25A8%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share 第5章 中央处理器 on whatsapp" href="https://api.whatsapp.com/send?text=%e7%ac%ac5%e7%ab%a0%20%e4%b8%ad%e5%a4%ae%e5%a4%84%e7%90%86%e5%99%a8%20-%20%2fposts%2fprinciples-of-computer-organization%2f%25E7%25AC%25AC5%25E7%25AB%25A0-%25E4%25B8%25AD%25E5%25A4%25AE%25E5%25A4%2584%25E7%2590%2586%25E5%2599%25A8%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share 第5章 中央处理器 on telegram" href="https://telegram.me/share/url?text=%e7%ac%ac5%e7%ab%a0%20%e4%b8%ad%e5%a4%ae%e5%a4%84%e7%90%86%e5%99%a8&url=%2fposts%2fprinciples-of-computer-organization%2f%25E7%25AC%25AC5%25E7%25AB%25A0-%25E4%25B8%25AD%25E5%25A4%25AE%25E5%25A4%2584%25E7%2590%2586%25E5%2599%25A8%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></div></footer></article></main><footer class=footer><span>&copy; 2023 <a href>Home</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>