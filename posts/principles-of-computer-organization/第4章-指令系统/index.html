<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>第4章 指令系统 | Home</title><meta name=keywords content="Principles of Computer Organization"><meta name=description content="基本概念 **指令(Instruction)**指计算机执行某种操作的命令
**指令系统（ISA Instruction Set Architecture）**也称 指令集架构，一台计算机中所有机器指令的集合
高级语言 - 语句和用法与具体机器的指令系统无关 低级语言 - 面向机器的语言，和具体机器的指令系统密切相关 比较 高级语言 低级语言 通用算法 有 有 语言规则 少 多 编程需要硬件知识 不需要 需要 独立于机器 独立 不独立 编程难易度 易 难 编程时间 短 长 程序执行时间 长 短 编译过程中对计算机资源的占用 多 少 指令格式 基础 指令字（简称指令），即表示一条指令的机器字（机器码）
指令的构成：
操作码字段 - 定义操作 操作数地址字段 - 指定操作数的地址 操作码：表示指令对应的操作。操作码字段的长度取决于计算机指令系统的规模。如某指令系统有8条（种）指令，操作码只需3位即可。指令字中的操作码长度可以使固定的也可以是变长的
按操作数地址数量分类 按照指令中操作数（地址）的个数X（类似于高级语言中函数的参数），可以把指令称为X操作数指令或X地址指令
通常指令可以根据操作数地址数量划分为：
三地址指令 二地址指令 一地址指令 零地址指令 零地址指令：只有操作码，没有地址码
一地址指令：称为单操作数指令，指令中只有一个操作数或者是指令默认以运算器中累加寄存器AC中的数为操作数1，操作结果又放回累加寄存器AC中，类似于高级语言函数中的默认参数。符号表达为(AC) OP (A) -> AC，其中OP表示操作，AC和A表示地址。AC为累加寄存器地址。地址加括号表示取地址中的数据，类似于C语言中对指针的解引用
二地址指令：称为双操作数指令。两个地址码表明两个操作数的地址，结果存放在其中一个地址处。符号表达为(A1) OP (A2) -> A1
三地址指令：指令字中有三个操作数地址。符号表达为(A1) OP (A2) -> A3。A1为被操作数地址或源操作数地址。A1为操作数地址或终点操作数地址。A3为存放结果的地址"><meta name=author content="Chan"><link rel=canonical href=/posts/principles-of-computer-organization/%E7%AC%AC4%E7%AB%A0-%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.6a98292fb8fa8cf0f3ba4042d4b75515c04267550f3ad49ff6271b5af9562443.css integrity="sha256-apgpL7j6jPDzukBC1LdVFcBCZ1UPOtSf9icbWvlWJEM=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-123-45","auto"),ga("send","pageview"))</script><meta property="og:title" content="第4章 指令系统"><meta property="og:description" content="基本概念 **指令(Instruction)**指计算机执行某种操作的命令
**指令系统（ISA Instruction Set Architecture）**也称 指令集架构，一台计算机中所有机器指令的集合
高级语言 - 语句和用法与具体机器的指令系统无关 低级语言 - 面向机器的语言，和具体机器的指令系统密切相关 比较 高级语言 低级语言 通用算法 有 有 语言规则 少 多 编程需要硬件知识 不需要 需要 独立于机器 独立 不独立 编程难易度 易 难 编程时间 短 长 程序执行时间 长 短 编译过程中对计算机资源的占用 多 少 指令格式 基础 指令字（简称指令），即表示一条指令的机器字（机器码）
指令的构成：
操作码字段 - 定义操作 操作数地址字段 - 指定操作数的地址 操作码：表示指令对应的操作。操作码字段的长度取决于计算机指令系统的规模。如某指令系统有8条（种）指令，操作码只需3位即可。指令字中的操作码长度可以使固定的也可以是变长的
按操作数地址数量分类 按照指令中操作数（地址）的个数X（类似于高级语言中函数的参数），可以把指令称为X操作数指令或X地址指令
通常指令可以根据操作数地址数量划分为：
三地址指令 二地址指令 一地址指令 零地址指令 零地址指令：只有操作码，没有地址码
一地址指令：称为单操作数指令，指令中只有一个操作数或者是指令默认以运算器中累加寄存器AC中的数为操作数1，操作结果又放回累加寄存器AC中，类似于高级语言函数中的默认参数。符号表达为(AC) OP (A) -> AC，其中OP表示操作，AC和A表示地址。AC为累加寄存器地址。地址加括号表示取地址中的数据，类似于C语言中对指针的解引用
二地址指令：称为双操作数指令。两个地址码表明两个操作数的地址，结果存放在其中一个地址处。符号表达为(A1) OP (A2) -> A1
三地址指令：指令字中有三个操作数地址。符号表达为(A1) OP (A2) -> A3。A1为被操作数地址或源操作数地址。A1为操作数地址或终点操作数地址。A3为存放结果的地址"><meta property="og:type" content="article"><meta property="og:url" content="/posts/principles-of-computer-organization/%E7%AC%AC4%E7%AB%A0-%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/"><meta property="og:image" content="%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-02-21T16:29:43+00:00"><meta property="article:modified_time" content="2023-02-21T16:29:43+00:00"><meta property="og:site_name" content="Chancellor16's Blog"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="第4章 指令系统"><meta name=twitter:description content="基本概念 **指令(Instruction)**指计算机执行某种操作的命令
**指令系统（ISA Instruction Set Architecture）**也称 指令集架构，一台计算机中所有机器指令的集合
高级语言 - 语句和用法与具体机器的指令系统无关 低级语言 - 面向机器的语言，和具体机器的指令系统密切相关 比较 高级语言 低级语言 通用算法 有 有 语言规则 少 多 编程需要硬件知识 不需要 需要 独立于机器 独立 不独立 编程难易度 易 难 编程时间 短 长 程序执行时间 长 短 编译过程中对计算机资源的占用 多 少 指令格式 基础 指令字（简称指令），即表示一条指令的机器字（机器码）
指令的构成：
操作码字段 - 定义操作 操作数地址字段 - 指定操作数的地址 操作码：表示指令对应的操作。操作码字段的长度取决于计算机指令系统的规模。如某指令系统有8条（种）指令，操作码只需3位即可。指令字中的操作码长度可以使固定的也可以是变长的
按操作数地址数量分类 按照指令中操作数（地址）的个数X（类似于高级语言中函数的参数），可以把指令称为X操作数指令或X地址指令
通常指令可以根据操作数地址数量划分为：
三地址指令 二地址指令 一地址指令 零地址指令 零地址指令：只有操作码，没有地址码
一地址指令：称为单操作数指令，指令中只有一个操作数或者是指令默认以运算器中累加寄存器AC中的数为操作数1，操作结果又放回累加寄存器AC中，类似于高级语言函数中的默认参数。符号表达为(AC) OP (A) -> AC，其中OP表示操作，AC和A表示地址。AC为累加寄存器地址。地址加括号表示取地址中的数据，类似于C语言中对指针的解引用
二地址指令：称为双操作数指令。两个地址码表明两个操作数的地址，结果存放在其中一个地址处。符号表达为(A1) OP (A2) -> A1
三地址指令：指令字中有三个操作数地址。符号表达为(A1) OP (A2) -> A3。A1为被操作数地址或源操作数地址。A1为操作数地址或终点操作数地址。A3为存放结果的地址"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"/posts/"},{"@type":"ListItem","position":3,"name":"第4章 指令系统","item":"/posts/principles-of-computer-organization/%E7%AC%AC4%E7%AB%A0-%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"第4章 指令系统","name":"第4章 指令系统","description":"基本概念 **指令(Instruction)**指计算机执行某种操作的命令\n**指令系统（ISA Instruction Set Architecture）**也称 指令集架构，一台计算机中所有机器指令的集合\n高级语言 - 语句和用法与具体机器的指令系统无关 低级语言 - 面向机器的语言，和具体机器的指令系统密切相关 比较 高级语言 低级语言 通用算法 有 有 语言规则 少 多 编程需要硬件知识 不需要 需要 独立于机器 独立 不独立 编程难易度 易 难 编程时间 短 长 程序执行时间 长 短 编译过程中对计算机资源的占用 多 少 指令格式 基础 指令字（简称指令），即表示一条指令的机器字（机器码）\n指令的构成：\n操作码字段 - 定义操作 操作数地址字段 - 指定操作数的地址 操作码：表示指令对应的操作。操作码字段的长度取决于计算机指令系统的规模。如某指令系统有8条（种）指令，操作码只需3位即可。指令字中的操作码长度可以使固定的也可以是变长的\n按操作数地址数量分类 按照指令中操作数（地址）的个数X（类似于高级语言中函数的参数），可以把指令称为X操作数指令或X地址指令\n通常指令可以根据操作数地址数量划分为：\n三地址指令 二地址指令 一地址指令 零地址指令 零地址指令：只有操作码，没有地址码\n一地址指令：称为单操作数指令，指令中只有一个操作数或者是指令默认以运算器中累加寄存器AC中的数为操作数1，操作结果又放回累加寄存器AC中，类似于高级语言函数中的默认参数。符号表达为(AC) OP (A) -\u0026gt; AC，其中OP表示操作，AC和A表示地址。AC为累加寄存器地址。地址加括号表示取地址中的数据，类似于C语言中对指针的解引用\n二地址指令：称为双操作数指令。两个地址码表明两个操作数的地址，结果存放在其中一个地址处。符号表达为(A1) OP (A2) -\u0026gt; A1\n三地址指令：指令字中有三个操作数地址。符号表达为(A1) OP (A2) -\u0026gt; A3。A1为被操作数地址或源操作数地址。A1为操作数地址或终点操作数地址。A3为存放结果的地址","keywords":["Principles of Computer Organization"],"articleBody":"基本概念 **指令(Instruction)**指计算机执行某种操作的命令\n**指令系统（ISA Instruction Set Architecture）**也称 指令集架构，一台计算机中所有机器指令的集合\n高级语言 - 语句和用法与具体机器的指令系统无关 低级语言 - 面向机器的语言，和具体机器的指令系统密切相关 比较 高级语言 低级语言 通用算法 有 有 语言规则 少 多 编程需要硬件知识 不需要 需要 独立于机器 独立 不独立 编程难易度 易 难 编程时间 短 长 程序执行时间 长 短 编译过程中对计算机资源的占用 多 少 指令格式 基础 指令字（简称指令），即表示一条指令的机器字（机器码）\n指令的构成：\n操作码字段 - 定义操作 操作数地址字段 - 指定操作数的地址 操作码：表示指令对应的操作。操作码字段的长度取决于计算机指令系统的规模。如某指令系统有8条（种）指令，操作码只需3位即可。指令字中的操作码长度可以使固定的也可以是变长的\n按操作数地址数量分类 按照指令中操作数（地址）的个数X（类似于高级语言中函数的参数），可以把指令称为X操作数指令或X地址指令\n通常指令可以根据操作数地址数量划分为：\n三地址指令 二地址指令 一地址指令 零地址指令 零地址指令：只有操作码，没有地址码\n一地址指令：称为单操作数指令，指令中只有一个操作数或者是指令默认以运算器中累加寄存器AC中的数为操作数1，操作结果又放回累加寄存器AC中，类似于高级语言函数中的默认参数。符号表达为(AC) OP (A) -\u003e AC，其中OP表示操作，AC和A表示地址。AC为累加寄存器地址。地址加括号表示取地址中的数据，类似于C语言中对指针的解引用\n二地址指令：称为双操作数指令。两个地址码表明两个操作数的地址，结果存放在其中一个地址处。符号表达为(A1) OP (A2) -\u003e A1\n三地址指令：指令字中有三个操作数地址。符号表达为(A1) OP (A2) -\u003e A3。A1为被操作数地址或源操作数地址。A1为操作数地址或终点操作数地址。A3为存放结果的地址\n按照操作数的物理位置分类 操作数地址可以是存储器地址，也可以是寄存器地址。因此可以把指令分为以下三类\n存储器-存储器(SS)型指令 参与操作的数都在内存里需多次访存。慢 寄存器-寄存器(RR)型指令 操作数都在寄存器中，从寄存器取操作数，结果也存放在寄存器。速度很快，不需要访存，但需要多个寄存器 寄存器-存储器(RS)型指令。既要访问存储器又要访问寄存器的指令 指令字长度 即指令字中比特的个数\n回忆-机器字长：计算机能处理的二进制数据的位数，决定了计算机的运算精度。机器字长通常和寄存器的位数一致\n指令分类：\n单字长指令 半字长指令 双字长指令 使用多字长指令，地址的位数更多，能够提供更大的地址空间，但是CPU必须两次或多次访问内存才能取出一条指令，降低了CPU的运算速度\n定长操作码与扩展操作码（不定长操作码） 定长操作码指令格式：\n显而易见的缺点：地址长度不统一（实际计算机中地址长度是统一的），存在没有被使用的位，浪费空间\n所以诞生了变长操作码/扩展操作码：\n指令助记符 典型的指令助记符\n典型指令 助记符 加法 ADD 减法 SUB 传送 MOV 跳转 JMP 转子 JSR 存储 STR 读取 LDA 指令与数据的寻址方式 存储器既可以存放数据，也可以存放指令\n如何区分数据和指令 从时间来说\n取指令事件发生在取指周期 取数据事件发生在执行周期 从空间来说\n取出的代码是指令，一定送往指令寄存器（控制器） 取出的代码是数据，一定送往数据寄存器（运算器） 寻址方式概述 在存储器中，写入或读出操作数/指令字的方式：\n地址指定方式（几乎所有计算机都采用这种方式） 相联存储方式 堆栈存取方式 当采用地址指定方式时，形成操作数或指令地址的方式，称为寻址方式\n寻址方式：\n指令寻址方式（简单） 顺序寻址方式 跳跃寻址方式 数据（操作数）寻址方式（复杂） 隐含寻址 立即寻址 直接寻址 间接寻址 寄存器寻址 寄存器间接寻址 偏移寻址 相对寻址 基址寻址 变址寻址 段寻址 堆栈寻址 顺序指令寻址 通常执行程序时是一条指令接一条指令的顺序执行\n从内存取出第一条指令，然后执行，然后取出第二条，然后执行，然后取出第三条，然后执行。。。\n需要使用程序计数器PC（又称指令指针寄存器） 存放下一条指令的地址\n指令顺序寻址示意图：\n跳跃指令寻址 程序根据条件需要跳跃执行时采取跳跃寻址，即下一条指令的地址码不是由PC给出，而是由本条指令给出。即本条指令改变PC内数据（因为PC内是下一条指令地址），本条指令执行结束后会跳到PC指向的地址\n跳跃后继续顺序执行指令，PC也要跟着改变\n使用跳跃可以实现程序转移与循环\n指令跳跃寻址示意图：\n操作数隐含寻址 隐含寻址：在指令中不显示给出操作数。如某些单地址指令拥有隐含的操作数AC\n操作数立即寻址 即指令的地址字段给出的不是操作数地址，而是操作数本身。准确来说根本没有寻址\n这种指令执行速度快，不需要访存，取指的同时就取到了操作数\n操作数直接寻址 最“正常”的寻址方式。即指令的操作数字段内容为操作数的地址A，CPU去地址A取出数据D。可以表示为D = (A)，和之前说的一样，括号可以视为C语言中对指针的解引用\n操作数间接寻址 指令的操作数字段给出了地址A1，但是(A1)也是一个指针（地址），指向了另一个地址A2，即A2 = (A1)，地址A2指向的才是数据D，即D = (A2) = ((A1))\n因为地址A2可以有很多位，所以间接寻址可以扩大寻址范围\n需要两次访存，速度慢，早期曾主流，现在已不太使用\n操作数寄存器寻址 指令中地址字段给出的不是内存地址而是CPU中通用寄存器的编号。假设编号为R，则数据D = (R)\n操作数寄存器间接寻址 类似于间接寻址，寄存器R的内容A不是数据而是一个地址。操作数D = (A) = ((R))\n操作数偏移寻址 是直接寻址和寄存器间接寻址方式的结合\n大致思想：目标地址EA = (R) + A，R是一个寄存器的编号，A是指令字中给出的一个偏移量（形式地址），是有符号数，即可以为负\n分为三类：\n相对寻址 即相对于当前PC的寻址。把PC的内容加上偏移量A 优点是程序员不需要使用绝对地址编程 基址寻址 CPU中的基址寄存器的内容加上偏移量A 优点是扩大寻址范围。基址寄存器的位数可以设置的很长 变址寻址 CPU中的变址寄存器的内容加上偏移量A 与基址寻址类似，但是变址寄存器的内容自动递增或递减 使用变址寻址的目的不在于扩大寻址空间，而是实现程序块的规律性变化 操作数段寻址 基于基址寻址。只是把地址空间划分为段\n某计算机有20位地址。容量1MB。以64KB为单位划分为16段。则可以把20位地址划分为一个4位段号和一个16位段内偏移量。CPU内有一个段寄存器保存一个段号，计算地址时把段号左移16位再加上偏移量即可\n堆栈寻址 使用栈，数据的存取只通过栈顶进行。后进先出LIFO\n可以分为：\n寄存器堆栈 存储区域为若干个寄存器。CPU中有一组专门的串联堆栈寄存器，每个寄存器能保存一个字\n入栈和出栈时栈顶不变，数据移动，即栈顶的地址为定值\n优点：访问速度快\n缺点：堆栈大小受限。数据的读出是破坏性的\n存储器堆栈 存储区域为主存的一部分。需要一个堆栈指示器来指示栈顶位置。CPU中有一个专用的寄存器作为堆栈指示器(SP: Stack Point)\n栈顶变化时由SP指示而数据不动\n优点：比串联堆栈灵活。长度几乎不受限。个数也不受限。对存储器寻址的指令对堆栈同样适用\n压栈操作：\n对应的表达式：(A) -\u003e (SP), SP - 1 -\u003e SP。此处使用的策略是栈顶指向空单元，即先压数据再移动指针，栈顶为空。当然也可以使栈顶指向满单元（略）\n弹栈操作：\n对应表达式：SP + 1 -\u003e SP, (SP) -\u003e A。在栈顶指向空单元策略下先移动指针再读取数据\n使用标志位区分寻址方式 即在指令字中除了操作码和操作数地址外给出若干个寻址方式标志位（特征位）来说明寻址方式\n基本寻址方式总结 令指令字中的地址字段为A，R为寄存器，SP为栈顶指针，EA为实际地址，操作数为D，D = (EA)\n方式 算法 优点 缺点 隐含寻址 默认操作数地址 不访存 数据范围受限 立即寻址 D = A 不访存 操作数值范围受限 直接寻址 EA = A 简单 地址范围受限 间接寻址 EA = (A) 地址范围大 多次访存 寄存器寻址 EA = R 不访存 地址范围受限 寄存器间接寻址 EA = ® 地址范围大 访存 偏移寻址 EA = A + ® 灵活 复杂 段寻址 EA = A + ® 灵活 复杂 堆栈寻址 EA = SP 不访存 应用受限 复杂指令系统与精简指令系统 复杂指令系统计算机CISC 指令系统庞大，指令条数可达几百条 指令长度不固定，指令格式种类多，寻址方式种类多 能够访存的指令不受限制 各种指令使用频度差别大 各种指令执行时间差别大，不利于流水线 一般采用微程序控制 难以优化编译生成高效目标代码 复杂指令系统给很多运算设置了独立的指令。比如二进制加减法有指令，十进制加减法也有自己的指令（而不是使用二进制加减法实现），甚至十六进制也有自己的指令。或者乘除法也有自己的指令而不是通过加减法指令实现\n精简指令系统计算机RISC 选取使用频率最高的简单指令，指令条数少 指令长度固定，指令格式种类少，寻址方式种类少 只有取数/存数指令访存。其余指令都在寄存器之间进行 指令功能简单，控制器多使用硬布线 CPU中通用寄存器多，减少访存 大部分指令能在一个机器周期完成，利于流水线 使用硬布线控制逻辑，控制器简单，留出更多芯片空间来实现大容量cache 注重编译的优化 即指实现简单的指令。复杂指令通过简单指令的组合实现\n典型指令 数据传送指令 一般传送 数据交换 堆栈操作 算术运算指令 定点浮点加减乘除 加一、减一 求反、求补 移位、比较 十进制加减 逻辑运算指令 程序控制指令（转移指令） 条件转移 无条件转移 转子程序 返回主程序 中断返回 输入输出指令 串处理指令 串传送 串存储 串加载 串比较 串扫描 特权指令（一般不提供给用于，只能操作系统使用） 系统资源分配管理 系统工作方式设置 用户访问权限检测 段表、页表的修改 任务的创建和切换 其他指令 状态寄存器置位、复位 测试 停机 空操作 ","wordCount":"358","inLanguage":"en","datePublished":"2023-02-21T16:29:43Z","dateModified":"2023-02-21T16:29:43Z","author":{"@type":"Person","name":"Chan"},"mainEntityOfPage":{"@type":"WebPage","@id":"/posts/principles-of-computer-organization/%E7%AC%AC4%E7%AB%A0-%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/"},"publisher":{"@type":"Organization","name":"Home","logo":{"@type":"ImageObject","url":"%3Clink%20/%20abs%20url%3E"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href accesskey=h title="Cheyne16's Blog (Alt + H)"><img src=/apple-touch-icon.png alt aria-label=logo height=35>Cheyne16's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=/categories/ title=categories><span>categories</span></a></li><li><a href=/tags/ title=tags><span>tags</span></a></li><li><a href=https://example.org title=example.org><span>example.org</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href>Home</a>&nbsp;»&nbsp;<a href=/posts/>Posts</a></div><h1 class=post-title>第4章 指令系统</h1><div class=post-meta><span title='2023-02-21 16:29:43 +0000 UTC'>February 21, 2023</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;358 words&nbsp;·&nbsp;Chan&nbsp;|&nbsp;<a href=https://github.com/%3cpath_to_repo%3e/content/posts/Principles%20of%20Computer%20Organization/%e7%ac%ac4%e7%ab%a0%20%e6%8c%87%e4%bb%a4%e7%b3%bb%e7%bb%9f.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=post-content><h2 id=基本概念>基本概念<a hidden class=anchor aria-hidden=true href=#基本概念>#</a></h2><p>**指令(Instruction)**指计算机执行某种操作的命令</p><p>**指令系统（ISA Instruction Set Architecture）**也称 指令集架构，一台计算机中所有机器指令的集合</p><ul><li>高级语言 - 语句和用法与具体机器的指令系统无关</li><li>低级语言 - 面向机器的语言，和具体机器的指令系统密切相关</li></ul><table><thead><tr><th>比较</th><th>高级语言</th><th>低级语言</th></tr></thead><tbody><tr><td>通用算法</td><td>有</td><td>有</td></tr><tr><td>语言规则</td><td>少</td><td>多</td></tr><tr><td>编程需要硬件知识</td><td>不需要</td><td>需要</td></tr><tr><td>独立于机器</td><td>独立</td><td>不独立</td></tr><tr><td>编程难易度</td><td>易</td><td>难</td></tr><tr><td>编程时间</td><td>短</td><td>长</td></tr><tr><td>程序执行时间</td><td>长</td><td>短</td></tr><tr><td>编译过程中对计算机资源的占用</td><td>多</td><td>少</td></tr></tbody></table><h2 id=指令格式>指令格式<a hidden class=anchor aria-hidden=true href=#指令格式>#</a></h2><h3 id=基础>基础<a hidden class=anchor aria-hidden=true href=#基础>#</a></h3><p><strong>指令字</strong>（简称指令），即表示一条指令的机器字（机器码）</p><p>指令的构成：</p><ul><li>操作码字段 - 定义操作</li><li>操作数地址字段 - 指定操作数的地址</li></ul><p><strong>操作码</strong>：表示指令对应的操作。操作码字段的长度取决于计算机指令系统的规模。如某指令系统有8条（种）指令，操作码只需3位即可。指令字中的操作码长度可以使固定的也可以是变长的</p><h3 id=按操作数地址数量分类>按操作数地址数量分类<a hidden class=anchor aria-hidden=true href=#按操作数地址数量分类>#</a></h3><p>按照指令中操作数（地址）的个数X（类似于高级语言中函数的参数），可以把指令称为<strong>X操作数指令</strong>或<strong>X地址指令</strong></p><p>通常指令可以根据操作数地址数量划分为：</p><ul><li>三地址指令</li><li>二地址指令</li><li>一地址指令</li><li>零地址指令</li></ul><p><strong>零地址指令</strong>：只有操作码，没有地址码</p><p><strong>一地址指令</strong>：称为<strong>单操作数指令</strong>，指令中只有一个操作数或者是指令默认以运算器中累加寄存器AC中的数为操作数1，操作结果又放回累加寄存器AC中，类似于高级语言函数中的默认参数。符号表达为<code>(AC) OP (A) -> AC</code>，其中OP表示操作，AC和A表示地址。AC为累加寄存器地址。地址加括号表示取地址中的数据，类似于C语言中对指针的解引用</p><p><strong>二地址指令</strong>：称为<strong>双操作数指令</strong>。两个地址码表明两个操作数的地址，结果存放在其中一个地址处。符号表达为<code>(A1) OP (A2) -> A1</code></p><p><strong>三地址指令</strong>：指令字中有三个操作数地址。符号表达为<code>(A1) OP (A2) -> A3</code>。A1为<strong>被操作数地址</strong>或<strong>源操作数地址</strong>。A1为<strong>操作数地址</strong>或<strong>终点操作数地址</strong>。A3为存放结果的地址</p><h3 id=按照操作数的物理位置分类>按照操作数的物理位置分类<a hidden class=anchor aria-hidden=true href=#按照操作数的物理位置分类>#</a></h3><p>操作数地址可以是存储器地址，也可以是寄存器地址。因此可以把指令分为以下三类</p><ul><li>存储器-存储器(SS)型指令<ul><li>参与操作的数都在内存里需多次访存。慢</li></ul></li><li>寄存器-寄存器(RR)型指令<ul><li>操作数都在寄存器中，从寄存器取操作数，结果也存放在寄存器。速度很快，不需要访存，但需要多个寄存器</li></ul></li><li>寄存器-存储器(RS)型指令。既要访问存储器又要访问寄存器的指令</li></ul><h3 id=指令字长度>指令字长度<a hidden class=anchor aria-hidden=true href=#指令字长度>#</a></h3><p>即指令字中比特的个数</p><p>回忆-机器字长：计算机能处理的二进制数据的位数，决定了计算机的运算精度。<strong>机器字长通常和寄存器的位数一致</strong></p><p>指令分类：</p><ul><li>单字长指令</li><li>半字长指令</li><li>双字长指令</li></ul><p>使用多字长指令，地址的位数更多，能够提供更大的地址空间，但是CPU必须两次或多次访问内存才能取出一条指令，降低了CPU的运算速度</p><h3 id=定长操作码与扩展操作码不定长操作码>定长操作码与扩展操作码（不定长操作码）<a hidden class=anchor aria-hidden=true href=#定长操作码与扩展操作码不定长操作码>#</a></h3><p>定长操作码指令格式：</p><p><img loading=lazy src=https://discretetom.github.io/_nuxt/img/466f972.png alt=4-1></p><p>显而易见的缺点：地址长度不统一（实际计算机中地址长度是统一的），存在没有被使用的位，浪费空间</p><p>所以诞生了变长操作码/扩展操作码：</p><p><img loading=lazy src=https://discretetom.github.io/_nuxt/img/220bdb1.png alt=4-2></p><h2 id=指令助记符>指令助记符<a hidden class=anchor aria-hidden=true href=#指令助记符>#</a></h2><p>典型的指令助记符</p><table><thead><tr><th>典型指令</th><th>助记符</th></tr></thead><tbody><tr><td>加法</td><td>ADD</td></tr><tr><td>减法</td><td>SUB</td></tr><tr><td>传送</td><td>MOV</td></tr><tr><td>跳转</td><td>JMP</td></tr><tr><td>转子</td><td>JSR</td></tr><tr><td>存储</td><td>STR</td></tr><tr><td>读取</td><td>LDA</td></tr></tbody></table><h2 id=指令与数据的寻址方式>指令与数据的寻址方式<a hidden class=anchor aria-hidden=true href=#指令与数据的寻址方式>#</a></h2><p>存储器既可以存放数据，也可以存放指令</p><h3 id=如何区分数据和指令>如何区分数据和指令<a hidden class=anchor aria-hidden=true href=#如何区分数据和指令>#</a></h3><p>从时间来说</p><ul><li>取指令事件发生在<strong>取指周期</strong></li><li>取数据事件发生在<strong>执行周期</strong></li></ul><p>从空间来说</p><ul><li>取出的代码是指令，一定<strong>送往指令寄存器（控制器）</strong></li><li>取出的代码是数据，一定送往<strong>数据寄存器（运算器）</strong></li></ul><h3 id=寻址方式概述>寻址方式概述<a hidden class=anchor aria-hidden=true href=#寻址方式概述>#</a></h3><p>在存储器中，写入或读出操作数/指令字的方式：</p><ul><li>地址指定方式（<strong>几乎所有计算机都采用这种方式</strong>）</li><li>相联存储方式</li><li>堆栈存取方式</li></ul><p>当<strong>采用地址指定方式</strong>时，<strong>形成操作数或指令地址的方式</strong>，称为<strong>寻址方式</strong></p><p>寻址方式：</p><ul><li>指令寻址方式（简单）<ul><li>顺序寻址方式</li><li>跳跃寻址方式</li></ul></li><li>数据（操作数）寻址方式（复杂）<ul><li>隐含寻址</li><li>立即寻址</li><li>直接寻址</li><li>间接寻址</li><li>寄存器寻址</li><li>寄存器间接寻址</li><li>偏移寻址<ul><li>相对寻址</li><li>基址寻址</li><li>变址寻址</li></ul></li><li>段寻址</li><li>堆栈寻址</li></ul></li></ul><h3 id=顺序指令寻址>顺序指令寻址<a hidden class=anchor aria-hidden=true href=#顺序指令寻址>#</a></h3><p>通常执行程序时是一条指令接一条指令的顺序执行</p><p>从内存取出第一条指令，然后执行，然后取出第二条，然后执行，然后取出第三条，然后执行。。。</p><p>需要使用<strong>程序计数器PC（又称指令指针寄存器）</strong> <strong>存放下一条指令</strong>的地址</p><p>指令顺序寻址示意图：</p><p><img loading=lazy src=https://discretetom.github.io/_nuxt/img/129f096.png alt=4-3></p><h3 id=跳跃指令寻址>跳跃指令寻址<a hidden class=anchor aria-hidden=true href=#跳跃指令寻址>#</a></h3><p>程序根据条件需要跳跃执行时采取跳跃寻址，即下一条指令的地址码不是由PC给出，而是由本条指令给出。即<strong>本条指令改变PC内数据</strong>（因为PC内是下一条指令地址），本条指令执行结束后会跳到PC指向的地址</p><p>跳跃后继续顺序执行指令，PC也要跟着改变</p><p>使用跳跃可以实现程序转移与循环</p><p>指令跳跃寻址示意图：</p><p><img loading=lazy src=https://discretetom.github.io/_nuxt/img/0fb28b5.png alt=4-4></p><h3 id=操作数隐含寻址>操作数隐含寻址<a hidden class=anchor aria-hidden=true href=#操作数隐含寻址>#</a></h3><p>隐含寻址：在指令中不显示给出操作数。如某些单地址指令拥有隐含的操作数AC</p><h3 id=操作数立即寻址>操作数立即寻址<a hidden class=anchor aria-hidden=true href=#操作数立即寻址>#</a></h3><p>即<strong>指令的地址字段给出的不是操作数地址，而是操作数本身</strong>。准确来说根本没有寻址</p><p>这种指令执行速度快，不需要访存，取指的同时就取到了操作数</p><h3 id=操作数直接寻址>操作数直接寻址<a hidden class=anchor aria-hidden=true href=#操作数直接寻址>#</a></h3><p>最“正常”的寻址方式。即指令的操作数字段内容为操作数的地址A，CPU去地址A取出数据D。可以表示为<code>D = (A)</code>，和之前说的一样，括号可以视为C语言中对指针的解引用</p><h3 id=操作数间接寻址>操作数间接寻址<a hidden class=anchor aria-hidden=true href=#操作数间接寻址>#</a></h3><p>指令的操作数字段给出了地址A1，但是<code>(A1)</code>也是一个指针（地址），指向了另一个地址A2，即<code>A2 = (A1)</code>，地址A2指向的才是数据D，即<code>D = (A2) = ((A1))</code></p><p>因为地址A2可以有很多位，所以间接寻址可以扩大寻址范围</p><p>需要两次访存，速度慢，早期曾主流，现在已不太使用</p><h3 id=操作数寄存器寻址>操作数寄存器寻址<a hidden class=anchor aria-hidden=true href=#操作数寄存器寻址>#</a></h3><p>指令中地址字段给出的不是内存地址而是CPU中通用寄存器的<strong>编号</strong>。假设编号为R，则数据<code>D = (R)</code></p><h3 id=操作数寄存器间接寻址>操作数寄存器间接寻址<a hidden class=anchor aria-hidden=true href=#操作数寄存器间接寻址>#</a></h3><p>类似于间接寻址，寄存器R的内容A不是数据而是一个地址。操作数<code>D = (A) = ((R))</code></p><h3 id=操作数偏移寻址>操作数偏移寻址<a hidden class=anchor aria-hidden=true href=#操作数偏移寻址>#</a></h3><p>是<strong>直接寻址</strong>和<strong>寄存器间接寻址</strong>方式的结合</p><p>大致思想：目标地址<code>EA = (R) + A</code>，R是一个寄存器的编号，A是指令字中给出的一个<strong>偏移量（形式地址）</strong>，是<strong>有符号数</strong>，即<strong>可以为负</strong></p><p>分为三类：</p><ul><li>相对寻址<ul><li>即相对于当前PC的寻址。把PC的内容加上偏移量A</li><li>优点是程序员不需要使用绝对地址编程</li></ul></li><li>基址寻址<ul><li>CPU中的<strong>基址寄存器</strong>的内容加上偏移量A</li><li>优点是扩大寻址范围。基址寄存器的位数可以设置的很长</li></ul></li><li>变址寻址<ul><li>CPU中的<strong>变址寄存器</strong>的内容加上偏移量A</li><li>与基址寻址类似，但是<strong>变址寄存器的内容自动递增或递减</strong></li><li>使用变址寻址的目的不在于扩大寻址空间，而是实现<strong>程序块</strong>的<strong>规律性变化</strong></li></ul></li></ul><h3 id=操作数段寻址>操作数段寻址<a hidden class=anchor aria-hidden=true href=#操作数段寻址>#</a></h3><p>基于基址寻址。只是把地址空间划分为段</p><p>某计算机有20位地址。容量1MB。以64KB为单位划分为16段。则可以把20位地址划分为一个4位段号和一个16位段内偏移量。CPU内有一个<strong>段寄存器</strong>保存一个段号，计算地址时把段号左移16位再加上偏移量即可</p><h3 id=堆栈寻址>堆栈寻址<a hidden class=anchor aria-hidden=true href=#堆栈寻址>#</a></h3><p>使用栈，数据的存取只通过栈顶进行。后进先出LIFO</p><p>可以分为：</p><ul><li><strong>寄存器堆栈</strong></li></ul><p>存储区域为若干个寄存器。CPU中有一组专门的<strong>串联堆栈寄存器</strong>，每个寄存器能保存一个字</p><p>入栈和出栈时<strong>栈顶不变，数据移动</strong>，即栈顶的地址为定值</p><p><img loading=lazy src=https://discretetom.github.io/_nuxt/img/5db7883.png alt=4-6></p><p>优点：访问速度快</p><p>缺点：堆栈大小受限。<strong>数据的读出是破坏性的</strong></p><ul><li><strong>存储器堆栈</strong></li></ul><p>存储区域为主存的一部分。需要一个<strong>堆栈指示器</strong>来指示栈顶位置。CPU中有一个专用的寄存器作为堆栈指示器(SP: Stack Point)</p><p>栈顶变化时由SP指示而数据不动</p><p>优点：比串联堆栈灵活。长度几乎不受限。个数也不受限。对存储器寻址的指令对堆栈同样适用</p><p>压栈操作：</p><p><img loading=lazy src=https://discretetom.github.io/_nuxt/img/26d2860.png alt=4-7></p><p>对应的表达式：<code>(A) -> (SP), SP - 1 -> SP</code>。此处使用的策略是<strong>栈顶指向空单元</strong>，即<strong>先压数据再移动指针</strong>，<strong>栈顶为空</strong>。当然也可以使<strong>栈顶指向满单元</strong>（略）</p><p>弹栈操作：</p><p><img loading=lazy src=https://discretetom.github.io/_nuxt/img/d8f5ad8.png alt=4-8></p><p>对应表达式：<code>SP + 1 -> SP, (SP) -> A</code>。在栈顶指向空单元策略下<strong>先移动指针再读取数据</strong></p><h3 id=使用标志位区分寻址方式>使用标志位区分寻址方式<a hidden class=anchor aria-hidden=true href=#使用标志位区分寻址方式>#</a></h3><p><img loading=lazy src=https://discretetom.github.io/_nuxt/img/9974387.png alt=4-5></p><p>即在指令字中除了操作码和操作数地址外给出若干个寻址方式标志位（特征位）来说明寻址方式</p><h3 id=基本寻址方式总结>基本寻址方式总结<a hidden class=anchor aria-hidden=true href=#基本寻址方式总结>#</a></h3><p>令指令字中的地址字段为A，R为寄存器，SP为栈顶指针，EA为实际地址，操作数为D，<code>D = (EA)</code></p><table><thead><tr><th>方式</th><th>算法</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>隐含寻址</td><td>默认操作数地址</td><td>不访存</td><td>数据范围受限</td></tr><tr><td>立即寻址</td><td>D = A</td><td>不访存</td><td>操作数值范围受限</td></tr><tr><td>直接寻址</td><td>EA = A</td><td>简单</td><td>地址范围受限</td></tr><tr><td>间接寻址</td><td>EA = (A)</td><td>地址范围大</td><td>多次访存</td></tr><tr><td>寄存器寻址</td><td>EA = R</td><td>不访存</td><td>地址范围受限</td></tr><tr><td>寄存器间接寻址</td><td>EA = ®</td><td>地址范围大</td><td>访存</td></tr><tr><td>偏移寻址</td><td>EA = A + ®</td><td>灵活</td><td>复杂</td></tr><tr><td>段寻址</td><td>EA = A + ®</td><td>灵活</td><td>复杂</td></tr><tr><td>堆栈寻址</td><td>EA = SP</td><td>不访存</td><td>应用受限</td></tr></tbody></table><h2 id=复杂指令系统与精简指令系统>复杂指令系统与精简指令系统<a hidden class=anchor aria-hidden=true href=#复杂指令系统与精简指令系统>#</a></h2><h3 id=复杂指令系统计算机cisc>复杂指令系统计算机CISC<a hidden class=anchor aria-hidden=true href=#复杂指令系统计算机cisc>#</a></h3><ul><li>指令系统庞大，指令条数可达几百条</li><li>指令长度不固定，指令格式种类多，寻址方式种类多</li><li>能够访存的指令不受限制</li><li>各种指令使用频度差别大</li><li>各种指令执行时间差别大，不利于流水线</li><li>一般采用微程序控制</li><li>难以优化编译生成高效目标代码</li></ul><p>复杂指令系统给很多运算设置了独立的指令。比如二进制加减法有指令，十进制加减法也有自己的指令（而不是使用二进制加减法实现），甚至十六进制也有自己的指令。或者乘除法也有自己的指令而不是通过加减法指令实现</p><h3 id=精简指令系统计算机risc>精简指令系统计算机RISC<a hidden class=anchor aria-hidden=true href=#精简指令系统计算机risc>#</a></h3><ul><li>选取使用频率最高的简单指令，<strong>指令条数少</strong></li><li><strong>指令长度固定，指令格式种类少，寻址方式种类少</strong></li><li><strong>只有取数/存数指令访存</strong>。其余指令都在寄存器之间进行</li><li><strong>指令功能简单，控制器多使用硬布线</strong></li><li>CPU中通用寄存器多，减少访存</li><li>大部分指令能在一个机器周期完成，利于流水线</li><li>使用硬布线控制逻辑，控制器简单，留出更多芯片空间来实现大容量cache</li><li>注重编译的优化</li></ul><p>即指实现简单的指令。复杂指令通过简单指令的组合实现</p><h2 id=典型指令>典型指令<a hidden class=anchor aria-hidden=true href=#典型指令>#</a></h2><ul><li>数据传送指令<ul><li>一般传送</li><li>数据交换</li><li>堆栈操作</li></ul></li><li>算术运算指令<ul><li>定点浮点加减乘除</li><li>加一、减一</li><li>求反、求补</li><li>移位、比较</li><li>十进制加减</li></ul></li><li>逻辑运算指令</li><li>程序控制指令（转移指令）<ul><li>条件转移</li><li>无条件转移</li><li>转子程序</li><li>返回主程序</li><li>中断返回</li></ul></li><li>输入输出指令</li><li>串处理指令<ul><li>串传送</li><li>串存储</li><li>串加载</li><li>串比较</li><li>串扫描</li></ul></li><li>特权指令（一般不提供给用于，只能操作系统使用）<ul><li>系统资源分配管理</li><li>系统工作方式设置</li><li>用户访问权限检测</li><li>段表、页表的修改</li><li>任务的创建和切换</li></ul></li><li>其他指令<ul><li>状态寄存器置位、复位</li><li>测试</li><li>停机</li><li>空操作</li></ul></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=/tags/principles-of-computer-organization/>Principles of Computer Organization</a></li></ul><nav class=paginav><a class=prev href=/posts/principles-of-computer-organization/%E7%AC%AC3%E7%AB%A0-%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/><span class=title>« Prev</span><br><span>第3章 存储系统</span></a>
<a class=next href=/posts/principles-of-computer-organization/%E7%AC%AC5%E7%AB%A0-%E4%B8%AD%E5%A4%AE%E5%A4%84%E7%90%86%E5%99%A8/><span class=title>Next »</span><br><span>第5章 中央处理器</span></a></nav><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share 第4章 指令系统 on twitter" href="https://twitter.com/intent/tweet/?text=%e7%ac%ac4%e7%ab%a0%20%e6%8c%87%e4%bb%a4%e7%b3%bb%e7%bb%9f&url=%2fposts%2fprinciples-of-computer-organization%2f%25E7%25AC%25AC4%25E7%25AB%25A0-%25E6%258C%2587%25E4%25BB%25A4%25E7%25B3%25BB%25E7%25BB%259F%2f&hashtags=PrinciplesofComputerOrganization"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share 第4章 指令系统 on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=%2fposts%2fprinciples-of-computer-organization%2f%25E7%25AC%25AC4%25E7%25AB%25A0-%25E6%258C%2587%25E4%25BB%25A4%25E7%25B3%25BB%25E7%25BB%259F%2f&title=%e7%ac%ac4%e7%ab%a0%20%e6%8c%87%e4%bb%a4%e7%b3%bb%e7%bb%9f&summary=%e7%ac%ac4%e7%ab%a0%20%e6%8c%87%e4%bb%a4%e7%b3%bb%e7%bb%9f&source=%2fposts%2fprinciples-of-computer-organization%2f%25E7%25AC%25AC4%25E7%25AB%25A0-%25E6%258C%2587%25E4%25BB%25A4%25E7%25B3%25BB%25E7%25BB%259F%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share 第4章 指令系统 on reddit" href="https://reddit.com/submit?url=%2fposts%2fprinciples-of-computer-organization%2f%25E7%25AC%25AC4%25E7%25AB%25A0-%25E6%258C%2587%25E4%25BB%25A4%25E7%25B3%25BB%25E7%25BB%259F%2f&title=%e7%ac%ac4%e7%ab%a0%20%e6%8c%87%e4%bb%a4%e7%b3%bb%e7%bb%9f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share 第4章 指令系统 on facebook" href="https://facebook.com/sharer/sharer.php?u=%2fposts%2fprinciples-of-computer-organization%2f%25E7%25AC%25AC4%25E7%25AB%25A0-%25E6%258C%2587%25E4%25BB%25A4%25E7%25B3%25BB%25E7%25BB%259F%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share 第4章 指令系统 on whatsapp" href="https://api.whatsapp.com/send?text=%e7%ac%ac4%e7%ab%a0%20%e6%8c%87%e4%bb%a4%e7%b3%bb%e7%bb%9f%20-%20%2fposts%2fprinciples-of-computer-organization%2f%25E7%25AC%25AC4%25E7%25AB%25A0-%25E6%258C%2587%25E4%25BB%25A4%25E7%25B3%25BB%25E7%25BB%259F%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share 第4章 指令系统 on telegram" href="https://telegram.me/share/url?text=%e7%ac%ac4%e7%ab%a0%20%e6%8c%87%e4%bb%a4%e7%b3%bb%e7%bb%9f&url=%2fposts%2fprinciples-of-computer-organization%2f%25E7%25AC%25AC4%25E7%25AB%25A0-%25E6%258C%2587%25E4%25BB%25A4%25E7%25B3%25BB%25E7%25BB%259F%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></div></footer></article></main><footer class=footer><span>&copy; 2023 <a href>Home</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>